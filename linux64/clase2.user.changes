

----SNAPSHOT----(16 August 2019 05:58:17) clase2.image priorSource: 12628964!

----STARTUP---- (16 August 2019 22:19:26) as /home/marcos/Desktop/isw1/linux64/clase2.image!

!AlonsoChurch class methodsFor: 'nil' stamp: 'MB 8/16/2019 22:24:11'!
ageDifferenceWith: AlonsoChurch

	^'g'! !
!AlonsoChurch class methodsFor: 'as yet unclassified' stamp: 'MB 8/16/2019 22:24:53' prior: 50726512!
ageDifferenceWith: aMessage

	^self dateOfBirth distanceTo: aMessage dateOfBirth! !

AlonsoChurch ageDifferenceWith: AlanTuring !

#dateOfBirth asMessage sendTo: AlanTuring.!

(#ageDifferenceWith: asMessageWith: AlanTuring) sendTo: AlonsoChurch !
!AlonsoChurch class methodsFor: 'as yet unclassified' stamp: 'MB 8/16/2019 22:26:39' prior: 50726517!
ageDifferenceWith: aPerson

	^self dateOfBirth distanceTo: aPerson dateOfBirth! !

#dateOfBirth asMessage.!

#ageDifferenceWith: asMessageWith: AlanTuring.!

AlanTuring. !

#dateOfBirth asMessage.!

self sendTo: AlanTuring!

self sendTo: AlonsoChurch!

self sendTo: AlanKay!

AlanTuring methodNamed: #dateOfBirth.!

AlonsoChurch methodNamed: #dateOfBirth.!

AlanTuring methodNamed: #dateOfBirth. !

self sourceCode.!

self linesOfCode.!

self valueWithReceiver: AlanTuring arguments: #().!

self valueWithReceiver: AlonsoChurch arguments: #().!

----STARTUP---- (18 August 2019 08:03:28) as /home/marcos/Desktop/isw1/linux64/clase2.image!


AlanKay
	collaboratorNames: 'currentCompany'
	in: 'DenotativeObject-TestSupport'!

!classDefinition: #AlanKay category: #'DenotativeObject-TestSupport'!
DenotativeObject subclass: #AlanKay
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'AlanKay class' category: #'DenotativeObject-TestSupport'!
AlanKay class
	instanceVariableNames: 'currentCompany'!

AlanKay !

AlanKay collaboratorNamed: 'currentCompany'!

self value.!

self value: 'VPRI'.!

self value.!

AlanKay !
!AlonsoChurch class methodsFor: 'nil' stamp: 'MB 8/18/2019 08:17:11'!
isBiggerThan: aPerson
    ^(self ageDifferenceWith: aPerson) positive! !
!AlonsoChurch class methodsFor: 'nil' stamp: 'MB 8/18/2019 08:20:19'!
ageDifferenceWith: aPerson
	^ self dateOfBirth - aPerson dateOfBirth! !

AlonsoChurch ageDifferenceWith: AlanTuring!
!AlonsoChurch class methodsFor: 'as yet unclassified' stamp: 'MB 8/18/2019 08:20:55' prior: 50726573!
ageDifferenceWith: aPerson
	^ (self dateOfBirth - aPerson dateOfBirth)! !

AlonsoChurch ageDifferenceWith: AlanTuring!
!AlonsoChurch class methodsFor: 'as yet unclassified' stamp: 'MB 8/18/2019 08:21:31' prior: 50726580!
ageDifferenceWith: aPerson
	^ (self dateOfBirth) - (aPerson dateOfBirth)! !

AlonsoChurch ageDifferenceWith: AlanTuring!
!AlonsoChurch class methodsFor: 'as yet unclassified' stamp: 'MB 8/18/2019 08:21:49' prior: 50726587!
ageDifferenceWith: aPerson
	^ ((self dateOfBirth) - (aPerson dateOfBirth))! !

AlonsoChurch ageDifferenceWith: AlanTuring!
!AlonsoChurch class methodsFor: 'as yet unclassified' stamp: 'MB 8/18/2019 08:22:33' prior: 50726594!
ageDifferenceWith: aPerson
	^ ((self dateOfBirth) distanceTo: (aPerson dateOfBirth))! !

AlonsoChurch ageDifferenceWith: AlanTuring!
!AlonsoChurch class methodsFor: 'nil' stamp: 'MB 8/18/2019 08:28:24'!
m1: collaborator1
   | temp1 |

   ^thisContext! !

self tempsAndValues. !

self tempAt: 1. !

self tempAt: 2. !

self tempAt: 2 put: 20. !

self tempAt: 2. !

AlonsoChurch!
!AlonsoChurch class methodsFor: 'as yet unclassified' stamp: 'MB 8/18/2019 08:41:42' prior: 50726602!
ageDifferenceWith: aPerson
	^ ((self dateOfBirth) distanceTo: (aPerson dateOfBirth))! !

AlonsoChurch ageDifferenceWith: AlanTuring  !

----QUIT----(18 August 2019 09:24:03) clase2.image priorSource: 12635381!

----STARTUP---- (18 August 2019 12:52:23) as /home/marcos/Desktop/isw1/linux64/clase2.image!


list size!

self setSelectionIndex: 1.!

self setSelectionIndex: 3.!

self selection: #fail.!

self setSelectionIndex: 1.!

 true !

self setSelectionIndex: 3.!

self selection: #fail.!

self setSelectionIndex: 3. true !

self setSelectionIndex: 100. !

self setSelectionIndex: 10000.  true !

self setSelectionIndex: -1. !

browse !

self selection: Assert!

self selection: Assert!

self selection: #Assert!

self selection: #fail!

self selection: #self!

self send.!

self browseMethodFull!

Assert browseMethodFull!

DenotativeObject browseMethodFull!

self clone!

Assert clone!

DenotativeObject subclass: #Assert1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: #Assert1 category: #'DenotativeObject-TestSupport'!
DenotativeObject subclass: #Assert1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

Assert1 class
	instanceVariableNames: ''!

!classDefinition: 'Assert1 class' category: #'DenotativeObject-TestSupport'!
Assert1 class
	instanceVariableNames: ''!
!Assert1 class methodsFor: 'descriptions' stamp: 'MB 8/18/2019 14:09:24'!
comparingStringBetween: actual and: expected

	^ String streamContents: [:stream |
		stream
			nextPutAll: 'Expected ';
			nextPutAll: (expected printStringLimitedTo: 50);
			nextPutAll: ' but was ';
			nextPutAll: (actual printStringLimitedTo: 50);
			nextPutAll: '.'
		]! !
!Assert1 class methodsFor: 'descriptions' stamp: 'MB 8/18/2019 14:09:24'!
defaultAssertionFailedDescription
	
	^'Assertion failed'! !
!Assert1 class methodsFor: 'descriptions' stamp: 'MB 8/18/2019 14:09:24'!
defaultIdenticalFailureDescription
	
	^'Objects are not identical'! !
!Assert1 class methodsFor: 'descriptions' stamp: 'MB 8/18/2019 14:09:24'!
defaultNotEqualsFaillureDescription
	
	^'Expected to be different but they are equal'! !
!Assert1 class methodsFor: 'descriptions' stamp: 'MB 8/18/2019 14:09:24'!
defaultNotIdenticalFailureDescription
	
	^'Expected to be not identical but they are identical'! !
!Assert1 class methodsFor: 'descriptions' stamp: 'MB 8/18/2019 14:09:24'!
failDescription
	
	^'Failed'! !
!Assert1 class methodsFor: 'descriptions' stamp: 'MB 8/18/2019 14:09:24'!
shouldNotSignalFailureDescription
	
	^'Exception was signal when not expected to'! !
!Assert1 class methodsFor: 'boolean assertions' stamp: 'MB 8/18/2019 14:09:24'!
fail
	
	self isTrue: false description: self failDescription! !
!Assert1 class methodsFor: 'boolean assertions' stamp: 'MB 8/18/2019 14:09:24'!
isFalse: aBooleanOrBlock

	^self isFalse: aBooleanOrBlock description: self defaultAssertionFailedDescription ! !
!Assert1 class methodsFor: 'boolean assertions' stamp: 'MB 8/18/2019 14:09:24'!
isFalse: aBooleanOrBlock description: aFailureDescription

	self isTrue: aBooleanOrBlock value not description: aFailureDescription ! !
!Assert1 class methodsFor: 'boolean assertions' stamp: 'MB 8/18/2019 14:09:24'!
isTrue: aBooleanOrBlock

	self isTrue: aBooleanOrBlock description: self defaultAssertionFailedDescription
! !
!Assert1 class methodsFor: 'boolean assertions' stamp: 'MB 8/18/2019 14:09:24'!
isTrue: aBooleanOrBlock description: aFailureDescription
 
	aBooleanOrBlock value ifFalse: [ self signalFailure: aFailureDescription ]
! !
!Assert1 class methodsFor: 'expected exception assertions' stamp: 'MB 8/18/2019 14:09:24'!
should: aBlockClosure signal: anExceptionHandlingCondition withDescription: exceptionDescription

	self should: aBlockClosure signal: anExceptionHandlingCondition withDescription: exceptionDescription asserting: [:anException | ]! !
!Assert1 class methodsFor: 'expected exception assertions' stamp: 'MB 8/18/2019 14:09:24'!
should: aBlockClosure signal: anExceptionHandlingCondition withDescription: exceptionDescription asserting: assertionsBlock

	| signaledException |
	
	signaledException := nil.
	aBlockClosure 
		on: anExceptionHandlingCondition - MessageNotUnderstood 
		do: [ :anException | 
			signaledException := anException.
			anException return: nil ].
		
	signaledException isNil 
		ifTrue: [ self fail ]
		ifFalse: [ 
			self that: signaledException messageText isEqualTo: exceptionDescription.
			assertionsBlock value: signaledException ]
		! !
!Assert1 class methodsFor: 'expected exception assertions' stamp: 'MB 8/18/2019 14:09:24'!
shouldNot: aBlockClosure signal: anExceptionHandlingCondition

	| handledException |
	
	handledException := false.
	aBlockClosure 
		on: anExceptionHandlingCondition 
		do: [ :anException | handledException := true ].
		
	self isFalse: handledException description: self shouldNotSignalFailureDescription! !
!Assert1 class methodsFor: 'private - signal failure' stamp: 'MB 8/18/2019 14:09:24'!
signalFailure: aDescription

	Error signal: aDescription! !
!Assert1 class methodsFor: 'equality assertions' stamp: 'MB 8/18/2019 14:09:24'!
that: actual isEqualTo: expected
 
	self that: actual isEqualTo: expected description: (self comparingStringBetween: actual and: expected)! !
!Assert1 class methodsFor: 'equality assertions' stamp: 'MB 8/18/2019 14:09:24'!
that: actual isEqualTo: expected description: failureDescription 

	self isTrue: (actual isEqualTo: expected) description: failureDescription ! !
!Assert1 class methodsFor: 'equality assertions' stamp: 'MB 8/18/2019 14:09:24'!
that: actual isNotEqualTo: expected
 
	self that: actual isNotEqualTo: expected description: self defaultNotEqualsFaillureDescription ! !
!Assert1 class methodsFor: 'equality assertions' stamp: 'MB 8/18/2019 14:09:24'!
that: actual isNotEqualTo: expected description: failureDescription 
 
	self isTrue: (actual isNotEqualTo: expected) description: failureDescription ! !
!Assert1 class methodsFor: 'identity assertions' stamp: 'MB 8/18/2019 14:09:24'!
that: actual isIdenticalTo: expected

	self that: actual isIdenticalTo: expected description: self defaultIdenticalFailureDescription 
! !
!Assert1 class methodsFor: 'identity assertions' stamp: 'MB 8/18/2019 14:09:24'!
that: actual isIdenticalTo: expected description: failureDescription

	self isTrue: (actual isIdenticalTo: expected) description: failureDescription! !
!Assert1 class methodsFor: 'identity assertions' stamp: 'MB 8/18/2019 14:09:24'!
that: actual isNotIdenticalTo: expected
 
	self that: actual isNotIdenticalTo: expected description: self defaultNotIdenticalFailureDescription
! !
!Assert1 class methodsFor: 'identity assertions' stamp: 'MB 8/18/2019 14:09:24'!
that: actual isNotIdenticalTo: expected description: failureDescription

	self isTrue: (actual isNotIdenticalTo: expected) description: failureDescription ! !

Smalltalk removeClassNamed: #Assert1!

Browser selection: Assert.!

Browser selection: #Assert.!

Browser selection: #fail.!

DenotativeObject selection: #fail.!

DenotativeObject selection: #Assert!

self send.!

self send.!

self send.!

self send.!

self send. !

self send. !

self send. !

self send. !

self send. !

self send. !

self send.!

self send.!

self send.!

self send.!

self send. nil !

 nil !

 nil !

 nil !

 nil !

 nil !

 nil !

 nil !

self send. nil !

self send.!

self send. !

self send.!

self send. !

self send.!

self send. !

self send.!

self send.!

self send.!

self send.!

self send.!

self send. !

self send.!

self send.!

self send.!

self send.!

self send.!

self send.!

self send. !

self send.!

self send.!

self send.!

self send.!

self send.!

self send.!

self send.!

self send.!

self send.!

self send.!

layoutMorph selection: #Restart.!

self restart!

self send. !

self send.!

self send.!

self send.!

self restart !

self browse.!

self browse.!

10 factorial.!

[ 10 factorial ].!

[ 10 factorial ] value.!

[ :anInteger | anInteger factorial ] value: 10.!

[ :anInteger | anInteger factorial ] value: 100.!

factorialBlock := [ :anInteger | anInteger factorial ].!

factorialBlock value: 10.!

factorialSumBlock value: 10 value: 20.!

factorialSumBlock valueWithArguments: #(10 20)!

factorialSumBlock := [ :anIntegerToFact1 :anIntegerToFact2 | anIntegerToFact1 factorial + anIntegerToFact2 factorial ].!

factorialSumBlock value: 10 value: 20.!

factorialSumBlock valueWithArguments: #(10 20) nil !

factorialSumBlock valueWithArguments: #(10 20)!

   anAdderPlusTen := anAdder + 10.!

plusTenByTwentyBlock value: 5.!

plusTenByTwentyBlock value: 5.!

plusTenByTwentyBlock := [ :anAdder | | anAdderPlusTen | anAdderPlusTen := anAdder + 10. anAdderPlusTen * 20].!

plusTenByTwentyBlock value: 5.!

plusTenByTwentyBlock value: 100.!

DenotativeObject subclass: #cloneOfAlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: #cloneOfAlonsoChurch category: #'DenotativeObject-TestSupport'!
DenotativeObject subclass: #cloneOfAlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

cloneOfAlonsoChurch class
	instanceVariableNames: ''!

!classDefinition: 'cloneOfAlonsoChurch class' category: #'DenotativeObject-TestSupport'!
cloneOfAlonsoChurch class
	instanceVariableNames: ''!
!cloneOfAlonsoChurch class methodsFor: 'as yet unclassified' stamp: 'MB 8/18/2019 15:50:02'!
ageDifferenceWith: aPerson
	^ ((self dateOfBirth) distanceTo: (aPerson dateOfBirth))! !
!cloneOfAlonsoChurch class methodsFor: 'as yet unclassified' stamp: 'MB 8/18/2019 15:50:02'!
ageDifferenceWithAlanTuring

	^self dateOfBirth distanceTo:  AlanTuring dateOfBirth! !
!cloneOfAlonsoChurch class methodsFor: 'as yet unclassified' stamp: 'MB 8/18/2019 15:50:02'!
dateOfBirth
	^June/14/1903! !
!cloneOfAlonsoChurch class methodsFor: 'as yet unclassified' stamp: 'MB 8/18/2019 15:50:02'!
isBiggerThan: aPerson
    ^(self ageDifferenceWith: aPerson) positive! !
!cloneOfAlonsoChurch class methodsFor: 'as yet unclassified' stamp: 'MB 8/18/2019 15:50:02'!
m1: collaborator1
   | temp1 |

   ^thisContext! !

(June/23/2019) = (June/23/2019).!

(June/23/2019) == (June/23/2019).!

100 factorial = 100 factorial.!

100 factorial == 100 factorial.!

('ho','la') = ('ho','la').  !

('ho','la') == ('ho', 'la').!

----QUIT----(18 August 2019 16:01:02) clase2.image priorSource: 12639174!

----STARTUP---- (18 August 2019 23:18:32) as /home/marcos/Desktop/isw1/linux64/clase2.image!


self mouseStillDown. !

self mouseStillDown. !

self mouseStillDown. !

self mouseStillDown. !

self mouseStillDown. !

self mouseStillDown!

self mouseStillDown. !

self mouseStillDown. !

 self mouseStillDown. !

 self mouseStillDown. !

 self mouseStillDown. !

 self mouseStillDown. !

 self mouseStillDown. !

----QUIT----(18 August 2019 23:35:15) clase2.image priorSource: 12649978!

----STARTUP---- (19 August 2019 01:41:13) as /home/marcos/Desktop/isw1/linux64/clase2.image!


self browseMethodFull.!

self browseMethodFull !

Assert
	collaboratorNames: ''
	in: 'DenotativeObject-TestSupport'!

!classDefinition: #Assert category: #'DenotativeObject-TestSupport'!
DenotativeObject subclass: #Assert
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'Assert class' category: #'DenotativeObject-TestSupport'!
Assert class
	instanceVariableNames: ''!

----QUIT----(19 August 2019 02:10:51) clase2.image priorSource: 12650463!                                                                                                                                                                          

----STARTUP---- (26 August 2019 17:31:09) as /home/marcos/Desktop/isw1/linux64/clase2.image!


----End fileIn of /home/marcos/Desktop/isw1/linux64/Tercera Actividad.st----!
!Bill class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 17:36:53' prior: 50727025!
caminar: unaCantidadDeKilometros

	energia - unaCantidadDeKilometros - 3 < 0 ifTrue: [ ^'error'] ifFalse: [energia _ energia - unaCantidadDeKilometros - 3 ].! !

Bill energia. !

Bill caminar: 100000000.!

Bill caminar: 10. 'error' !

Bill caminar: 10.!

Bill energia!

Bill caminar: 1. !

----SNAPSHOT----(26 August 2019 17:39:58) clase2.image priorSource: 12651260!
!Bill class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 17:41:59' prior: 50727053!
caminar: unaCantidadDeKilometros

	energia - unaCantidadDeKilometros - 3 < 0 ifTrue: [ ^Error] ifFalse: [energia _ energia - unaCantidadDeKilometros - 3 ].
	energia = 0 ifTrue: ['matar'] ifFalse:[].! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 17:42:14' prior: 50727068!
caminar: unaCantidadDeKilometros

	energia - unaCantidadDeKilometros - 3 < 0 ifTrue: [ ^Error] ifFalse: [energia _ energia - unaCantidadDeKilometros - 3 ].
	energia = 0 ifTrue: ['matar'] ifFalse: [].! !

Bill energia. !

Bill comer: 1.!
!Bill class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 17:43:30' prior: 50727078!
caminar: unaCantidadDeKilometros

	energia - unaCantidadDeKilometros - 3 < 0 ifTrue: [ ^Error] ifFalse: [energia _ energia - unaCantidadDeKilometros - 3 ].
	energia = 0 ifTrue: [^'matar'] ifFalse: [].! !

----SNAPSHOT----(26 August 2019 17:43:34) clase2.image priorSource: 12653248!
!Bill class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 17:47:15' prior: 50727089!
caminar: unaCantidadDeKilometros

	energia - unaCantidadDeKilometros - 3 < 0 ifTrue: [ ^self Error] ifFalse: [energia _ energia - unaCantidadDeKilometros - 3 ].
	energia = 0 ifTrue: [^'matar'] ifFalse: [].! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:00:42' prior: 50727101!
caminar: unaCantidadDeKilometros

	energia - unaCantidadDeKilometros - 3 < 0 ifTrue: [self Error] ifFalse: [energia _ energia - unaCantidadDeKilometros - 3 ].
	energia = 0 ifTrue: [self removeFromSystem].! !

----SNAPSHOT----(26 August 2019 18:00:50) clase2.image priorSource: 12654315!

Bill energia !

Bill energia !

Bill energia !
!Bill class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:01:34' prior: 50727111!
caminar: unaCantidadDeKilometros

	energia - unaCantidadDeKilometros - 3 < 0 ifTrue: [self Error] ifFalse: [energia _ energia - unaCantidadDeKilometros - 3 ].
	energia = 5 ifTrue: [self removeFromSystem].! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:01:50' prior: 50727125!
caminar: unaCantidadDeKilometros

	energia - unaCantidadDeKilometros - 3 < 0 ifTrue: [self Error] ifFalse: [energia _ energia - unaCantidadDeKilometros - 3 ].
	energia = 0 ifTrue: [self removeFromSystem].! !

----SNAPSHOT----(26 August 2019 18:02:08) clase2.image priorSource: 12655023!

Bill comer: 2.!

Bill energia.!

Bill caminar: 10.!

Smalltalk removeClassNamed: #Bill!

----STARTUP---- (26 August 2019 18:03:08) as /home/marcos/Desktop/isw1/linux64/clase2.image!


ObjectBuilder create: #I
	collaboratorNames: ''
	in: 'DenotativeObject-TestSupport'
	!

!classDefinition: #I category: #'DenotativeObject-TestSupport'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'I class' category: #'DenotativeObject-TestSupport'!
I class
	instanceVariableNames: ''!

ObjectBuilder create: #II
	collaboratorNames: ''
	in: 'DenotativeObject-TestSupport'
	!

!classDefinition: #II category: #'DenotativeObject-TestSupport'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'II class' category: #'DenotativeObject-TestSupport'!
II class
	instanceVariableNames: ''!
!AlanKay class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:08:02'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	currentCompany := 'VPRI'.! !

AlanKay class removeSelector: #initializeCollaboratorsFromFile!
!Bill class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:08:45'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	energia := 5.! !

Bill class removeSelector: #initializeCollaboratorsFromFile!

----End fileIn of /home/marcos/Desktop/isw1/linux64/Peano.st----!

ObjectBuilder create: #anObject
	collaboratorNames: ''
	in: 'DenotativeObject-TestSupport'
	!

!classDefinition: #anObject category: #'DenotativeObject-TestSupport'!
DenotativeObject subclass: #anObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'anObject class' category: #'DenotativeObject-TestSupport'!
anObject class
	instanceVariableNames: ''!

Smalltalk removeClassNamed: #anObject!

ObjectBuilder create: #next
	collaboratorNames: ''
	in: 'Peano'
	!

!classDefinition: #next category: #Peano!
DenotativeObject subclass: #next
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: 'next class' category: #Peano!
next class
	instanceVariableNames: ''!
!I class methodsFor: 'no messages' stamp: 'MB 8/26/2019 18:27:52'!
next

		^II! !

next
	collaboratorNames: ''
	in: 'abc'!

!classDefinition: #next category: #abc!
DenotativeObject subclass: #next
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'abc'!

!classDefinition: 'next class' category: #abc!
next class
	instanceVariableNames: ''!

Smalltalk removeClassNamed: #next!

!classDefinition: 'II class' category: #Peano!
II class
	instanceVariableNames: 'next'!
!II class methodsFor: 'no messages' stamp: 'MB 8/26/2019 18:32:49'!
next

	next ifNil: [
		self cloneNamed: self name, 'I'
		].
	^next! !

II next.!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next'!
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:34:09'!
next

	next ifNil: [
		self cloneNamed: self name, 'I'
		].
	^next! !

II next.!

III next.!

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:34:27'!
next

	next ifNil: [
		self cloneNamed: self name, 'I'
		].
	^next! !
!II class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:35:05' prior: 50727283!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'
		].
	^next! !

III
	collaboratorNames: 'next'
	in: 'abc'!

!classDefinition: #III category: #abc!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'abc'!

!classDefinition: 'III class' category: #abc!
III class
	instanceVariableNames: 'next'!

IIII
	collaboratorNames: 'next'
	in: 'abc'!

!classDefinition: #IIII category: #abc!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'abc'!

!classDefinition: 'IIII class' category: #abc!
IIII class
	instanceVariableNames: 'next'!

Smalltalk removeClassNamed: #IIII!

Smalltalk removeClassNamed: #III!
!II class methodsFor: 'nil' stamp: 'MB 8/26/2019 18:38:13'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

II next.!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next'!
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:38:24'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'
		].
	^next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:38:24'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

 III !

 III !

 III !

II removeAllNext.!

Smalltalk removeClassNamed: #III!
!I class methodsFor: 'nil' stamp: 'MB 8/26/2019 18:50:45'!
+ unNumeroDePeano
	
	^ unNumeroDePeano next ! !

I+I. !

 II !
!II class methodsFor: 'nil' stamp: 'MB 8/26/2019 18:54:26'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!II class methodsFor: 'nil' stamp: 'MB 8/26/2019 18:55:01'!
previous
	^I! !
!II class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:55:03' prior: 50727394!
previous
	
	^I! !
!II class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:55:57' prior: 50727327!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !

II
	collaboratorNames: 'next previous'
	in: 'Peano'!

!classDefinition: #II category: #Peano!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: 'II class' category: #Peano!
II class
	instanceVariableNames: 'next previous'!
!II class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 18:58:23' prior: 50727398!
previous
	
	^previous! !

self I!
!II class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:05:01'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !

II previous. !

II next.!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:05:48'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:05:48'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:05:48'!
previous
	
	^previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:05:48'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:05:48'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

III previous.!

II removeAllNext.!

Smalltalk removeClassNamed: #III!

II+II.!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:13'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:13'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:13'!
previous
	
	^previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:13'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:13'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:13'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:13'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:13'!
previous
	
	^previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:13'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:13'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

IIII+IIII.!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: #Peano!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIII class' category: #Peano!
IIIII class
	instanceVariableNames: 'next previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
previous
	
	^previous! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIII category: #Peano!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIII class' category: #Peano!
IIIIII class
	instanceVariableNames: 'next previous'!
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
previous
	
	^previous! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIII class' category: #Peano!
IIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
previous
	
	^previous! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:26'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIII class' category: #Peano!
IIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:27'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:27'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:27'!
previous
	
	^previous! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:27'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:08:27'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

II removeAllNext.!

Smalltalk removeClassNamed: #IIIIIIII!

Smalltalk removeClassNamed: #IIIIIII!

Smalltalk removeClassNamed: #IIIIII!

Smalltalk removeClassNamed: #IIIII!

Smalltalk removeClassNamed: #IIII!

Smalltalk removeClassNamed: #III!

II+II!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:26'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:26'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:26'!
previous
	
	^previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:26'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:26'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:26'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:26'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:26'!
previous
	
	^previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:26'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:26'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

IIII+IIII.!

DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIII category: #Peano!
DenotativeObject subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIII class' category: #Peano!
IIIII class
	instanceVariableNames: 'next previous'!
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
previous
	
	^previous! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIII category: #Peano!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIII class' category: #Peano!
IIIIII class
	instanceVariableNames: 'next previous'!
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
previous
	
	^previous! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIII class' category: #Peano!
IIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
previous
	
	^previous! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIII class' category: #Peano!
IIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
previous
	
	^previous! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:42'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

IIIIIIII+IIIIIIII. !

DenotativeObject subclass: #IIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIII class' category: #Peano!
IIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
previous
	
	^previous! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIII class' category: #Peano!
IIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
previous
	
	^previous! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIII class' category: #Peano!
IIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
previous
	
	^previous! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
previous
	
	^previous! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
previous
	
	^previous! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:54'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
previous
	
	^previous! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
previous
	
	^previous! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:10:55'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

IIIIIIIIIIIIIIII+IIIIIIIIIIIIIII.!

DenotativeObject subclass: #IIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:12'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:13'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:14'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII+IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII.!

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:54'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:54'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:54'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:55'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:56'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:57'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:58'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:11:59'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:00'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:01'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:01'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:01'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:01'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:01'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:01'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:01'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:01'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'MB 8/26/2019 19:12:01'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

IIIII removeAllNext !

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIII!

Smalltalk removeClassNamed: #IIIIIII!

Smalltalk removeClassNamed: #IIIIII!

----SNAPSHOT----(26 August 2019 19:14:52) clase2.image priorSource: 12655791!

----STARTUP---- (26 August 2019 19:33:50) as /home/mregnier/linux64/clase2.image!


IIII + IIII!

DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIII category: #Peano!
DenotativeObject subclass: #IIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIII class' category: #Peano!
IIIIII class
	instanceVariableNames: 'next previous'!
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
previous
	
	^previous! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIII class' category: #Peano!
IIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
previous
	
	^previous! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIII class' category: #Peano!
IIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
previous
	
	^previous! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:53:59'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

IIII + IIII + IIIIIIII !

DenotativeObject subclass: #IIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIII class' category: #Peano!
IIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
previous
	
	^previous! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIII class' category: #Peano!
IIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
previous
	
	^previous! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIII class' category: #Peano!
IIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
previous
	
	^previous! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:10'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
previous
	
	^previous! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
previous
	
	^previous! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
previous
	
	^previous! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
previous
	
	^previous! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIIIIIIIIIIIIIII category: #Peano!
DenotativeObject subclass: #IIIIIIIIIIIIIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIIIIIIIIIIIIIII class' category: #Peano!
IIIIIIIIIIIIIIII class
	instanceVariableNames: 'next previous'!
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
previous
	
	^previous! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIIIIIIIIIIIIIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 19:54:11'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

II removeAllNext!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIIII!

Smalltalk removeClassNamed: #IIIIIIII!

Smalltalk removeClassNamed: #IIIIIII!

Smalltalk removeClassNamed: #IIIIII!

Smalltalk removeClassNamed: #IIIII!

Smalltalk removeClassNamed: #IIII!

Smalltalk removeClassNamed: #III!
!I class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:36:39'!
- unNumeroDePeano
	
	^ unNumeroDePeano previous! !
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:37:41'!
- unNumeroDePeano
	
	^self previous - unNumeroDePeano next! !
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:41:26' prior: 50731289!
- unNumeroDePeano
	
	unNumeroDePeano = 1 ifTrue: [ ^self previous - unNumeroDePeano next ]! !
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:21' prior: 50731294!
- unNumeroDePeano
	
	unNumeroDePeano = 1 ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]! !

----SNAPSHOT----(26 August 2019 20:43:32) clase2.image priorSource: 12772717!

II + II!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:52'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:52'!
- unNumeroDePeano
	
	unNumeroDePeano = 1 ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:52'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:52'!
previous
	
	^previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:52'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:52'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:52'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:52'!
- unNumeroDePeano
	
	unNumeroDePeano = 1 ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:52'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:52'!
previous
	
	^previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:52'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:43:52'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

II - I!

II - I!
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:45:47' prior: 50731300!
- unNumeroDePeano
	
	unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]! !

II - I!

II removeAllNext !

Smalltalk removeClassNamed: #IIII!

Smalltalk removeClassNamed: #III!

II + II !

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:47:47'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:47:47'!
- unNumeroDePeano
	
	unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:47:47'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:47:47'!
previous
	
	^previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:47:47'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:47:47'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:47:47'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:47:47'!
- unNumeroDePeano
	
	unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:47:47'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:47:47'!
previous
	
	^previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:47:47'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:47:47'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

III - II !
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:51:37'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!I class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:51:56'!
* unNumeroPeano
	^unNumeroPeano ! !

II removeAllNext!

Smalltalk removeClassNamed: #IIII!

Smalltalk removeClassNamed: #III!

II * I!

II * II !

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:32'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:32'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:32'!
- unNumeroDePeano
	
	unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:32'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:32'!
previous
	
	^previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:32'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:32'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:33'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:33'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:33'!
- unNumeroDePeano
	
	unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:33'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:33'!
previous
	
	^previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:33'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:52:33'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

II removeAllNext !

Smalltalk removeClassNamed: #IIII!

Smalltalk removeClassNamed: #III!
!I class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 20:54:54'!
/ unNumeroPeano
	^I
! !

ObjectBuilder create: #Verdadero
	collaboratorNames: ''
	in: 'Verdadero y Falso'
	!

!classDefinition: #Verdadero category: #'Verdadero y Falso'!
DenotativeObject subclass: #Verdadero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Verdadero y Falso'!

!classDefinition: 'Verdadero class' category: #'Verdadero y Falso'!
Verdadero class
	instanceVariableNames: ''!

ObjectBuilder create: #Falso
	collaboratorNames: ''
	in: 'Verdadero y Falso'
	!

!classDefinition: #Falso category: #'Verdadero y Falso'!
DenotativeObject subclass: #Falso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Verdadero y Falso'!

!classDefinition: 'Falso class' category: #'Verdadero y Falso'!
Falso class
	instanceVariableNames: ''!
!Verdadero class methodsFor: 'nil' stamp: 'Dago 8/26/2019 21:03:21'!
no
	^Falso! !
!Falso class methodsFor: 'no messages' stamp: 'Dago 8/26/2019 21:03:36'!
no
	^Verdadero! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:04:17'!
y: unBool
	^unBool! !
!Falso class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:04:35'!
y: unBool
	^self! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:04:53'!
o: unBool
	^self! !
!Falso class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:05:19'!
o: unBool
	^unBool! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:06:30'!
siVerdadero: aClosure
	^aClosure value ! !

----SNAPSHOT----(26 August 2019 21:06:35) clase2.image priorSource: 12788989!
!Falso class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:07:04'!
siVerdadero: aClosure
	! !

Falso siVerdadero: [ ^1 ]!
!Falso class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:07:52' prior: 50731686!
siVerdadero: aClosure
	^nil! !
!Falso class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:08:20'!
siFalso: aClosure
	^aClosure value! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:08:37'!
siFalso: aClosure
	^nil! !

ObjectBuilder create: #BooleanosTest
	collaboratorNames: ''
	in: 'Verdadero y Falso'
	!

!classDefinition: #BooleanosTest category: #'Verdadero y Falso'!
DenotativeObject subclass: #BooleanosTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Verdadero y Falso'!

!classDefinition: 'BooleanosTest class' category: #'Verdadero y Falso'!
BooleanosTest class
	instanceVariableNames: ''!
!BooleanosTest class methodsFor: 'no messages' stamp: 'Dago 8/26/2019 21:11:51'!
test01noVerdaderoEsFalso

	self assert: Verdadero no = Falso! !
!BooleanosTest class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:12:13'!
test02VerdaderoEsNoFalso

	self assert: Verdadero = Falso no! !
!BooleanosTest class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:12:28'!
test03FalsoEsFalso

	self assert: Verdadero no = Falso! !
!BooleanosTest class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:13:15'!
test04VerdaderoEsVerdadero

	self assert: Verdadero = Verdadero! !
!BooleanosTest class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:14:59'!
test05VerdaderoOFalsoEsVerdadero

	self assert: (Verdadero o: Falso = Verdadero)! !
!BooleanosTest class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:15:28' prior: 50731736!
test05VerdaderoOFalsoEsVerdadero

	self assert: (Verdadero o: Falso = Verdadero).
	self assert: (Falso o: Verdadero = Verdadero).! !
!BooleanosTest class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:18:32'!
test06VerdaderoSiVerdaderoYFalsoSiVerdadero
	self assert: (Verdadero siVerdadero: [ ^'Hola' ] = 'Hola' ).
	self assert: (Falso siVerdadero: [ ^'Hola' ] = nil ).! !
!BooleanosTest class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:19:24'!
test07VerdaderoSiFalsoYFalsoSiFalso
	self assert: (Verdadero siFalso: [ ^'Hola' ] = nil ).
	self assert: (Falso siFalso: [ ^'Hola' ] = 'Hola' ).

! !
!BooleanosTest class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:20:42' prior: 50731742!
test05VerdaderoOFalsoEsVerdadero

	self assert: (Verdadero o: Falso) = Verdadero.
	self assert: (Falso o: Verdadero) = Verdadero.! !
!BooleanosTest class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:20:59' prior: 50731749!
test06VerdaderoSiVerdaderoYFalsoSiVerdadero
	self assert: (Verdadero siVerdadero: [ ^'Hola' ]) = 'Hola' .
	self assert: (Falso siVerdadero: [ ^'Hola' ]) = nil .! !
!BooleanosTest class methodsFor: 'as yet unclassified' stamp: 'Dago 8/26/2019 21:22:06' prior: 50731757!
test07VerdaderoSiFalsoYFalsoSiFalso
	self assert: (Verdadero siFalso: [ ^'Hola' ]) = nil .
	self assert: (Falso siFalso: [ ^'Hola' ]) = 'Hola' .

! !

----SNAPSHOT----(26 August 2019 21:30:51) clase2.image priorSource: 12801034!

----QUIT----(26 August 2019 21:30:55) clase2.image priorSource: 12804437!

----STARTUP---- (27 August 2019 17:00:38) as /home/mregnier/isw1/linux64/clase2.image!


----End fileIn of /home/mregnier/isw1/linux64/Packages/TerseGuide.pck.st----!
!I class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:11:05'!
previous
	self descripcionDeErrorDeNumerosNegativosNoSoportados! !
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:18:27'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ]! !
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:22:37' prior: 50734806!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ] ifFalse: [ 
		self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ] ifFalse: [ ^ self - unNumeroPeano / unNumeroPeano  + I] ]! !
!I class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:24:33'!
< unNumeroPeano
	^ (self = I) not
	 ! !
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:26:13'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ] ifFalse: [ ^self previous < unNumeroPeano previous ]! !
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:26:49' prior: 50734827!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!I class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:27:43' prior: 50731628!
/ unNumeroPeano
	unNumeroPeano  = self ifTrue: [ ^self ]
! !
!I class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:28:20' prior: 50734823!
< unNumeroPeano
	^ (self = unNumeroPeano ) not
	 ! !
!I class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:28:22' prior: 50734845!
< unNumeroPeano
	^ (self = unNumeroPeano) not
	 ! !
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:32:16' prior: 50734813!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ].
		self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
		^ self - unNumeroPeano / unNumeroPeano  + I ! !
!I class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:34:25' prior: 50734840!
/ unNumeroPeano
	unNumeroPeano  = self ifTrue: [ ^self ].
	self Error descripcionDeErrorDeNumerosNegativosNoSoportados
	! !
!I class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:35:03' prior: 50734865!
/ unNumeroPeano
	unNumeroPeano  = self ifTrue: [ ^self ].
	self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	! !

----SNAPSHOT----(27 August 2019 17:35:14) clase2.image priorSource: 12804516!

II * II!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
- unNumeroDePeano
	
	unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ].
		self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
		^ self - unNumeroPeano / unNumeroPeano  + I ! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
previous
	
	^previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
- unNumeroDePeano
	
	unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ].
		self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
		^ self - unNumeroPeano / unNumeroPeano  + I ! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:35'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:36'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:36'!
previous
	
	^previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:36'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:36:36'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

IIII / II!

IIII / II!
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:45:52' prior: 50734855!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ].
		self = unNumeroPeano ifTrue: [ ^I ].
		self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
		^ self - unNumeroPeano / unNumeroPeano  + I ! !
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:46:09' prior: 50735018!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !

IIII / II!

II / IIII!

----SNAPSHOT----(27 August 2019 17:46:52) clase2.image priorSource: 12903289!

II removeAllNext !

Smalltalk removeClassNamed: #IIII!

Smalltalk removeClassNamed: #III!

II + II!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
- unNumeroDePeano
	
	unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
previous
	
	^previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
- unNumeroDePeano
	
	unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
previous
	
	^previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:47:20'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !

III / I!

II removeAllNext !

Smalltalk removeClassNamed: #IIII!

Smalltalk removeClassNamed: #III!
!I class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:52:48'!
restaInversa: unNumeroPeano
	^unNumeroPeano  previous! !
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:54:09'!
restaInversa: unNumeroPeano
	^self previous restaInversa: unNumeroPeano  previous! !
!II class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:54:54' prior: 50731405!
- unNumeroDePeano
	^unNumeroDePeano restaInversa: self.
	
	"unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]"! !

----SNAPSHOT----(27 August 2019 17:55:01) clase2.image priorSource: 12908463!

II + II!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:07'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:07'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:07'!
- unNumeroDePeano
	^unNumeroDePeano restaInversa: self.
	
	"unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]"! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:07'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:07'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:07'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:07'!
previous
	
	^previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:07'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:07'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !
!III class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:07'!
restaInversa: unNumeroPeano
	^self previous restaInversa: unNumeroPeano  previous! !

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:07'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:07'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:08'!
- unNumeroDePeano
	^unNumeroDePeano restaInversa: self.
	
	"unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]"! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:08'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:08'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:08'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:08'!
previous
	
	^previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:08'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:08'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'Dago 8/27/2019 17:55:08'!
restaInversa: unNumeroPeano
	^self previous restaInversa: unNumeroPeano  previous! !

IIII - I!

IIII - II!

----SNAPSHOT----(27 August 2019 17:58:04) clase2.image priorSource: 12913765!

III - IIII!

----QUIT----(27 August 2019 18:30:56) clase2.image priorSource: 12918731!

----STARTUP---- (29 August 2019 17:48:06) as /home/mregnier/isw1/linux64/clase2.image!


1 +1!

 2 !

----SNAPSHOT----(29 August 2019 17:51:09) clase2.image priorSource: 12918823!

1 inspect!

ProcessBrowser!

ProcessBrowser!

ProcessBrowser inspect!

#('a' 2 #('c' 3 'a'))!

#('a' 2 #('c' 3 'a')) exploreIt!

#('a' 2 #('c' 3 'a')) explore!

#('a' 2 #('c' 3 'a'))!

ObjectBuilder create: #TestPrueba
	collaboratorNames: ''
	in: 'DenotativeObject-TestSupport'
	!

!classDefinition: #TestPrueba category: #'DenotativeObject-TestSupport'!
DenotativeObject subclass: #TestPrueba
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'TestPrueba class' category: #'DenotativeObject-TestSupport'!
TestPrueba class
	instanceVariableNames: ''!
!TestPrueba class methodsFor: 'no messages' stamp: 'Dago 8/29/2019 18:42:28'!
test01Prueba

Assert isTrue: 1 = 2! !

----STARTUP---- (29 August 2019 19:00:35) as /home/mregnier/isw1/linux64/clase2.image!


odds!

odds!

 |    elements index |!

elements:= #(1 2 5 6 9).!

odds := OrderedCollection new.!

index := 1.!

[index <= elements size]!


    ((elements at: index) odd  ) ifTrue: [odds add: (elements at: index)].
    index := index +1.
    !

odds := OrderedCollection new.!

odds := OrderedCollection new. !

odds!

#(1 2 5 6 9) do: [ :elem | elem odd ifTrue: [ odds add: elem ]].!

odds := OrderedCollection new. 

#(1 2 5 6 9) do: [ :elem | elem odd ifTrue: [ odds add: elem ]].
odds!

#(1 5 9) detect: [ :elem | elem even ]!

10 * peso +  10 * dollar    !

10 * peso +  (10 * dollar )   !

10 * peso +( 10 * dollar) - (2 * dollar)!

10 * peso +( 10 * dollar) - (2 * dollar) - (8 * dollar)!

peso!

diezMetros := 10 * meter!

diezMetros!

sesentaPulgadas :=  60 * inch!

sesentaPulgadas :=  60 * inch!

BaseUnit!

BaseUnit!

BaseUnit!

| inch |
inch := BaseUnit initializeNameFomOne: 'inch' nameForMany: 'inches'.!

inch := BaseUnit nameForOne: 'inch' nameForMany: 'inches'.!

sesinchm := 60 * inch!

cm := BaseUnit nameForOne: 'centimetro' nameForMany: 'centimetros'.!

cm!

BaseUnit!

----SNAPSHOT----(29 August 2019 21:52:20) clase2.image priorSource: 12919000!

----QUIT----(29 August 2019 21:55:23) clase2.image priorSource: 12920261!

----STARTUP---- (31 August 2019 17:31:27) as /home/dago/Documents/Facultad/isw1/isw1/linux64/clase2.image!


----End fileIn of /home/dago/Documents/Facultad/isw1/isw1/linux64/PeanoTest.st----!

II removeAllNext !

Smalltalk removeClassNamed: #IIII!

Smalltalk removeClassNamed: #III!
!I class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:36:35' prior: 50734872!
/ unNumeroPeano
	unNumeroPeano  = self ifTrue: [ ^self ].
	self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	! !
!I class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:37:00' prior: 50734801!
previous
	self error: self descripcionDeErrorDeNumerosNegativosNoSoportados! !
!II class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:37:27' prior: 50735029!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self error: self descripcionDeErrorDeNumerosNegativosNoSoportados ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !

I previous!

II + II!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:05'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:05'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:05'!
- unNumeroDePeano
	^unNumeroDePeano restaInversa: self.
	
	"unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]"! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:05'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self error: self descripcionDeErrorDeNumerosNegativosNoSoportados ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
previous
	
	^previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
restaInversa: unNumeroPeano
	^self previous restaInversa: unNumeroPeano  previous! !

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
- unNumeroDePeano
	^unNumeroDePeano restaInversa: self.
	
	"unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]"! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self error: self descripcionDeErrorDeNumerosNegativosNoSoportados ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
previous
	
	^previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:40:06'!
restaInversa: unNumeroPeano
	^self previous restaInversa: unNumeroPeano  previous! !

----STARTUP---- (31 August 2019 17:40:56) as /home/dago/Documents/Facultad/isw1/isw1/linux64/clase2.image!


II removeAllNext !

Smalltalk removeClassNamed: #IIII!

Smalltalk removeClassNamed: #III!

II + II!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:51'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:51'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:51'!
- unNumeroDePeano
	^unNumeroDePeano restaInversa: self.
	
	"unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]"! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
previous
	
	^previous! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
restaInversa: unNumeroPeano
	^self previous restaInversa: unNumeroPeano  previous! !

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next previous'!
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
- unNumeroDePeano
	^unNumeroDePeano restaInversa: self.
	
	"unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]"! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self descripcionDeErrorDeNumerosNegativosNoSoportados ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
previous
	
	^previous! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:41:52'!
restaInversa: unNumeroPeano
	^self previous restaInversa: unNumeroPeano  previous! !

----End fileIn of /home/dago/Documents/Facultad/isw1/isw1/linux64/PeanoTest.st----!

II removeAllNext !

Smalltalk removeClassNamed: #IIII!

Smalltalk removeClassNamed: #III!
!I class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:45:12' prior: 50734872!
/ unNumeroPeano
	unNumeroPeano  = self ifTrue: [ ^self ].
	self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	! !
!I class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:46:00'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^ 'No se puede dividir por un nmero mayor'! !

I / II!
!II class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:47:04' prior: 50735029!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self error: self descripcionDeErrorDeNumerosNegativosNoSoportados ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!II class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:47:38'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^ 'No se puede dividir por un nmero mayor'! !
!II class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:48:28' prior: 50735689!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!I class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 17:48:57' prior: 50734801!
previous
	self error: self descripcionDeErrorDeNumerosNegativosNoSoportados! !
!I class methodsFor: 'Errores' stamp: 'mr 8/31/2019 17:50:11'!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^ 'Los nmeros negativos no estn soportados'! !

----SNAPSHOT----(31 August 2019 17:54:04) clase2.image priorSource: 12920340!

II + II!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'Errores' stamp: 'mr 8/31/2019 17:56:09'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^ 'No se puede dividir por un nmero mayor'! !
!III class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 17:56:09'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!III class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 17:56:09'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 17:56:09'!
- unNumeroDePeano
	^unNumeroDePeano restaInversa: self.
	
	"unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]"! !
!III class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 17:56:09'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!III class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 17:56:09'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 17:56:09'!
previous
	
	^previous! !
!III class methodsFor: 'Privado' stamp: 'mr 8/31/2019 17:56:09'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!III class methodsFor: 'Privado' stamp: 'mr 8/31/2019 17:56:09'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'Privado' stamp: 'mr 8/31/2019 17:56:09'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !
!III class methodsFor: 'Privado' stamp: 'mr 8/31/2019 17:56:09'!
restaInversa: unNumeroPeano
	^self previous restaInversa: unNumeroPeano  previous! !

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next previous'!
!IIII class methodsFor: 'Errores' stamp: 'mr 8/31/2019 17:56:09'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^ 'No se puede dividir por un nmero mayor'! !
!IIII class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 17:56:09'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!IIII class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 17:56:09'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIII class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 17:56:09'!
- unNumeroDePeano
	^unNumeroDePeano restaInversa: self.
	
	"unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]"! !
!IIII class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 17:56:09'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!IIII class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 17:56:09'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIII class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 17:56:09'!
previous
	
	^previous! !
!IIII class methodsFor: 'Privado' stamp: 'mr 8/31/2019 17:56:09'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!IIII class methodsFor: 'Privado' stamp: 'mr 8/31/2019 17:56:09'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIII class methodsFor: 'Privado' stamp: 'mr 8/31/2019 17:56:09'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !
!IIII class methodsFor: 'Privado' stamp: 'mr 8/31/2019 17:56:09'!
restaInversa: unNumeroPeano
	^self previous restaInversa: unNumeroPeano  previous! !

IIII - II !

Smalltalk removeClassNamed: #PeanoTest!

----End fileIn of /home/dago/Documents/Facultad/isw1/isw1/linux64/PeanoTest.st----!

I - II. !
!I class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:03:36' prior: 50731284!
- unNumeroDePeano
	
	^ unNumeroDePeano restaInversa: self! !

I - II. !

II removeAllNext .!

Smalltalk removeClassNamed: #IIII!

Smalltalk removeClassNamed: #III!

II + II.!

DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #III category: #Peano!
DenotativeObject subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

III class
	instanceVariableNames: 'next previous'!

!classDefinition: 'III class' category: #Peano!
III class
	instanceVariableNames: 'next previous'!
!III class methodsFor: 'Errores' stamp: 'mr 8/31/2019 18:04:20'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^ 'No se puede dividir por un nmero mayor'! !
!III class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:04:20'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!III class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:04:20'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!III class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:04:20'!
- unNumeroDePeano
	^unNumeroDePeano restaInversa: self.
	
	"unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]"! !
!III class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:04:20'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!III class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:04:20'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!III class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:04:20'!
previous
	
	^previous! !
!III class methodsFor: 'Privado' stamp: 'mr 8/31/2019 18:04:20'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!III class methodsFor: 'Privado' stamp: 'mr 8/31/2019 18:04:20'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!III class methodsFor: 'Privado' stamp: 'mr 8/31/2019 18:04:20'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !
!III class methodsFor: 'Privado' stamp: 'mr 8/31/2019 18:04:20'!
restaInversa: unNumeroPeano
	^self previous restaInversa: unNumeroPeano  previous! !

DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

!classDefinition: #IIII category: #Peano!
DenotativeObject subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Peano'!

IIII class
	instanceVariableNames: 'next previous'!

!classDefinition: 'IIII class' category: #Peano!
IIII class
	instanceVariableNames: 'next previous'!
!IIII class methodsFor: 'Errores' stamp: 'mr 8/31/2019 18:04:21'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^ 'No se puede dividir por un nmero mayor'! !
!IIII class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:04:21'!
* unNumeroPeano

	^self previous * unNumeroPeano + unNumeroPeano ! !
!IIII class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:04:21'!
+ unNumeroDePeano
	
	^self previous + unNumeroDePeano next! !
!IIII class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:04:21'!
- unNumeroDePeano
	^unNumeroDePeano restaInversa: self.
	
	"unNumeroDePeano = I ifTrue: [ ^self previous ] ifFalse: [ ^self previous - unNumeroDePeano previous ]"! !
!IIII class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:04:21'!
/ unNumeroPeano
	self < unNumeroPeano ifTrue: [ ^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor ].
	self = unNumeroPeano ifTrue: [ ^I ].
	self - unNumeroPeano  < unNumeroPeano ifTrue: [ ^I ].
	^ self - unNumeroPeano / unNumeroPeano  + I ! !
!IIII class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:04:21'!
next

	next ifNil: [
		next _ self cloneNamed: self name, 'I'.
		next previous: self.
		].
	^next! !
!IIII class methodsFor: 'Operaciones' stamp: 'mr 8/31/2019 18:04:21'!
previous
	
	^previous! !
!IIII class methodsFor: 'Privado' stamp: 'mr 8/31/2019 18:04:21'!
< unNumeroPeano
	unNumeroPeano = I ifTrue: [ ^false ].
	^self previous < unNumeroPeano previous! !
!IIII class methodsFor: 'Privado' stamp: 'mr 8/31/2019 18:04:21'!
previous: unNumeroDePeano
	previous _ unNumeroDePeano! !
!IIII class methodsFor: 'Privado' stamp: 'mr 8/31/2019 18:04:21'!
removeAllNext
	next ifNotNil:
	[
		next removeAllNext.
		next removeFromSystem.
		next := nil.
	]! !
!IIII class methodsFor: 'Privado' stamp: 'mr 8/31/2019 18:04:21'!
restaInversa: unNumeroPeano
	^self previous restaInversa: unNumeroPeano  previous! !

Smalltalk removeClassNamed: #PeanoTest!

----End fileIn of /home/dago/Documents/Facultad/isw1/isw1/linux64/PeanoTest.st----!
!II class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 18:05:00'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.! !
!III class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 18:05:00'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.! !
!IIII class methodsFor: 'as yet unclassified' stamp: 'mr 8/31/2019 18:05:00'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := III.! !

II class removeSelector: #initializeCollaboratorsFromFile!

III class removeSelector: #initializeCollaboratorsFromFile!

IIII class removeSelector: #initializeCollaboratorsFromFile!

----SNAPSHOT----(31 August 2019 18:06:28) clase2.image priorSource: 12930530!

Smalltalk removeClassNamed: #PeanoTest!

diezMetros := 10 * metro!

diezMetros := 10 * meter!

metros := BaseUnit nameForOne:  'metro' nameForMany:  'metros'.!

pulgadas :=
        ProportionalDerivedUnit
                baseUnit:  metros
                conversionFactor: 0.0254
                nameForOne:  'pulgada'
                nameForMany:  'pulgadas'
                sign: 'in'.!

pulgadas :=
        ProportionalDerivedUnit
                baseUnit:  meter
                conversionFactor: 0.0254
                nameForOne:  'pulgada'
                nameForMany:  'pulgadas'
                sign: 'in'. pulgada 
!

pulgadas :=
        ProportionalDerivedUnit
                baseUnit:  meter
                conversionFactor: 0.0254
                nameForOne:  'pulgada'
                nameForMany:  'pulgadas'
                sign: 'in'.!

centimetros :=
        ProportionalDerivedUnit
                baseUnit:  metros
                conversionFactor: 1/ 100
                nameForOne:  'centimetro'
                nameForMany:  'centimetros'
                sign: 'cm'.!

diezMetros convertTo: centimetros.!

centimetros :=
        ProportionalDerivedUnit
                baseUnit:  meter
                conversionFactor: 1/ 100
                nameForOne:  'centimetro'
                nameForMany:  'centimetros'
                sign: 'cm'.!

diezMetros convertTo: centimetros.!

sesentaPulgadas := 60 * pulgada.!

sesentaPulgadas := 60 * pulgadas.!

sesentaPulgadas convertTo: meter.!

----SNAPSHOT----(31 August 2019 18:43:32) clase2.image priorSource: 12948347!

----QUIT----(31 August 2019 18:43:43) clase2.image priorSource: 12949938!

----STARTUP---- (2 September 2019 15:34:08) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!


----QUIT----(2 September 2019 15:37:19) clase2.image priorSource: 12950017!

----STARTUP---- (2 September 2019 15:52:45) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!


I / II!

----STARTUP---- (2 September 2019 17:13:01) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!


----QUIT----(2 September 2019 18:41:34) clase2.image priorSource: 12950199!

----STARTUP---- (2 September 2019 18:41:38) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!


----End fileIn of /home/drenteria/Documentos/isI/isw1/linux64/CodigoRepetido-Ejercicio.st----!
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/2/2019 18:48:14' prior: 50736556!
addCustomerNamed: aName

	aName isEmpty ifTrue: [ self signalCustomerNameCannotBeEmpty ].
	(self includesCustomerNamed: aName) ifTrue: [ self signalCustomerAlreadyExists ].
	
	active add: aName ! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 19:05:50'!
Message: aMessage OnCustomer: aCustomer OnCustomerBook: aCustomerBook ShouldNotTakeMoreMillisecondsThan: milliseconds 
	
	| millisecondsBeforeRunning millisecondsAfterRunning |
	
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aMessage sendTo: aCustomerBook with: aCustomer.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (milliseconds * millisecond)! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 19:08:28' prior: 50736407!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	  
	self Message: 'addCustomerNamed:' asMessage OnCustomer: paulMcCartney OnCustomerBook: customerBook ShouldNotTakeMoreMillisecondsThan: 100
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 19:08:49' prior: 50736660!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	  
	self Message: 'addCustomerNamed:' asMessage OnCustomer: paulMcCartney OnCustomerBook: customerBook        ShouldNotTakeMoreMillisecondsThan: 100
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 19:09:19' prior: 50736674!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	  
	self Message: 'addCustomerNamed:' OnCustomer: paulMcCartney OnCustomerBook: customerBook        ShouldNotTakeMoreMillisecondsThan: 100
! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 19:12:22'!
Action: aClosure ShouldNotTakeMoreMillisecondsThan: milliseconds 
	
	| millisecondsBeforeRunning millisecondsAfterRunning |
	
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aClosure value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (milliseconds * millisecond)! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 19:14:46' prior: 50736689!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.

	self Action: [customerBook removeCustomerNamed: paulMcCartney] ShouldNotTakeMoreMillisecondsThan: 100.
! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 19:15:37'!
action: aClosure ShouldNotTakeMoreMillisecondsThan: milliseconds 
	
	| millisecondsBeforeRunning millisecondsAfterRunning |
	
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aClosure value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (milliseconds * millisecond)! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 19:16:04' prior: 50736718!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.

	self action: [customerBook removeCustomerNamed: paulMcCartney] ShouldNotTakeMoreMillisecondsThan: 100.
! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 19:17:24'!
action: aClosure shouldNotTakeMoreMillisecondsThan: milliseconds 
	
	| millisecondsBeforeRunning millisecondsAfterRunning |
	
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aClosure value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (milliseconds * millisecond)! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 19:17:27' prior: 50736390!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self action: [ customerBook addCustomerNamed: 'john Lennon' ] shouldNotTakeMoreMillisecondsThan: 50
! !

CustomerBookTest removeSelector: #action:ShouldNotTakeMoreMillisecondsThan:!

CustomerBookTest removeSelector: #Action:ShouldNotTakeMoreMillisecondsThan:!
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 19:41:02'!
closure: closureToFail shouldFailWith: error andShouldAssert: aConditionToAssert and: anotherConditionToAssert
 	[ closureToFail value.
	  self fail ]
		on: error
		do: [ :anError |
			self assert: aConditionToAssert.
			self assert: anotherConditionToAssert 
			]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 19:45:23' prior: 50736439!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	self closure: [ customerBook removeCustomerNamed: 'Paul McCartney'. ] shouldFailWith: NotFound andShouldAssert: 
	[ customerBook numberOfCustomers = 1. ] and: [ (customerBook includesCustomerNamed: johnLennon) ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 19:47:26' prior: 50736427!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.

	self closure: [ customerBook addCustomerNamed: ''. ] shouldFailWith: Error andShouldAssert: 
	[ :anError | anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage. ] and: [ customerBook isEmpty ]! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 19:49:19' prior: 50736789!
closure: closureToFail shouldFailWith: error andShouldAssert: aConditionToAssert and: anotherConditionToAssert
 	[ closureToFail value.
	  self fail ]
		on: error
		do: [ :anError |
			self assert: (aConditionToAssert value: anError).
			self assert: (anotherConditionToAssert value: anError) 
			]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:00:22' prior: 50736817!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.

	self closure: [ customerBook addCustomerNamed: ''. ] shouldFailWith: Error andShouldAssert: 
	[ :anError | anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage. ] and: [ customerBook isEmpty ]! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 20:00:40'!
closure: aClosure shouldNotTakeMoreMillisecondsThan: milliseconds 
	
	| millisecondsBeforeRunning millisecondsAfterRunning |
	
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aClosure value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (milliseconds * millisecond)! !

CustomerBookTest removeSelector: #action:shouldNotTakeMoreMillisecondsThan:!
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:01:00' prior: 50736774!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self closure: [ customerBook addCustomerNamed: 'john Lennon' ] shouldNotTakeMoreMillisecondsThan: 50
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:01:13' prior: 50736746!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.

	self closure: [customerBook removeCustomerNamed: paulMcCartney] ShouldNotTakeMoreMillisecondsThan: 100.
! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 20:02:37' prior: 50736830!
closure: closureToFail shouldFailWith: error andShouldAssert: aConditionToAssert and: anotherConditionToAssert
 	[ closureToFail value.
	  self fail ]
		on: error
		do: [ :anError |
			self assert: (aConditionToAssert value: anError).
			self assert: (anotherConditionToAssert) 
			]! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 20:08:11'!
assertCustomerBook: aCustomerBook hasActiveCustomers: numberOfActiveCustomers andSuspendedCustomers: numberOfSuspendedCustomers
 	| totalCustomers |
	
	totalCustomers := numberOfActiveCustomers + numberOfSuspendedCustomers 
	self assert: numberOfActiveCustomers equals: aCustomerBook numberOfActiveCustomers.
	self assert: numberOfSuspendedCustomers equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: 0 equals: aCustomerBook numberOfCustomers.
	! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 20:09:06' prior: 50736910!
assertCustomerBook: aCustomerBook hasActiveCustomers: numberOfActiveCustomers andSuspendedCustomers: numberOfSuspendedCustomers
 	| totalCustomers |
	
	totalCustomers := numberOfActiveCustomers + numberOfSuspendedCustomers 
	self assert: numberOfActiveCustomers equals: aCustomerBook numberOfActiveCustomers.
	self assert: numberOfSuspendedCustomers equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: totalCustomers equals: aCustomerBook numberOfCustomers.
	! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 20:09:10' prior: 50736928!
assertCustomerBook: aCustomerBook hasActiveCustomers: numberOfActiveCustomers andSuspendedCustomers: numberOfSuspendedCustomers
 	| totalCustomers |
	
	totalCustomers := numberOfActiveCustomers + numberOfSuspendedCustomers 
	
	self assert: numberOfActiveCustomers equals: aCustomerBook numberOfActiveCustomers.
	self assert: numberOfSuspendedCustomers equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: totalCustomers equals: aCustomerBook numberOfCustomers.
	! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:10:32' prior: 50736454!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:11:26' prior: 50736965!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	self assertCustomerBook: customerBook hasActiveCustomers: 0 andSuspendedCustomers: 1.	
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:11:41' prior: 50736473!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertCustomerBook: customerBook hasActiveCustomers: 0 andSuspendedCustomers: 0.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:28:58' prior: 50736494!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'Paul McCartney'.
	self fail ]
		on: CantSuspend 
		do: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ]
! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 20:31:27'!
closure: closureToFail shouldFailWith: error andDo: closureAfterFail
 	[ closureToFail value.
	  self fail ]
		on: error
		do: closureAfterFail! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:32:33' prior: 50736843!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.

	self closure: [ customerBook addCustomerNamed: ''. ] shouldFailWith: Error andDo: 
	[ :anError |
		self assert anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
		self assert customerBook isEmpty ]! !

CustomerBookTest removeSelector: #closure:shouldFailWith:andShouldAssert:and:!

CustomerBookTest removeSelector: #Message:OnCustomer:OnCustomerBook:ShouldNotTakeMoreMillisecondsThan:!
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:34:07' prior: 50737044!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.

	self closure: [ customerBook addCustomerNamed: ''. ] shouldFailWith: Error andDo: 
	[ :anError |
		self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
		self assert: customerBook isEmpty ]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:34:57' prior: 50736801!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	self closure: [ customerBook removeCustomerNamed: 'Paul McCartney'. ] shouldFailWith: NotFound andDo: 
	[ :anError |
		self assert: customerBook numberOfCustomers = 1. 
		self assert: (customerBook includesCustomerNamed: johnLennon) ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:36:11' prior: 50737020!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	self closure: [ customerBook suspendCustomerNamed: 'Paul McCartney'.] shouldFailWIth: CantSuspend andDo: [ 		:anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:36:47' prior: 50737092!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	self closure: [ customerBook suspendCustomerNamed: 'Paul McCartney'. ] shouldFailWith: CantSuspend andDo: [ 		:anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ]
! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 20:39:55'!
message: nameOfCustomer and: aCustomerBook

	self closure: [ aCustomerBook suspendCustomerNamed: nameOfCustomer. ] shouldFailWith: CantSuspend andDo: [ 		:anError | 
			self assert: aCustomerBook numberOfCustomers = 1.
			self assert: (aCustomerBook includesCustomerNamed: nameOfCustomer) ]
! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 20:44:58'!
assertCustomerBook: aCustomerBook includes: nameOfCustomer andHasNumberOfCustomers: numberOfCustomers

	self assert: aCustomerBook numberOfCustomers = 1.
	self assert: (aCustomerBook includesCustomerNamed: nameOfCustomer )! !
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 20:45:04' prior: 50737138!
assertCustomerBook: aCustomerBook includes: nameOfCustomer andHasNumberOfCustomers: numberOfCustomers

	self assert: aCustomerBook numberOfCustomers = numberOfCustomers .
	self assert: (aCustomerBook includesCustomerNamed: nameOfCustomer )! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:46:18' prior: 50737109!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	self closure: [ customerBook suspendCustomerNamed: 'Paul McCartney'. ] shouldFailWith: CantSuspend andDo: [ 		:anError | 
			self assertCustomerBook: customerBook includes: johnLennon andHasNumberOfCustomers: 1]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:47:41' prior: 50736510!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	customerBook suspendCustomerNamed: johnLennon.

	self closure: [ customerBook suspendCustomerNamed: johnLennon. ] shouldFailWith: CantSuspend andDo: [ 		:anError | 
			self assertCustomerBook: customerBook includes: johnLennon andHasNumberOfCustomers: 1]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/2/2019 20:49:22' prior: 50736884!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.

	self closure: [ customerBook removeCustomerNamed: paulMcCartney. ] shouldNotTakeMoreMillisecondsThan: 100.
! !

CustomerBookTest removeSelector: #message:and:!
!CustomerBookTest methodsFor: 'extracted_collaborations' stamp: 'mr 9/2/2019 20:51:46' prior: 50736947!
assertCustomerBook: aCustomerBook hasActiveCustomers: numberOfActiveCustomers andSuspendedCustomers: numberOfSuspendedCustomers
 	| totalCustomers |
	
	totalCustomers := numberOfActiveCustomers + numberOfSuspendedCustomers. 
	
	self assert: numberOfActiveCustomers equals: aCustomerBook numberOfActiveCustomers.
	self assert: numberOfSuspendedCustomers equals: aCustomerBook numberOfSuspendedCustomers.
	self assert: totalCustomers equals: aCustomerBook numberOfCustomers.
	! !

OrderedCollection!

#(1 2 3 4) remove: 1 ifAbsent: []!

|x|
x := OrderedCollection new.
x add: 1; add: 2.
x remove: 1 ifAbsent: []!
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/2/2019 21:26:01' prior: 50736579!
removeCustomerNamed: aName 
 
	active remove: aName ifAbsent: [].
	suspended remove: aName ifAbsent: [].

	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/2/2019 21:28:51'!
removeFrom: aCollection if: conditionToRemove
	aCollection do: [:each | (conditionToRemove value: each) ifTrue: [aCollection remove: each. ^ true]]
	
! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/2/2019 21:29:12' prior: 50737238!
removeFrom: aCollection if: conditionToRemove
	aCollection do: [:each | (conditionToRemove value: each) ifTrue: [aCollection remove: each. ^ true]].
	^ false.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/2/2019 21:30:37' prior: 50737231!
removeCustomerNamed: aName 
 
	self removeFrom: active if: [  ].
	suspended remove: aName ifAbsent: [].

	^ NotFound signal.
! !

----SNAPSHOT----(2 September 2019 21:30:50) clase2.image priorSource: 12950383!

----QUIT----(2 September 2019 21:30:56) clase2.image priorSource: 12979552!

----STARTUP---- (3 September 2019 14:42:25) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!

!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 14:55:38' prior: 50737246!
removeFrom: aCollection if: conditionToRemove
	aCollection do: [:each | (conditionToRemove value: each) ifTrue: [aCollection remove: each. ^ true]].
	^ false.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 14:56:42' prior: 50737255!
removeCustomerNamed: aName 
 	
	| customerHasTheSameName |
	
	customerHasTheSameName  :=  [:customer |  aName = customer].
	
	(self removeFrom: active if: customerHasTheSameName) ifTrue: [ ^aName ].
	(self removeFrom: suspended if: customerHasTheSameName) ifTrue: [ ^aName ].
	
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 15:00:50'!
signalError: anError

! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 15:02:01' prior: 50737292!
signalError: anError

	self error: self class anError 

! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 15:02:05' prior: 50737296!
signalError: anError

	self error: self class anError

! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 15:02:21' prior: 50737301!
signalError: anError

	self error: self class anError

! !

self class!

self !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 15:19:02' prior: 50736592!
signalCustomerAlreadyExists 
	
	self signalError: #customerAlreadyExistsErrorMessage asMessage! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 15:19:24' prior: 50737306!
signalError: anError

	self error: self class anError asMessage

! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 15:19:30' prior: 50737319!
signalError: anError

	self error: self class anError asMessage

! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 15:19:35' prior: 50737312!
signalCustomerAlreadyExists 
	
	self signalError: #customerAlreadyExistsErrorMessage! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 15:23:39' prior: 50737325!
signalError: anError

	self error: self class anError asMessage

! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 15:24:54' prior: 50737337!
signalError: anError

	self error: self class anError.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 15:25:39' prior: 50736598!
signalCustomerNameCannotBeEmpty 
	
	self signalError: #customerCanNotBeEmptyErrorMessage.

	"	self error: self class customerCanNotBeEmptyErrorMessage "! !
!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 15:27:30' prior: 50737343!
signalError: anError

	self error: (anError asMessage sendTo: self class)
! !

----SNAPSHOT----(3 September 2019 15:38:42) clase2.image priorSource: 12979633!
!CustomerBook methodsFor: 'errors' stamp: 'mr 9/3/2019 15:39:46'!
signalClassError: classError

	self error: (classError asMessage sendTo: self class)
! !
!CustomerBook methodsFor: 'errors' stamp: 'mr 9/3/2019 15:40:05' prior: 50737331!
signalCustomerAlreadyExists 
	
	self signalClassError: #customerAlreadyExistsErrorMessage! !
!CustomerBook methodsFor: 'errors' stamp: 'mr 9/3/2019 15:40:13' prior: 50737348!
signalCustomerNameCannotBeEmpty 
	
	self signalClassError: #customerCanNotBeEmptyErrorMessage.

	"	self error: self class customerCanNotBeEmptyErrorMessage "! !
!CustomerBook methodsFor: 'errors' stamp: 'mr 9/3/2019 15:40:17' prior: 50737376!
signalCustomerNameCannotBeEmpty 
	
	self signalClassError: #customerCanNotBeEmptyErrorMessage.
! !

CustomerBook removeSelector: #signalError:!
!CustomerBook methodsFor: 'removing' stamp: 'mr 9/3/2019 15:40:55' prior: 50737271!
removeFrom: aCollection if: conditionToRemove
	
	aCollection do: [:each | (conditionToRemove value: each) ifTrue: [aCollection remove: each. ^ true]].
	^ false.
! !

----SNAPSHOT----(3 September 2019 16:19:36) clase2.image priorSource: 12982733!

----QUIT----(3 September 2019 16:20:03) clase2.image priorSource: 12983972!

----STARTUP---- (3 September 2019 17:58:46) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!

!CustomerBook methodsFor: 'customer management' stamp: 'mr 9/3/2019 17:59:56' prior: 50736570!
numberOfCustomers
	
	^self numberOfActiveCustomers + self numberOfSuspendedCustomers.! !

----QUIT----(3 September 2019 18:02:31) clase2.image priorSource: 12984053!

----STARTUP---- (5 September 2019 16:35:20) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!

!CustomerBookTest methodsFor: 'time measuring' stamp: 'mr 9/5/2019 16:39:14' prior: 50736856!
closure: aClosure shouldNotTakeMoreMillisecondsThan: milliseconds 
	
	self assert: (Time millisecondsToRun: aClosure ) < (milliseconds * millisecond)! !
!CustomerBookTest methodsFor: 'time measuring' stamp: 'mr 9/5/2019 16:39:35' prior: 50737421!
closure: aClosure shouldNotTakeMoreMillisecondsThan: milliseconds 
	
	self assert: (Time millisecondsToRun: aClosure ) < (milliseconds * millisecond)! !
!CustomerBookTest methodsFor: 'time measuring' stamp: 'mr 9/5/2019 16:41:53' prior: 50737429!
closure: closureToMeasure shouldNotTakeMoreMillisecondsThan: milliseconds 
	
	self assert: (Time millisecondsToRun: closureToMeasure ) < (milliseconds * millisecond)! !
!CustomerBookTest methodsFor: 'time measuring' stamp: 'mr 9/5/2019 16:42:25'!
doing: closureToMeasure shouldNotTakeMoreMillisecondsThan: milliseconds 
	
	self assert: (Time millisecondsToRun: closureToMeasure ) < (milliseconds * millisecond)! !
!CustomerBookTest methodsFor: 'fail' stamp: 'mr 9/5/2019 16:42:37'!
doing: closureToFail shouldFailWith: error andDo: closureAfterFail
 	[ closureToFail value.
	  self fail ]
		on: error
		do: closureAfterFail! !

CustomerBookTest removeSelector: #closure:shouldFailWith:andDo:!

CustomerBookTest removeSelector: #closure:shouldNotTakeMoreMillisecondsThan:!
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/5/2019 16:43:08' prior: 50736874!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self doing: [ customerBook addCustomerNamed: 'john Lennon' ] shouldNotTakeMoreMillisecondsThan: 50
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/5/2019 16:43:20' prior: 50737193!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.

	self doing: [ customerBook removeCustomerNamed: paulMcCartney. ] shouldNotTakeMoreMillisecondsThan: 100.
! !
!CustomerBookTest methodsFor: 'fail' stamp: 'mr 9/5/2019 16:43:39'!
closure: closureToFail shouldFailWith: error andDo: closureAfterFail
 	[ closureToFail value.
	  self fail ]
		on: error
		do: closureAfterFail! !

CustomerBookTest removeSelector: #closure:shouldFailWith:andDo:!
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/5/2019 16:43:58' prior: 50737063!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.

	self doing: [ customerBook addCustomerNamed: ''. ] shouldFailWith: Error andDo: 
	[ :anError |
		self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
		self assert: customerBook isEmpty ]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/5/2019 16:44:08' prior: 50737076!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	self doing: [ customerBook removeCustomerNamed: 'Paul McCartney'. ] shouldFailWith: NotFound andDo: 
	[ :anError |
		self assert: customerBook numberOfCustomers = 1. 
		self assert: (customerBook includesCustomerNamed: johnLennon) ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/5/2019 16:44:15' prior: 50737160!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	self doing: [ customerBook suspendCustomerNamed: 'Paul McCartney'. ] shouldFailWith: CantSuspend andDo: [ 		:anError | 
			self assertCustomerBook: customerBook includes: johnLennon andHasNumberOfCustomers: 1]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'mr 9/5/2019 16:44:22' prior: 50737176!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	customerBook suspendCustomerNamed: johnLennon.

	self doing: [ customerBook suspendCustomerNamed: johnLennon. ] shouldFailWith: CantSuspend andDo: [ 		:anError | 
			self assertCustomerBook: customerBook includes: johnLennon andHasNumberOfCustomers: 1]! !

----SNAPSHOT----(5 September 2019 16:45:51) clase2.image priorSource: 12984440!

----SNAPSHOT----(5 September 2019 16:47:57) clase2.image priorSource: 12989086!

----QUIT----(5 September 2019 16:48:01) clase2.image priorSource: 12989167!

----STARTUP---- (7 September 2019 19:50:25) as /home/dago/Documents/Facultad/isw1/isw1/linux64/clase2.image!


----QUIT----(7 September 2019 20:01:47) clase2.image priorSource: 12989248!

----STARTUP---- (9 September 2019 17:02:19) as /home/mregnier/isw1/linux64/clase2.image!


----End fileIn of /home/mregnier/isw1/Pre-Numero-Ejercicio.st----!

| oneHalf |
oneHalf := Numero with: 1 over: 2.!

----SNAPSHOT----(9 September 2019 21:41:45) clase2.image priorSource: 12989436!

----QUIT----(9 September 2019 21:41:49) clase2.image priorSource: 13000116!

----STARTUP---- (11 September 2019 15:40:06) as /home/mregnier/isw1/linux64/clase2.image!


Smalltalk removeClassNamed: #Numero!

Smalltalk removeClassNamed: #NumeroTest!

----End fileIn of /home/mregnier/isw1/ejercicio2/Numero-Ejercicio.st----!

	zero := Entero with: 0.
	one := Entero with: 1.
	two := Entero with: 2.
	three:= Entero with: 3.
	four := Entero with: 4.
	five := Entero with: 5.
	eight := Entero with: 8.
	negativeOne := Entero with: -1.
	negativeTwo := Entero with: -2.!

	three / one!

	three / two!

	three / two !

one fibonacci.!

	oneHalf := Fraccion with: 1 over: 2.!

	oneHalf := one/two.!

	oneHalf + oneHalf.!

	oneHalf / oneHalf. !

oneHalf / oneHalf.!

oneHalf / oneHalf.!

oneHalf / oneHalf.!

	oneHalf := Fraccion with: one over: two.!

	three / two. !

	oneHalf * three.!
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:05:18' prior: 50738293!
+ anAdder 
	
	(anAdder isKindOf: self class)
	^self class with: value + anAdder integerValue
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:05:59' prior: 50738530!
+ anAdder 
	
	(anAdder isKindOf: self class) ifTrue: [
		^self class with: value + anAdder integerValue
		].
	
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:07:51' prior: 50738536!
+ anAdder 
	
	(anAdder isKindOf: self class) ifTrue: [
		^self class with: value + anAdder integerValue
		].
	(anAdder isKindOf: Fraccion) ifTrue: [
		^Fraccion new 
		].
	
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:13:38' prior: 50738543!
+ anAdder 
	
	
	
	(anAdder isKindOf: self class) ifTrue: [
		^self class with: value + anAdder integerValue
		].
	(anAdder isKindOf: Fraccion) ifTrue: [
		^Fraccion with: self * anAdder denominator + anAdder  numerator 
				      over: anAdder denominator 
 		].
	
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:16:06' prior: 50738552!
+ anAdder
	
	
	(anAdder isKindOf: self class) ifTrue: [
		^self class with: value + anAdder integerValue
		].
	(anAdder isKindOf: Fraccion) ifTrue: [
		| numerator denominator |
		numerator := self * anAdder denominator + anAdder  numerator.
		denominator := anAdder denominator.
		^Fraccion with: numerator over: denominator .
 		].
	
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:16:18' prior: 50738564!
+ anAdder
	
	
	(anAdder isKindOf: self class) ifTrue: [
		^self class with: value + anAdder integerValue
	].
	(anAdder isKindOf: Fraccion) ifTrue: [
		| numerator denominator |
		numerator := self * anAdder denominator + anAdder  numerator.
		denominator := anAdder denominator.
		^Fraccion with: numerator over: denominator .
	].
	
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:18:32' prior: 50738578!
+ anAdder
	
	
	(anAdder isKindOf: self class) ifTrue: [
		^self class with: value + anAdder integerValue
	].
	(anAdder isKindOf: Fraccion) ifTrue: [
		| newNumerator newDenominator |
		newNumerator := self * anAdder denominator + anAdder  numerator.
		newDenominator := anAdder denominator.
		^Fraccion with: newNumerator over: newDenominator .
	].
	
! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:22:07' prior: 50738406!
+ anAdder 
	
	| newNumerator newDenominator |
	
	(anAdder isKindOf: self class) ifTrue: [		
		newNumerator := (numerator * anAdder denominator) + (denominator * anAdder numerator).
		newDenominator := denominator * anAdder denominator.
	].
	(anAdder isKindOf: Entero) ifTrue:[
	
		
		
		].



	^newNumerator / newDenominator ! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:22:57' prior: 50738607!
+ anAdder 
	
	| newNumerator newDenominator |
	
	(anAdder isKindOf: self class) ifTrue: [		
		newNumerator := (numerator * anAdder denominator) + (denominator * anAdder numerator).
		newDenominator := denominator * anAdder denominator.
	].
	(anAdder isKindOf: Entero) ifTrue:[
		newNumerator := anAdder * self denominator + self  numerator.
		newDenominator := self denominator.
		].



	^newNumerator / newDenominator ! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:23:11' prior: 50738621!
+ anAdder 
	
	| newNumerator newDenominator |
	
	(anAdder isKindOf: self class) ifTrue: [		
		newNumerator := (numerator * anAdder denominator) + (denominator * anAdder numerator).
		newDenominator := denominator * anAdder denominator.
	].
	(anAdder isKindOf: Entero) ifTrue: [
		newNumerator := anAdder * self denominator + self  numerator.
		newDenominator := self denominator.
	].



	^newNumerator / newDenominator ! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:23:24' prior: 50738638!
+ anAdder 
	
	| newNumerator newDenominator |
	
	(anAdder isKindOf: self class) ifTrue: [		
		newNumerator := (numerator * anAdder denominator) + (denominator * anAdder numerator).
		newDenominator := denominator * anAdder denominator.
	].
	(anAdder isKindOf: Entero) ifTrue: [
		newNumerator := anAdder * self denominator + self  numerator.
		newDenominator := self denominator.
	].

	^newNumerator / newDenominator ! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:26:55' prior: 50738288!
* aMultiplier 
	
		
	(aMultiplier isKindOf: self class) ifTrue: [
		^self class with: value * aMultiplier integerValue
	].
	(aMultiplier isKindOf: Fraccion) ifTrue: [
		| newNumerator newDenominator |
		newNumerator := self * aMultiplier  numerator.
		newDenominator := aMultiplier denominator.
		^Fraccion with: newNumerator over: newDenominator .
	].
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:29:21' prior: 50738400!
* aMultiplier 
	

	
	(aMultiplier isKindOf: self class) ifTrue: [		
		^(numerator * aMultiplier numerator) / (denominator * aMultiplier denominator).
	].
	(aMultiplier isKindOf: Entero) ifTrue: [
		| newNumerator newDenominator |
		newNumerator := aMultiplier * self  numerator.
		newDenominator := self denominator.
		^newNumerator / newDenominator 
	].


	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:30:00' prior: 50738592!
+ anAdder
	
	
	(anAdder isKindOf: self class) ifTrue: [
		^self class with: value + anAdder integerValue
	].
	(anAdder isKindOf: Fraccion) ifTrue: [
		| newNumerator newDenominator |
		newNumerator := self * anAdder denominator + anAdder  numerator.
		newDenominator := anAdder denominator.
		^newNumerator / newDenominator .
	].
	
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:30:14' prior: 50738672!
* aMultiplier 
	
		
	(aMultiplier isKindOf: self class) ifTrue: [
		^self class with: value * aMultiplier integerValue
	].
	(aMultiplier isKindOf: Fraccion) ifTrue: [
		| newNumerator newDenominator |
		newNumerator := self * aMultiplier  numerator.
		newDenominator := aMultiplier denominator.
		^newNumerator / newDenominator .
	].
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:33:20' prior: 50738303!
/ aDivisor 
	
	(aDivisor isKindOf: self class) ifTrue: [
		^Fraccion with: self over: aDivisor
	].
	(aDivisor isKindOf: Fraccion) ifTrue: [
		| newNumerator newDenominator |
		newNumerator := self * aDivisor  denominator.
		newDenominator := aDivisor numerator.
		^newNumerator / newDenominator .
	].
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:34:21' prior: 50738730!
/ aDivisor 
	
	(aDivisor isKindOf: self class) ifTrue: [
		^Fraccion with: self over: aDivisor
	].
	(aDivisor isKindOf: Fraccion) ifTrue: [
		^self * aDivisor  denominator / aDivisor numerator.
	].
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:36:17' prior: 50738427!
/ aDivisor 
		
	(aDivisor isKindOf: self class) ifTrue: [		
		^(numerator * aDivisor denominator) / (denominator * aDivisor numerator)
	].
	(aDivisor isKindOf: Entero) ifTrue: [
		^ self numerator / (self denominator * aDivisor)
	].


	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:39:18' prior: 50738298!
- aSubtrahend 
	
	(aSubtrahend isKindOf: self class) ifTrue: [
		^self class with: value - aSubtrahend integerValue
	].
	(aSubtrahend isKindOf: Fraccion) ifTrue: [
		| newNumerator newDenominator |
		newNumerator := self * aSubtrahend denominator - aSubtrahend numerator.
		newDenominator := aSubtrahend denominator.
		^newNumerator / newDenominator .
	].! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:42:15' prior: 50738416!
- aSubtrahend 

	| newNumerator newDenominator |
	
	(aSubtrahend  isKindOf: self class) ifTrue: [		
		newNumerator := (numerator * aSubtrahend denominator) - (denominator * aSubtrahend numerator).
		newDenominator := denominator * aSubtrahend denominator.
	].
	(aSubtrahend isKindOf: Entero) ifTrue: [
		newNumerator := aSubtrahend * self denominator - self  numerator.
		newDenominator := self denominator.
	].

	^newNumerator / newDenominator ! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:42:37' prior: 50738779!
- aSubtrahend 

	| newNumerator newDenominator |
	
	(aSubtrahend  isKindOf: self class) ifTrue: [		
		newNumerator := (numerator * aSubtrahend denominator) - (denominator * aSubtrahend numerator).
		newDenominator := denominator * aSubtrahend denominator.
	].
	(aSubtrahend isKindOf: Entero) ifTrue: [
		newNumerator := self  numerator - aSubtrahend * self denominator.
		newDenominator := self denominator.
	].

	^newNumerator / newDenominator ! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/11/2019 16:43:56' prior: 50738796!
- aSubtrahend 

	| newNumerator newDenominator |
	
	(aSubtrahend  isKindOf: self class) ifTrue: [		
		newNumerator := (numerator * aSubtrahend denominator) - (denominator * aSubtrahend numerator).
		newDenominator := denominator * aSubtrahend denominator.
	].
	(aSubtrahend isKindOf: Entero) ifTrue: [
		newNumerator := self  numerator - (aSubtrahend * self denominator).
		newDenominator := self denominator.
	].

	^newNumerator / newDenominator ! !

----SNAPSHOT----(11 September 2019 18:16:24) clase2.image priorSource: 13000197!

----QUIT----(11 September 2019 18:44:51) clase2.image priorSource: 13029730!

----STARTUP---- (12 September 2019 16:59:11) as /home/mregnier/isw1/linux64/clase2.image!


Entero subclass: #OperacionMixta
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!
!Entero methodsFor: 'nil' stamp: 'mr 9/12/2019 20:35:53'!
sumarEntero: anIntegerAdder
	^self class with: value + anIntegerAdder integerValue! !
!Entero methodsFor: 'as yet unclassified' stamp: 'mr 9/12/2019 20:36:01'!
sumarFraccion: anIntegerAdder
	^self class with: value + anIntegerAdder integerValue! !
!Entero methodsFor: 'as yet unclassified' stamp: 'mr 9/12/2019 20:36:05' prior: 50738847!
sumarFraccion: anIntegerAdder
! !
!Entero methodsFor: 'as yet unclassified' stamp: 'mr 9/12/2019 20:36:29' prior: 50738853!
sumarFraccion: anIntegerAdder
	
		| newNumerator newDenominator |
		newNumerator := self * anIntegerAdder denominator + anIntegerAdder  numerator.
		newDenominator := anIntegerAdder denominator.
		^newNumerator / newDenominator .! !
!Entero methodsFor: 'as yet unclassified' stamp: 'mr 9/12/2019 20:36:43' prior: 50738842!
sumarEntero: anIntegerAdder

	^self class with: value + anIntegerAdder integerValue! !
!Fraccion methodsFor: 'nil' stamp: 'mr 9/12/2019 20:37:07'!
sumarEntero: anIntegerAdder

	! !
!Fraccion methodsFor: 'nil' stamp: 'mr 9/12/2019 20:37:25'!
sumarFraccin: aFractionalAdder
! !
!Entero methodsFor: 'as yet unclassified' stamp: 'mr 9/12/2019 20:37:47' prior: 50738857!
sumarFraccion: aFractionalAdder
	
		| newNumerator newDenominator |
		newNumerator := self * aFractionalAdder denominator + aFractionalAdder  numerator.
		newDenominator := aFractionalAdder denominator.
		^newNumerator / newDenominator .! !
!Fraccion methodsFor: 'as yet unclassified' stamp: 'mr 9/12/2019 20:38:43' prior: 50738876!
sumarFraccin: aFractionalAdder

	| newNumerator newDenominator |
	
	newNumerator := (numerator * aFractionalAdder denominator) + (denominator * aFractionalAdder numerator).
	newDenominator := denominator * aFractionalAdder denominator.
	^ newNumerator  / newDenominator ! !
!Fraccion methodsFor: 'as yet unclassified' stamp: 'mr 9/12/2019 20:39:19' prior: 50738873!
sumarEntero: anIntegerAdder

	
	| newDenominator newNumerator |
	newNumerator := anIntegerAdder * self denominator + self  numerator.
	newDenominator := self denominator.

	! !
!Fraccion methodsFor: 'as yet unclassified' stamp: 'mr 9/12/2019 20:40:00' prior: 50738903!
sumarEntero: anIntegerAdder

	
	| newDenominator newNumerator |
	newNumerator := anIntegerAdder * self denominator + self  numerator.
	newDenominator := self denominator.
	^ newNumerator / newDenominator 
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 20:40:35' prior: 50738702!
+ anAdder
	
	^ anAdder sumarEntero: self.
! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 20:41:00' prior: 50738655!
+ anAdder 
	
	^ anAdder sumarFraccion: self.! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 20:42:59'!
multiplicarFraccion: aFractionalMultiplier 
	
	^(numerator * aFractionalMultiplier numerator) / (denominator * aFractionalMultiplier denominator).
	

	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 20:43:38'!
multiplicarEntero: anIntegerMultiplier 
	
	| newNumerator newDenominator |
	newNumerator := anIntegerMultiplier * self  numerator.
	newDenominator := self denominator.
	^newNumerator / newDenominator 


	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 20:44:06' prior: 50738687!
* aMultiplier 
	
	^ aMultiplier multiplicarFraccion: self.

	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 20:44:54'!
multiplicarEntero: anIntegerMultiplier 
	
	^self class with: value * anIntegerMultiplier integerValue
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 20:45:23'!
multiplicarFraccion: aFractionalMultiplier 
	
	| newNumerator newDenominator |
	newNumerator := self * aFractionalMultiplier  numerator.
	newDenominator := aFractionalMultiplier denominator.
	^newNumerator / newDenominator .
! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 20:52:42'!
subtractFromInteger: anIntegerMinuend 
		^self class with: anIntegerMinuend integerValue - value
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 20:52:49' prior: 50738970!
subtractFromInteger: anIntegerMinuend 

		^self class with: anIntegerMinuend integerValue - value
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 20:55:53'!
substractFromFraction: aFractionalMinuend

	| newNumerator newDenominator |
	newNumerator := aFractionalMinuend numerator - self * aFractionalMinuend denominator.
	newDenominator := aFractionalMinuend denominator.

	^newNumerator / newDenominator .
! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 20:57:27'!
substractFromInteger: anIntegerMinuend

	| newDenominator newNumerator |
	newNumerator := anIntegerMinuend * self denominator - self  numerator.
	newDenominator := self denominator.

	^newNumerator / newDenominator ! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 20:59:48'!
substractFromFraction: aFractionalMinuend

	| newDenominator newNumerator |
	newNumerator := denominator * aFractionalMinuend numerator - (numerator * aFractionalMinuend denominator).
	newDenominator := denominator * aFractionalMinuend denominator.

	^newNumerator / newDenominator ! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:04:01'!
divideFraction: aFractionalDividend 
	
	^self * aFractionalDividend  denominator / aFractionalDividend numerator.
	
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:04:33' prior: 50739016!
divideFraction: aFractionalDividend 
	
	^ aFractionalDividend numerator / (aFractionalDividend numerator * self).
	
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:04:40' prior: 50739023!
divideFraction: aFractionalDividend 
	
	^ aFractionalDividend numerator / (aFractionalDividend denominator * self).
	
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:05:37'!
divideInteger: anIntegerDividend 
	
	^Fraccion with: anIntegerDividend over: self
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:07:24'!
divideInteger: anIntegerDividend 
	
	^ (self denominator * anIntegerDividend ) / self numerator.
	


	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:09:38'!
divideFraction: aFractionalDividend

	^ denominator * aFractionalDividend numerator / (numerator * aFractionalDividend denominator)

	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:11:45' prior: 50738764!
- aSubtrahend 
	
	^ aSubtrahend substractFromInteger: self.! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:12:12' prior: 50738743!
/ aDivisor 
	
	^ aDivisor divideInteger: self.! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:12:43' prior: 50738813!
- aSubtrahend 

	^ aSubtrahend substractFromFraction: self.! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:13:13' prior: 50738753!
/ aDivisor 
		
	^ aDivisor divideFraction: self.


	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:15:50'!
addInteger: anIntegerAdder

	
	| newDenominator newNumerator |
	newNumerator := anIntegerAdder * self denominator + self  numerator.
	newDenominator := self denominator.
	^ newNumerator / newDenominator 
	! !

Fraccion removeSelector: #sumarEntero:!
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:17:02'!
addInteger: anIntegerAdder

	^self class with: value + anIntegerAdder integerValue! !
!Entero methodsFor: 'as yet unclassified' stamp: 'mr 9/12/2019 21:17:02' prior: 50738922!
+ anAdder
	
	^ anAdder addInteger: self.
! !

Entero removeSelector: #sumarEntero:!
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:18:40'!
addFraction: aFractionalAdder
	
		| newNumerator newDenominator |
		newNumerator := self * aFractionalAdder denominator + aFractionalAdder  numerator.
		newDenominator := aFractionalAdder denominator.
		^newNumerator / newDenominator .! !
!Fraccion methodsFor: 'as yet unclassified' stamp: 'mr 9/12/2019 21:18:40' prior: 50738927!
+ anAdder 
	
	^ anAdder addFraction: self.! !

Entero removeSelector: #sumarFraccion:!
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:19:15'!
multiplyFraction: aFractionalMultiplier 
	
	| newNumerator newDenominator |
	newNumerator := self * aFractionalMultiplier  numerator.
	newDenominator := aFractionalMultiplier denominator.
	^newNumerator / newDenominator .
! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:19:15'!
multiplyFraction: aFractionalMultiplier 
	
	^(numerator * aFractionalMultiplier numerator) / (denominator * aFractionalMultiplier denominator).
	

	! !
!Fraccion methodsFor: 'as yet unclassified' stamp: 'mr 9/12/2019 21:19:15' prior: 50738949!
* aMultiplier 
	
	^ aMultiplier multiplyFraction: self.

	! !

Entero removeSelector: #multiplicarFraccion:!

Fraccion removeSelector: #multiplicarFraccion:!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:19:49'!
multiplyInteger: anIntegerMultiplier 
	
	| newNumerator newDenominator |
	newNumerator := anIntegerMultiplier * self  numerator.
	newDenominator := self denominator.
	^newNumerator / newDenominator 


	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:19:49'!
multiplyInteger: anIntegerMultiplier 
	
	^self class with: value * anIntegerMultiplier integerValue
! !

Fraccion removeSelector: #multiplicarEntero:!

Entero removeSelector: #multiplicarEntero:!
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:20:35' prior: 50738716!
* aMultiplier 
	
	^ aMultiplier multiplyInteger: self .
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'mr 9/12/2019 21:21:41'!
addFraction: aFractionalAdder

	| newNumerator newDenominator |
	
	newNumerator := (numerator * aFractionalAdder denominator) + (denominator * aFractionalAdder numerator).
	newDenominator := denominator * aFractionalAdder denominator.
	^ newNumerator  / newDenominator ! !

Fraccion removeSelector: #sumarFraccin:!

----SNAPSHOT----(12 September 2019 21:24:08) clase2.image priorSource: 13029812!
!Entero methodsFor: 'arithmetic operations private' stamp: 'mr 9/12/2019 21:25:49' prior: 50738983!
substractFromFraction: aFractionalMinuend

	| newNumerator newDenominator |
	newNumerator := aFractionalMinuend numerator - (self * aFractionalMinuend denominator).
	newDenominator := aFractionalMinuend denominator.

	^newNumerator / newDenominator .
! !
!Entero methodsFor: 'arithmetic operations private' stamp: 'mr 9/12/2019 21:27:02'!
substractFromInteger: anIntegerMinuend 

		^self class with: anIntegerMinuend integerValue - value
	! !

Entero removeSelector: #subtractFromInteger:!

----SNAPSHOT----(12 September 2019 21:27:43) clase2.image priorSource: 13040859!

----SNAPSHOT----(12 September 2019 21:39:49) clase2.image priorSource: 13041558!

----STARTUP---- (14 September 2019 16:18:28) as /home/dago/Documents/Facultad/isw1/isw1/linux64/clase2.image!


Entero subclass: #PositivosMayoresAUno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classDefinition: #PositivosMayoresAUno category: #'Numero-Exercise'!
Entero subclass: #PositivosMayoresAUno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

Entero subclass: #Uno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classDefinition: #Uno category: #'Numero-Exercise'!
Entero subclass: #Uno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

Entero subclass: #Cero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classDefinition: #Cero category: #'Numero-Exercise'!
Entero subclass: #Cero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

Entero subclass: #Negativos
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classDefinition: #Negativos category: #'Numero-Exercise'!
Entero subclass: #Negativos
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

Entero subclass: #Negativo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classDefinition: #Negativo category: #'Numero-Exercise'!
Entero subclass: #Negativo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

Smalltalk removeClassNamed: #Negativos!

Entero subclass: #PositivoMayoresAUno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classDefinition: #PositivoMayoresAUno category: #'Numero-Exercise'!
Entero subclass: #PositivoMayoresAUno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

Entero subclass: #PositivoMayorAUno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classDefinition: #PositivoMayorAUno category: #'Numero-Exercise'!
Entero subclass: #PositivoMayorAUno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

Smalltalk removeClassNamed: #PositivoMayoresAUno!

Smalltalk removeClassNamed: #PositivosMayoresAUno!
!Uno methodsFor: 'no messages' stamp: 'mr 9/14/2019 16:40:35'!
fibonacci

	^self! !
!Cero methodsFor: 'nil' stamp: 'mr 9/14/2019 16:40:58'!
fibonacci
	^Uno! !
!Entero methodsFor: 'arithmetic operations' stamp: 'mr 9/14/2019 16:44:28' prior: 50738313!
fibonacci

	^self subclassResponsibility 
"
	| one two |
	
	one := Entero with: 1.
	two := Entero with: 2.
	
	self isNegative ifTrue: [self error: Entero negativeFibonacciErrorDescription ].	
	(self isZero or: [self isOne]) ifTrue: [^one].
	
	^ (self - one) fibonacci + (self - two) fibonacci
	"	! !
!Cero methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 16:44:44' prior: 50739288!
fibonacci
	^Entero with: 1! !
!PositivoMayorAUno methodsFor: 'no messages' stamp: 'mr 9/14/2019 16:45:12'!
fibonacci
! !
!PositivoMayorAUno methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 16:45:49' prior: 50739309!
fibonacci


 | one two |
^ (self - one) fibonacci + (self - two) fibonacci! !
!PositivoMayorAUno methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 16:46:31' prior: 50739313!
fibonacci

	| one two |

	one := Entero with: 1.
	two := Entero with: 2.
	^ (self - one) fibonacci + (self - two) fibonacci! !
!Negativo methodsFor: 'no messages' stamp: 'mr 9/14/2019 16:48:59'!
fibonacci

	self error: Entero negativeFibonacciErrorDescription.! !
!Negativo class methodsFor: 'no messages' stamp: 'mr 9/14/2019 16:49:24'!
negativeFibonacciErrorDescription
	^ ' Fibonacci no est definido aqu para Enteros Negativos'! !

Entero class removeSelector: #negativeFibonacciErrorDescription!
!Entero class methodsFor: 'instance creation' stamp: 'mr 9/14/2019 16:51:13'!
negativeFibonacciErrorDescription
	^ ' Fibonacci no est definido aqu para Enteros Negativos'! !
!Entero class methodsFor: 'instance creation' stamp: 'mr 9/14/2019 16:54:01' prior: 50738378!
with: aValue 
	
	"Esta verificacion esta puesta por si se equivocan y quieren crear un Entero pasando otra cosa que un Integer - Hernan"
	aValue isInteger ifFalse: [  self error: 'aValue debe ser anInteger' ].
	
	aValue = 0 ifTrue:[ ^Cero new initializeWith: aValue ].
	aValue = 1 ifTrue:[ ^Uno new initializeWith: aValue ].
	aValue < 0 ifTrue:[ ^Negativo new initializeWith: aValue ].
	^self new initalizeWith: aValue
	! !
!Entero class methodsFor: 'instance creation' stamp: 'mr 9/14/2019 16:54:40' prior: 50739345!
with: aValue 
	
	"Esta verificacion esta puesta por si se equivocan y quieren crear un Entero pasando otra cosa que un Integer - Hernan"
	aValue isInteger ifFalse: [  self error: 'aValue debe ser anInteger' ].
	
	aValue = 0 ifTrue:[ ^Cero new initializeWith: aValue ].
	aValue = 1 ifTrue:[ ^Uno new initializeWith: aValue ].
	aValue < 0 ifTrue:[ ^Negativo new initializeWith: aValue ].
	^PositivoMayorAUno new initalizeWith: aValue
	! !
!Entero class methodsFor: 'instance creation' stamp: 'mr 9/14/2019 16:57:13' prior: 50739362!
with: aValue 
	
	"Esta verificacion esta puesta por si se equivocan y quieren crear un Entero pasando otra cosa que un Integer - Hernan"
	aValue isInteger ifFalse: [  self error: 'aValue debe ser anInteger' ].
	
	aValue = 0 ifTrue:[ ^Cero new initialize ].
	aValue = 1 ifTrue:[ ^Uno new initialize ].
	aValue < 0 ifTrue:[ ^Negativo new initializeWith: aValue ].
	^PositivoMayorAUno new initalizeWith: aValue
	! !
!Cero methodsFor: 'nil' stamp: 'mr 9/14/2019 16:57:40'!
initialize
	value:= 0! !
!Uno methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 16:57:55'!
initialize
	value:= 1! !
!Negativo methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 16:59:21'!
initializeWith: aNegativeValue

	value:= aNegativeValue ! !
!PositivoMayorAUno methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 17:00:28'!
initializeWith: aValueGreaterThanOne

	value := aValueGreaterThanOne ! !

9 gcd: 0.!

9 gcd: 0.!

9 gcd: 1.!

-9 gcd: -1.!

-9 gcd: 1.!

9 gcd: -3.!

9 gcd: -3.!

9 gcd: -3.!

-9 gcd: -3.!

-3/3.!
!Fraccion class methodsFor: 'intance creation' stamp: 'mr 9/14/2019 17:17:24' prior: 50738489!
with: aDividend over: aDivisor

	| greatestCommonDivisor numerator denominator |
	
"	aDivisor isZero ifTrue: [ self error: self canNotDivideByZeroErrorDescription ].
	aDividend isZero ifTrue: [ ^aDividend ].
	
	aDivisor isNegative ifTrue:[ ^aDividend negated / aDivisor negated].
"	
	greatestCommonDivisor := aDividend greatestCommonDivisorWith: aDivisor. 
	numerator := aDividend // greatestCommonDivisor.
	denominator := aDivisor // greatestCommonDivisor.

	^ aDivisor makeFractionAsDivisorWith: aDividend.
	
"	denominator isOne ifTrue: [ ^numerator ].

	^self new initializeWith: numerator over: denominator
"	! !
!Fraccion class methodsFor: 'intance creation' stamp: 'mr 9/14/2019 17:19:31' prior: 50739416!
with: aDividend over: aDivisor

	| greatestCommonDivisor numerator denominator |
	
"	aDivisor isZero ifTrue: [ self error: self canNotDivideByZeroErrorDescription ].
	aDividend isZero ifTrue: [ ^aDividend ].
	
	aDivisor isNegative ifTrue:[ ^aDividend negated / aDivisor negated].
"	
	greatestCommonDivisor := aDividend greatestCommonDivisorWith: aDivisor. 
	numerator := aDividend // greatestCommonDivisor.
	denominator := aDivisor // greatestCommonDivisor.

	^ denominator makeFractionAsDenominatorWith: numerator.
	
"	denominator isOne ifTrue: [ ^numerator ].

	^self new initializeWith: numerator over: denominator
"	! !
!Entero methodsFor: 'nil' stamp: 'mr 9/14/2019 17:20:38'!
makeFractionAsDenominatorWith: aNumerator
	
	^ self subclassResponsibility ! !
!Cero methodsFor: 'nil' stamp: 'mr 9/14/2019 17:21:30'!
makeFractionAsDenominatorWith: aNumerator
	! !
!Cero methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 17:22:22' prior: 50739466!
makeFractionAsDenominatorWith: aNumerator

	^ Fraccion error: Fraccion canNotDivideByZeroErrorDescription
	! !
!Uno methodsFor: 'nil' stamp: 'mr 9/14/2019 17:23:04'!
makeFractionAsDenominatorWith: aNumerator

	^ aNumerator ! !
!Negativo class methodsFor: 'nil' stamp: 'mr 9/14/2019 17:24:27'!
makeFractionAsDenominatorWith: aNumerator

	^ aNumerator negated / self negated! !
!Negativo methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 17:24:58'!
makeFractionAsDenominatorWith: aNumerator

	^ aNumerator negated / self negated! !

Negativo class removeSelector: #makeFractionAsDenominatorWith:!
!PositivoMayorAUno class methodsFor: 'nil' stamp: 'mr 9/14/2019 17:28:42'!
makeFractionAsDenominatorWith: aNumerator

	^ aNumerator makeFractionAsNumeratorWith: self
! !
!PositivoMayorAUno class methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 17:28:56' prior: 50739493!
makeFractionAsDenominatorWith: aNumerator

	^ aNumerator makeFractionAsNumeratorWithPositive: self
! !
!PositivoMayorAUno methodsFor: 'nil' stamp: 'mr 9/14/2019 17:29:38'!
makeFractionAsDenominatorWith: aNumerator

	^ aNumerator makeFractionAsNumeratorWithPositive: self
! !

PositivoMayorAUno class removeSelector: #makeFractionAsDenominatorWith:!
!Cero methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 17:30:53'!
makeFractionAsNumeratorWithPositive: aNumerator

	^ self! !
!Uno methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 17:31:59'!
makeFractionAsNumeratorWithPositive: aNumerator

	^ Fraccion with: self over: aNumerator! !
!PositivoMayorAUno methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 17:32:37'!
makeFractionAsNumeratorWithPositive: aDenominator

	^ Fraccion with: self over: aDenominator! !
!Uno methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 17:33:08' prior: 50739519!
makeFractionAsNumeratorWithPositive: aDenominator

	^ Fraccion with: self over: aDenominator! !
!PositivoMayorAUno methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 17:35:56' prior: 50739525!
makeFractionAsNumeratorWithPositive: aDenominator

	^ Fraccion new initializeWith: self over: aDenominator! !
!Uno methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 17:37:21' prior: 50739531!
makeFractionAsNumeratorWithPositive: aDenominator

	^ Fraccion new initializeWith: self over: aDenominator! !
!Negativo methodsFor: 'nil' stamp: 'mr 9/14/2019 17:42:10'!
makeFractionAsNumeratorWithPositive: aPositiveDenominator

	^ Fraccion new initializeWith: self over: aPositiveDenominator! !

----SNAPSHOT----(14 September 2019 17:43:21) clase2.image priorSource: 13041640!

Smalltalk removeClassNamed: #Fraccion!

Smalltalk removeClassNamed: #Uno!

Smalltalk removeClassNamed: #PositivoMayorAUno!

Smalltalk removeClassNamed: #Negativo!

Smalltalk removeClassNamed: #Cero!

Smalltalk removeClassNamed: #Entero!

Smalltalk removeClassNamed: #Numero!

Smalltalk removeClassNamed: #NumeroTest!

----End fileIn of /home/dago/Documents/Facultad/isw1/isw1/19- Numeros/Numero-Exercise.st----!

Smalltalk removeClassNamed: #Fraccion!

Smalltalk removeClassNamed: #Entero!

Smalltalk removeClassNamed: #Numero!

Smalltalk removeClassNamed: #NumeroTest!

----End fileIn of /home/dago/Documents/Facultad/isw1/isw1/19- Numeros/Numero-ExerciseNoIfs.st----!
!Cero methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 17:45:42' prior: 50740861!
makeFractionAsDenominatorWith: aNumerator

	^ self class error: self class canNotDivideByZeroErrorDescription
	! !
!Entero class methodsFor: 'instance creation' stamp: 'mr 9/14/2019 17:46:05' prior: 50740828!
with: aValue 
	
	"Esta verificacion esta puesta por si se equivocan y quieren crear un Entero pasando otra cosa que un Integer - Hernan"
	aValue isInteger ifFalse: [  self error: 'aValue debe ser anInteger' ].
	
	aValue = 0 ifTrue:[ ^Cero new initialize ].
	aValue = 1 ifTrue:[ ^Uno new initialize ].
	aValue < 0 ifTrue:[ ^Negativo new initializeWith: aValue ].
	
	^PositivoMayorAUno new initalizeWith: aValue
	! !
!Entero methodsFor: 'initialization' stamp: 'mr 9/14/2019 17:46:43' prior: 50740785!
initalizeWith: aValue 
	
	self subclassResponsibility ! !
!Entero methodsFor: 'nil' stamp: 'mr 9/14/2019 17:47:51' prior: 50740810!
makeFractionAsDenominatorWith: aNumerator

	self subclassResponsibility ! !
!Entero methodsFor: 'as yet unclassified' stamp: 'mr 9/14/2019 17:48:17'!
makeFractionAsNumeratorWithPositive: aPositiveDenominator

	self subclassResponsibility ! !

Entero removeSelector: #initalizeWith:!

Smalltalk removeClassNamed: #Fraccion!

Smalltalk removeClassNamed: #Uno!

Smalltalk removeClassNamed: #PositivoMayorAUno!

Smalltalk removeClassNamed: #Negativo!

Smalltalk removeClassNamed: #Cero!

Smalltalk removeClassNamed: #Entero!

Smalltalk removeClassNamed: #Numero!

Smalltalk removeClassNamed: #NumeroTest!

----End fileIn of /home/dago/Documents/Facultad/isw1/isw1/19- Numeros/Numero-ExerciseNoIfs.st----!

Smalltalk removeClassNamed: #Fraccion!

Smalltalk removeClassNamed: #Uno!

Smalltalk removeClassNamed: #PositivoMayorAUno!

Smalltalk removeClassNamed: #Negativo!

Smalltalk removeClassNamed: #Cero!

Smalltalk removeClassNamed: #Entero!

Smalltalk removeClassNamed: #Numero!

Smalltalk removeClassNamed: #NumeroTest!

----End fileIn of /home/dago/Documents/Facultad/isw1/isw1/linux64/Numero-ExerciseEstaRoto.st----!
!Entero class methodsFor: 'instance creation' stamp: 'mr 9/14/2019 17:55:35' prior: 50742633!
with: aValue 
	
	"Esta verificacion esta puesta por si se equivocan y quieren crear un Entero pasando otra cosa que un Integer - Hernan"
	aValue isInteger ifFalse: [  self error: 'aValue debe ser anInteger' ].
	
	aValue = 0 ifTrue:[ ^Cero new initialize ].
	aValue = 1 ifTrue:[ ^Uno new initialize ].
	aValue < 0 ifTrue:[ ^Negativo new initializeWith: aValue ].
	
	^PositivoMayorAUno new initializeWith: aValue
	! !
!Entero methodsFor: 'nil' stamp: 'mr 9/14/2019 17:57:17'!
initializeWith: aNumber

	self subclassResponsibility ! !

Negativo class removeSelector: #negativeFibonacciErrorDescription!

----SNAPSHOT----(14 September 2019 17:59:35) clase2.image priorSource: 13053021!

----QUIT----(14 September 2019 18:04:52) clase2.image priorSource: 13163101!

----STARTUP---- (16 September 2019 17:32:42) as /home/mregnier/isw1/linux64/clase2.image!


----End fileIn of /home/mregnier/isw1/20-Stack/Ejercicio/Stack-Exercise.st----!
!OOStack methodsFor: 'no messages' stamp: 'dr 9/16/2019 19:07:02'!
isEmpty

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:07:37'!
push: anElementToPush

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:07:44'!
pop



! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:08:47'!
top



! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:09:00'!
size



! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:10:01'!
initialize
	! !

Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:10:42' prior: 50743176!
initialize
	
	elements := Array new. ! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:13:54' prior: 50743190!
initialize
	
	elements := OrderedCollection new. ! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:16:34' prior: 50743160!
isEmpty

	^ elements isEmpty! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:16:59' prior: 50743200!
isEmpty

	^ elements isEmpty.! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:18:23' prior: 50743167!
pop

	^self isEmpty ifTrue: [ self error: self class stackEmptyErrorDescription. ].


! !

#(1 2 3 4) removeLast!

OrderedCollection new add: 3; removeLast!

OrderedCollection new add: 3;add: 4; removeLast!
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:21:44' prior: 50743208!
pop

	self isEmpty ifTrue: [ self error: self class stackEmptyErrorDescription. ].
		
	"else "
	
	^ elements removeLast

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:22:46' prior: 50743163!
push: anElementToPush

	elements addLast: anElementToPush ! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:23:41' prior: 50743173!
size

	^ elements size.

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:24:00' prior: 50743170!
top

	^ elements last.

! !

OrderedCollection new add: 3;add: 4; last !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:25:01' prior: 50743234!
top
	self isEmpty ifTrue: []
	^ elements last.

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:25:40' prior: 50743240!
top
	self isEmpty ifTrue: [ self error: self class stackEmptyErrorDescription. ].

	^ elements last.

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:25:44' prior: 50743245!
top

	self isEmpty ifTrue: [ self error: self class stackEmptyErrorDescription. ].

	^ elements last.

! !

OOStack subclass: #OOEmptyStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStack subclass: #OOEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOEmptyStack category: #'Stack-Exercise'!
OOStack subclass: #OOEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStack subclass: #OOStackWithElements
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackWithElements category: #'Stack-Exercise'!
OOStack subclass: #OOStackWithElements
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOEmptyStack class methodsFor: 'no messages' stamp: 'dr 9/16/2019 19:30:13'!
initialize
! !

Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Smalltalk removeClassNamed: #OOEmptyStack!

Smalltalk removeClassNamed: #OOStackWithElements!

OOStack subclass: #OOStackWithElements
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackWithElements category: #'Stack-Exercise'!
OOStack subclass: #OOStackWithElements
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStack subclass: #OOEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOEmptyStack category: #'Stack-Exercise'!
OOStack subclass: #OOEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOEmptyStack class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'OOEmptyStack class' category: #'Stack-Exercise'!
OOEmptyStack class
	instanceVariableNames: 'uniqueInstance'!
!OOEmptyStack class methodsFor: 'no messages' stamp: 'dr 9/16/2019 19:53:04'!
new
	
	^ uniqueInstance.! !
!OOEmptyStack class methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:53:27'!
initialize

	^ uniqueInstance := self basicNew.! !
!OOEmptyStack class methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:53:34' prior: 50743336!
initialize

	uniqueInstance := self basicNew.! !
!OOEmptyStack methodsFor: 'nil' stamp: 'dr 9/16/2019 19:53:55'!
isEmpty

	^ true.! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:54:14' prior: 50743218!
pop

		
	"else "
	
	^ elements removeLast

! !
!OOEmptyStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:54:39'!
pop

	self error: self class stackEmptyErrorDescription.! !

Smalltalk removeClassNamed: #OOEmptyStack!

Smalltalk removeClassNamed: #OOStackWithElements!

Object subclass: #OOStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackState category: #'Stack-Exercise'!
Object subclass: #OOStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStackState subclass: #OOEmptyState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOEmptyState category: #'Stack-Exercise'!
OOStackState subclass: #OOEmptyState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStackState subclass: #OONotEmptyState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OONotEmptyState category: #'Stack-Exercise'!
OOStackState subclass: #OONotEmptyState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStackState subclass: #OONotEmptyStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OONotEmptyStackState category: #'Stack-Exercise'!
OOStackState subclass: #OONotEmptyStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStackState subclass: #OOEmptyStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOEmptyStackState category: #'Stack-Exercise'!
OOStackState subclass: #OOEmptyStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Smalltalk removeClassNamed: #OOEmptyState!

Smalltalk removeClassNamed: #OONotEmptyState!
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:59:14' prior: 50743195!
initialize
	
	elements := OOEmptyStackState new. ! !

Object subclass: #OOStack
	instanceVariableNames: 'state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #OOStack
	instanceVariableNames: 'elements state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise'!
Object subclass: #OOStack
	instanceVariableNames: 'elements state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 19:59:53' prior: 50743418!
initialize
	
	state := OOEmptyStackState new. ! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:00:03' prior: 50743204!
isEmpty

	^ state isEmpty.! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:00:55' prior: 50743349!
pop

	^ state := state pop 
"	^ elements removeLast"

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:01:25' prior: 50743225!
push: anElementToPush
	
	state := state push: anElementToPush.
	"elements addLast: anElementToPush "! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:04:28' prior: 50743457!
pop
	| topElement |
	topElement  := state top.
	state := state pop. 
"	^ elements removeLast"

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:04:40' prior: 50743469!
pop
	| topElement |
	topElement  := state top.
	state := state pop.
	^topElement 
"	^ elements removeLast"

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:04:49' prior: 50743475!
pop

	| topElement |
	topElement  := state top.
	state := state pop.
	^ topElement 
"	^ elements removeLast"

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:05:03' prior: 50743230!
size

	^ state size.

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:05:36' prior: 50743252!
top

	^ state top.
	
	"self isEmpty ifTrue: [ self error: self class stackEmptyErrorDescription. ].

	^ elements last."

! !
!OONotEmptyStackState methodsFor: 'no messages' stamp: 'dr 9/16/2019 20:06:27'!
initializeWith: anElement

	! !

OOStackState subclass: #OONotEmptyStackState
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OONotEmptyStackState category: #'Stack-Exercise'!
OOStackState subclass: #OONotEmptyStackState
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:34:57' prior: 50743448!
initialize
	
	state := OOEmptyStackSlot new. ! !

OOStackSlot subclass: #OONotEmptyStackSlot
	instanceVariableNames: 'nextSlot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OONotEmptyStackSlot category: #'Stack-Exercise'!
OOStackSlot subclass: #OONotEmptyStackSlot
	instanceVariableNames: 'nextSlot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OONotEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:36:57'!
initializeWith: anElement withNext: aNextSlot

	

	! !

OONotEmptyStackSlot removeSelector: #initializeWith:!
!OOStackSlot methodsFor: 'no messages' stamp: 'dr 9/16/2019 20:39:24'!
pop

	self subclassResponsibility.! !
!OOStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:39:31'!
push

	self subclassResponsibility.! !
!OOStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:39:45'!
push: anElement

	self subclassResponsibility.! !
!OOStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:39:53'!
isEmpty

	self subclassResponsibility.! !
!OOStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:40:00'!
top

	self subclassResponsibility.! !

OOStackSlot removeSelector: #push!

OOStackSlot subclass: #OONotEmptyStackSlot
	instanceVariableNames: 'nextSlot value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OONotEmptyStackSlot category: #'Stack-Exercise'!
OOStackSlot subclass: #OONotEmptyStackSlot
	instanceVariableNames: 'nextSlot value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OONotEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:41:31' prior: 50743532!
initializeWith: anElement withNext: aNextSlot

	value := anElement. 
	nextSlot := aNextSlot .
	

	! !
!OONotEmptyStackSlot class methodsFor: 'nil' stamp: 'dr 9/16/2019 20:46:15'!
with: aValue withNext: aNextSlot

	! !
!OONotEmptyStackSlot class methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:47:03' prior: 50743579!
with: aValue withNext: aNextSlot

	^ self new initializeWith: aValue withNext: aNextSlot.! !
!OOEmptyStackSlot methodsFor: 'no messages' stamp: 'dr 9/16/2019 20:47:42'!
isEmpty

	^ true! !
!OONotEmptyStackSlot methodsFor: 'nil' stamp: 'dr 9/16/2019 20:47:57'!
isEmpty

	^ false! !
!OOEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:48:50'!
pop

	^ self error: OOStack! !
!OOEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:49:15' prior: 50743597!
pop

	^ self error: OOStack stackEmptyErrorDescription ! !
!OOEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:50:29'!
push: anElement

	^ OONotEmptyStackSlot with: anElement withNext: self! !
!OONotEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:51:13'!
push: anElement

	^ OONotEmptyStackSlot  with: anElement  withNext: self! !
!OONotEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:51:57'!
pop

	^ nextSlot ! !
!OOEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:52:50'!
top

	self error: OOStack stackEmptyErrorDescription ! !
!OONotEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:53:06'!
top

	^ value! !
!OONotEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:53:07' prior: 50743628!
top

	^ value.! !

Object subclass: #OOStack
	instanceVariableNames: 'state stack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #OOStack
	instanceVariableNames: 'state topOfStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #OOStack
	instanceVariableNames: 'state topOfStack elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

----SNAPSHOT----(16 September 2019 20:55:37) clase2.image priorSource: 13163183!

Object subclass: #OOStack
	instanceVariableNames: 'state topOfStack elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #OOStack
	instanceVariableNames: 'state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise'!
Object subclass: #OOStack
	instanceVariableNames: 'state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #OOStack
	instanceVariableNames: 'state topOfStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise'!
Object subclass: #OOStack
	instanceVariableNames: 'state topOfStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:57:34' prior: 50743516!
initialize
	
	topOfStack := OOEmptyStackSlot new. 
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:57:49' prior: 50743453!
isEmpty

	^ topOfStack isEmpty.! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:58:12' prior: 50743482!
pop

	| topElement |
	topElement  := topOfStack top.
	topOfStack := topOfStack pop.
	^ topElement 

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:58:25' prior: 50743462!
push: anElementToPush
	
	topOfStack := topOfStack push: anElementToPush.
	"elements addLast: anElementToPush "! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:58:31' prior: 50743694!
push: anElementToPush
	
	topOfStack := topOfStack push: anElementToPush.! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 20:58:40' prior: 50743489!
size

	^ topOfStack size.

! !

OOStackSlot subclass: #OONotEmptyStackSlot
	instanceVariableNames: 'nextSlot value amountOfNextElements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OONotEmptyStackSlot category: #'Stack-Exercise'!
OOStackSlot subclass: #OONotEmptyStackSlot
	instanceVariableNames: 'nextSlot value amountOfNextElements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OONotEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 21:01:01' prior: 50743613!
push: anElement
	
	^ OONotEmptyStackSlot  with: anElement  withNext: self! !

Object subclass: #OOStack
	instanceVariableNames: 'topOfStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise'!
Object subclass: #OOStack
	instanceVariableNames: 'topOfStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 21:02:16' prior: 50743493!
top

	^ topOfStack top.
	
	"self isEmpty ifTrue: [ self error: self class stackEmptyErrorDescription. ].

	^ elements last."

! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 21:02:23' prior: 50743741!
top

	^ topOfStack top.
	
! !

OOStackSlot subclass: #OONotEmptyStackSlot
	instanceVariableNames: 'nextSlot value amountOfNextElements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OONotEmptyStackSlot category: #'Stack-Exercise'!
OOStackSlot subclass: #OONotEmptyStackSlot
	instanceVariableNames: 'nextSlot value amountOfNextElements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OONotEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 21:04:54' prior: 50743573!
initializeWith: anElement withNext: aNextSlot
	
	value := anElement. 
	nextSlot := aNextSlot .
	amountOfNextElements := aNextSlot size - 1
	

	! !
!OONotEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 21:06:18'!
size 
	
	^ amountOfNextElements.

	! !
!OOEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 21:06:36'!
size

	^ 0.! !
!OONotEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 21:06:52' prior: 50743766!
initializeWith: anElement withNext: aNextSlot
	
	value := anElement. 
	nextSlot := aNextSlot .
	amountOfNextElements := aNextSlot size + 1
	

	! !
!OONotEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 21:06:55' prior: 50743782!
initializeWith: anElement withNext: aNextSlot
	
	value := anElement. 
	nextSlot := aNextSlot .
	amountOfNextElements := aNextSlot size + 1.
	

	! !
!OONotEmptyStackSlot methodsFor: 'as yet unclassified' stamp: 'dr 9/16/2019 21:07:23' prior: 50743619!
pop

	^ nextSlot ! !

----SNAPSHOT----(16 September 2019 21:19:30) clase2.image priorSource: 13183944!

----QUIT----(16 September 2019 21:19:57) clase2.image priorSource: 13188820!

----STARTUP---- (17 September 2019 14:56:00) as /home/mregnier/isw1/linux64/clase2.image!


Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: 'sentences'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: 'sentences'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefix methodsFor: 'no messages' stamp: 'dr 9/17/2019 15:19:10'!
initialize

	sentences := OOStack new.! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:19:28'!
pushSentence: aSentence! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:19:33'!
popSentence! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:19:44'!
find: aPrefix! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:19:50'!
isEmpty! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:20:16' prior: 50743838!
isEmpty

	^ sentences isEmpty! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:20:34' prior: 50743830!
popSentence

	^ sentences pop.! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:20:57' prior: 50743826!
pushSentence: aSentence

	^ sentences push: aSentence! !
!SentenceFinderByPrefix methodsFor: 'nil' stamp: 'dr 9/17/2019 15:23:08'!
topSentence

	^ sentences top.! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:45:47' prior: 50743834!
find: aPrefix

	aPrefix isEmpty ifTrue: [ self error: self class emptyPrefixErrorDescription ]! !

'  ' findString: ' '.!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:47:37' prior: 50743862!
find: aPrefix

	aPrefix isEmpty ifTrue: [ self error: self class emptyPrefixErrorDescription ].
	
	(aPrefix findString: ' ' = 0) ifTrue: [ self error: self class emptySpacesInPrefixErrorDescription ].! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:49:07' prior: 50743870!
find: aPrefix

	aPrefix isEmpty ifTrue: [ self error: self class emptyPrefixErrorDescription ].
	
	(aPrefix findString: ' ' = 0) ifTrue: [ self error: self class emptySpacesInPrefixErrorDescription ].
	
	^ self sentencesAsCollection select: [ :sentence | sentence beginsWith: aPrefix ].! !
!SentenceFinderByPrefix class methodsFor: 'no messages' stamp: 'dr 9/17/2019 15:49:50'!
emptyPrefixErrorDescription

	^ 'The prefix cannot be empty'! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:50:09'!
emptySpacesInPrefixErrorDescription

	^ 'The prefix cannot be empty'! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:50:30' prior: 50743897!
emptySpacesInPrefixErrorDescription

	^ 'The prefix cannot have empty spaces'! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:50:57'!
sentencesAsCollection! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:53:15' prior: 50743909!
sentencesAsCollection

	| sentencesContainer |
	
	sentencesContainer := OrderedCollection new.
	
	sentences isEmpty not whileTrue: [
		sentencesContainer add: sentences pop.
	].! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 15:54:03' prior: 50743914!
sentencesAsCollection

	| sentencesContainer |
	
	sentencesContainer := OrderedCollection new.
	
	sentences isEmpty not whileTrue: [
		sentencesContainer addFirst: sentences pop.
	].! !

| ord |

ord := OrderedCollection new.
ord addFirst: 4; addFirst: 3; addFirst: 2; addFirst: 1.

ord do: [ :elem |  
	elem printString
].!

| ord |

ord := OrderedCollection new.
ord addFirst: 4; addFirst: 3; addFirst: 2; addFirst: 1.
!

ord do: [ :elem |  
	elem printString
]. !

| ord |

ord := OrderedCollection new.
ord addFirst: 4; addFirst: 3; addFirst: 2; addFirst: 1.

ord do: [ :elem |  
	elem printString
]. !

| ord |

ord := OrderedCollection new.
ord addFirst: 4; addFirst: 3; addFirst: 2; addFirst: 1.

ord do: [ :elem |  
	elem printString
]. !

| ord  number |

ord := OrderedCollection new.
ord addFirst: 4; addFirst: 3; addFirst: 2; addFirst: 1.

number := 0.
ord do: [ :elem |  
	number := elem.
].
number.!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 16:00:58' prior: 50743923!
sentencesAsCollection

	| sentencesContainer |
	
	sentencesContainer := OrderedCollection new.
	
	self isEmpty not whileTrue: [
		sentencesContainer addFirst: self popSentence.
	].

	sentencesContainer do: [ :sentence |
		self pushSentence: sentence.
	].

	^ sentencesContainer.! !

| testing |

testing := SentenceFinderByPrefix new.

testing pushSentence: 'esto es una oracion'; pushSentence: 'esto tambien'.

testing find: 'esto'.!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 16:03:38' prior: 50743880!
find: aPrefix

	aPrefix isEmpty ifTrue: [ self error: self class emptyPrefixErrorDescription ].
	
	(aPrefix findString: ' ') = 0 ifTrue: [ self error: self class emptySpacesInPrefixErrorDescription ].
	
	^ self sentencesAsCollection select: [ :sentence | sentence beginsWith: aPrefix ].! !

| testing |

testing := SentenceFinderByPrefix new.

testing pushSentence: 'esto es una oracion'; pushSentence: 'esto tambien'.

testing find: 'esto'.!

'esto' findString: ' '.!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 16:04:47' prior: 50743972!
find: aPrefix

	aPrefix isEmpty ifTrue: [ self error: self class emptyPrefixErrorDescription ].
	
	(aPrefix findString: ' ') ~= 0 ifTrue: [ self error: self class emptySpacesInPrefixErrorDescription ].
	
	^ self sentencesAsCollection select: [ :sentence | sentence beginsWith: aPrefix ].! !

| testing |

testing := SentenceFinderByPrefix new.

testing pushSentence: 'esto es una oracion'; pushSentence: 'esto tambien'.

testing find: 'esto'.
!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 16:05:33' prior: 50743955!
sentencesAsCollection

	| sentencesContainer |
	
	sentencesContainer := OrderedCollection new.
	
	[ self isEmpty not ] whileTrue: [
		sentencesContainer addFirst: self popSentence.
	].

	sentencesContainer do: [ :sentence |
		self pushSentence: sentence.
	].

	^ sentencesContainer.! !

| testing |

testing := SentenceFinderByPrefix new.

testing pushSentence: 'esto es una oracion'; pushSentence: 'esto tambien'.

testing find: 'esto'.!

| testing |

testing := SentenceFinderByPrefix new.

testing pushSentence: 'esto es una oracion'; pushSentence: 'esto tambien'.

testing find: 'esto '.!

| testing |

testing := SentenceFinderByPrefix new.

testing pushSentence: 'esto es una oracion'; pushSentence: 'esto tambien'.

testing find: 'Esto'.!
!SentenceFinderByPrefixTest methodsFor: 'nil' stamp: 'dr 9/17/2019 16:08:00'!
setUp

	| sentenceMayus sentenceMinus anotherSentenceMayus anotherSentenceMinus |
	
	sentenceMayus := SentenceFinderByPrefix new.

	sentenceMayus pushSentence: 'esto es una oracion'; pushSentence: 'esto tambien'.
! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'dr 9/17/2019 16:09:24' prior: 50744034!
setUp

	| sentencesMayus sentencesMinus sentenceMayus anotherSentenceMinus |
	
	sentenceMayus := SentenceFinderByPrefix new.

	sentenceMayus pushSentence: 'esto es una oracion'; pushSentence: 'esto tambien'.
! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:11:22'!
test01EmptySentencesShouldReturnAnEmptyCollection
	
	| emptySentenceFinder |

	emptySentenceFinder := SentenceFinderByPrefix new.

	self assert: [  ]! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:12:42' prior: 50744055!
test01EmptySentencesShouldReturnAnEmptyCollection
	
	| emptySentenceFinder |

	emptySentenceFinder := SentenceFinderByPrefix new.

	self assert: (emptySentenceFinder find: 'anything') = OrderedCollection new.! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:15:01'!
test02FindingAPrefixNotFoundInSentencesShouldReturnEmptyCollection! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:15:33'!
test02APrefixNotFoundShouldReturnEmptyCollection! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:15:43' prior: 50744078!
test02APrefixNotFoundShouldReturnEmptyCollection

	! !

SentenceFinderByPrefixTest removeSelector: #test02FindingAPrefixNotFoundInSentencesShouldReturnEmptyCollection!
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:18:56' prior: 50744083!
test02APrefixNotFoundShouldReturnEmptyCollection

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'otra oracin en minsculas'.
	self assert: (sentences find: 'cualquiera') = OrderedCollection new.

	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:20:18'!
test03ACaseSensitivePrefixFindsOnlyMatchingCaseSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'otra oracin en minsculas'.
	self assert: (sentences find: 'cualquiera') = OrderedCollection new.

	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:22:23' prior: 50744104!
test03ACaseSensitivePrefixFindsOnlyMatchingCaseSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	self assert: (sentences find: 'Una') = (OrderedCollection new add: 'Una oracin en maysculas').

	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:22:38' prior: 50744117!
test03ACaseSensitivePrefixFindsOnlyMatchingCaseSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	self assert: (sentences find: 'Un') = (OrderedCollection new add: 'Una oracin en maysculas').

	! !

sentences find: 'Un'!

OrderedCollection new add: 'Una oracin en maysculas'!

OrderedCollection new add: 'Una oracin en maysculas'!

OrderedCollection new add: 'Una oracin en maysculas'!

OrderedCollection new add: 'Una oracin en maysculas'!

OrderedCollection new add: 'Una oracin en maysculas'!

(sentences find: 'Un') = (OrderedCollection new add: 'Una oracin en maysculas')!

(sentences find: 'Un').!

(OrderedCollection new add: 'Una oracin en maysculas').!
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:29:59' prior: 50744130!
test03ACaseSensitivePrefixFindsOnlyMatchingCaseSentences

	| sentences collectionWithCorrectSentence |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	collectionWithCorrectSentence := OrderedCollection new.
	collectionWithCorrectSentence add: 'Una oracin en maysculas'.
	
	self assert: (sentences find: 'Un') = collectionWithCorrectSentence.

	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:32:01'!
test04FindSearchsPrefixAndNotSubstring

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	
	self assert: (sentences find: 'oracin') = OrderedCollection new.

	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:36:04'!
test05FindDoesNotChangeTheAmountOrOrderOfSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	
	self assert: (sentences find: 'oracin') = OrderedCollection new.

	! !
!SentenceFinderByPrefix methodsFor: 'nil' stamp: 'dr 9/17/2019 16:36:32'!
amountOfSentences
	
	^ sentences size! !

----SNAPSHOT----(17 September 2019 16:38:14) clase2.image priorSource: 13188902!
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:38:31'!
test05FindDoesNotChangeTheAmountOfSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	sentences find: 'oracin'; find: 'una'; find: 'ESTO'.

	self assert: sentences

	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:39:10' prior: 50744205!
test05FindDoesNotChangeTheAmountOfSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	sentences find: 'oracin'; find: 'una'; find: 'ESTO'.

	self assert: sentences amountOfSentences = 2.

	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:39:16' prior: 50744217!
test05FindDoesNotChangeTheAmountOfSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	sentences find: 'oracin'; find: 'una'; find: 'ESTO'.

	self assert: sentences amountOfSentences = 2.
! !

SentenceFinderByPrefixTest removeSelector: #test05FindDoesNotChangeTheAmountOrOrderOfSentences!
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:40:13'!
test05FindDoesNotChangeTheOrderOfSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	sentences find: 'oracin'; find: 'una'; find: 'ESTO'.

	self assert: sentences amountOfSentences = 2.
! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:41:13' prior: 50744246!
test05FindDoesNotChangeTheOrderOfSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	sentences find: 'oracin'; find: 'una'; find: 'ESTO'.

	self assert: sentences pop = 'Una oracin en maysculas'.
	self assert: sentences pop = 'Una oracin en maysculas'.! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:41:28' prior: 50744259!
test05FindDoesNotChangeTheOrderOfSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	sentences find: 'oracin'; find: 'una'; find: 'ESTO'.

	self assert: sentences pop = 'Una oracin en maysculas'.
	self assert: sentences pop = 'una oracin en minsculas'.! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:42:26' prior: 50744274!
test05FindDoesNotChangeTheOrderOfSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	sentences find: 'oracin'; find: 'una'; find: 'ESTO'.

	self assert: sentences popSentence = 'Una oracin en maysculas'.
	self assert: sentences popSentence = 'una oracin en minsculas'.! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:42:46'!
test06FindDoesNotChangeTheOrderOfSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	sentences find: 'oracin'; find: 'una'; find: 'ESTO'.

	self assert: sentences popSentence = 'Una oracin en maysculas'.
	self assert: sentences popSentence = 'una oracin en minsculas'.! !

SentenceFinderByPrefixTest removeSelector: #test05FindDoesNotChangeTheOrderOfSentences!
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:45:45'!
test07CanNotFindAnEmptyPrefix

	| sentences |
	
	sentences := SentenceFinderByPrefix new.

	self assert: (sentences find: ' ').! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:49:07' prior: 50744322!
test07CanNotFindAnEmptyPrefix

	| sentences |
	
	sentences := SentenceFinderByPrefix new.

	self
	should: [ sentences find: '' ]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError |
		self assert: anError messageText = SentenceFinderByPrefix emptyPrefixErrorDescription ]
! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:50:03'!
test08CanNotFindAPrefixWithEmptySpaces

	| sentences |
	
	sentences := SentenceFinderByPrefix new.

	self
	should: [ sentences find: 'lala lala' ]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError |
		self assert: anError messageText = SentenceFinderByPrefix emptySpacesInPrefixErrorDescription ]
! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:50:16' prior: 50744342!
test08CanNotFindAPrefixWithEmptySpaces

	| sentences |
	
	sentences := SentenceFinderByPrefix new.

	self
	should: [ sentences find: 'melissa siempre tiene razn' ]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError |
		self assert: anError messageText = SentenceFinderByPrefix emptySpacesInPrefixErrorDescription ]
! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:50:28' prior: 50744355!
test08CanNotFindAPrefixWithEmptySpaces

	| sentences |
	
	sentences := SentenceFinderByPrefix new.

	self
	should: [ sentences find: 'la la la lala' ]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError |
		self assert: anError messageText = SentenceFinderByPrefix emptySpacesInPrefixErrorDescription ]
! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:52:11'!
test09ManyMatches

	| sentences |
	
	sentences := SentenceFinderByPrefix new.

	self
	should: [ sentences find: 'la la la lala' ]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError |
		self assert: anError messageText = SentenceFinderByPrefix emptySpacesInPrefixErrorDescription ]
! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 16:59:21'!
test09FindingAPrefixWithManyMatchesReturnAllThoseMatches

	| sentences collectionWithTwoMatches |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'Esto es una oracin'; pushSentence: 'Es muy larga'; pushSentence: 'Esta es una manera de escribir'.
	collectionWithTwoMatches := OrderedCollection new.
	collectionWithTwoMatches add: 'Esto es una oracin'; add: 'Esta es una manera de escribir'.
	
	self assert: (sentences find: 'Est') = collectionWithTwoMatches .! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/17/2019 17:01:14' prior: 50744394!
test09FindingAPrefixWithManyMatchesReturnAllThoseMatches

	| sentences collectionWithTwoMatches |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'Esto es una oracin'; pushSentence: 'Es muy larga'; pushSentence: 'Esta es una manera de escribir'.
	collectionWithTwoMatches := OrderedCollection new.
	collectionWithTwoMatches add: 'Esto es una oracin'; add: 'Esta es una manera de escribir'.
	
	self assert: (sentences find: 'Est') = collectionWithTwoMatches.! !

SentenceFinderByPrefixTest removeSelector: #test09ManyMatches!

SentenceFinderByPrefixTest removeSelector: #setUp!

----SNAPSHOT----(17 September 2019 17:04:48) clase2.image priorSource: 13201640!
!OOStackSlot methodsFor: 'accessing' stamp: 'dr 9/17/2019 17:09:30'!
size
	
	self subclassResponsibility.! !

----SNAPSHOT----(17 September 2019 17:09:54) clase2.image priorSource: 13209079!

----SNAPSHOT----(17 September 2019 18:26:23) clase2.image priorSource: 13209287!

----QUIT----(17 September 2019 18:26:26) clase2.image priorSource: 13209369!

----STARTUP---- (18 September 2019 14:32:22) as /home/mregnier/isw1/linux64/clase2.image!

!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'dr 9/18/2019 14:34:07'!
pop

	^ sentences pop.! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:34:07' prior: 50744008!
sentencesAsCollection

	| sentencesContainer |
	
	sentencesContainer := OrderedCollection new.
	
	[ self isEmpty not ] whileTrue: [
		sentencesContainer addFirst: self pop.
	].

	sentencesContainer do: [ :sentence |
		self pushSentence: sentence.
	].

	^ sentencesContainer.! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:34:07' prior: 50744304!
test06FindDoesNotChangeTheOrderOfSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences pushSentence: 'una oracin en minsculas'; pushSentence: 'Una oracin en maysculas'.
	sentences find: 'oracin'; find: 'una'; find: 'ESTO'.

	self assert: sentences pop = 'Una oracin en maysculas'.
	self assert: sentences pop = 'una oracin en minsculas'.! !

SentenceFinderByPrefix removeSelector: #popSentence!

SentenceFinderByPrefix removeSelector: #pop!
!SentenceFinderByPrefix methodsFor: 'operations' stamp: 'dr 9/18/2019 14:34:47'!
push: aSentence

	^ sentences push: aSentence! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:34:47' prior: 50744457!
sentencesAsCollection

	| sentencesContainer |
	
	sentencesContainer := OrderedCollection new.
	
	[ self isEmpty not ] whileTrue: [
		sentencesContainer addFirst: self pop.
	].

	sentencesContainer do: [ :sentence |
		self push: sentence.
	].

	^ sentencesContainer.! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:34:47' prior: 50744092!
test02APrefixNotFoundShouldReturnEmptyCollection

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences push: 'una oracin en minsculas'; push: 'otra oracin en minsculas'.
	self assert: (sentences find: 'cualquiera') = OrderedCollection new.

	! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:34:47' prior: 50744158!
test03ACaseSensitivePrefixFindsOnlyMatchingCaseSentences

	| sentences collectionWithCorrectSentence |
	
	sentences := SentenceFinderByPrefix new.
	sentences push: 'una oracin en minsculas'; push: 'Una oracin en maysculas'.
	collectionWithCorrectSentence := OrderedCollection new.
	collectionWithCorrectSentence add: 'Una oracin en maysculas'.
	
	self assert: (sentences find: 'Un') = collectionWithCorrectSentence.

	! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:34:47' prior: 50744175!
test04FindSearchsPrefixAndNotSubstring

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences push: 'una oracin en minsculas'; push: 'Una oracin en maysculas'.
	
	self assert: (sentences find: 'oracin') = OrderedCollection new.

	! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:34:47' prior: 50744230!
test05FindDoesNotChangeTheAmountOfSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences push: 'una oracin en minsculas'; push: 'Una oracin en maysculas'.
	sentences find: 'oracin'; find: 'una'; find: 'ESTO'.

	self assert: sentences amountOfSentences = 2.
! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:34:47' prior: 50744413!
test09FindingAPrefixWithManyMatchesReturnAllThoseMatches

	| sentences collectionWithTwoMatches |
	
	sentences := SentenceFinderByPrefix new.
	sentences push: 'Esto es una oracin'; push: 'Es muy larga'; push: 'Esta es una manera de escribir'.
	collectionWithTwoMatches := OrderedCollection new.
	collectionWithTwoMatches add: 'Esto es una oracin'; add: 'Esta es una manera de escribir'.
	
	self assert: (sentences find: 'Est') = collectionWithTwoMatches.! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:34:47' prior: 50744470!
test06FindDoesNotChangeTheOrderOfSentences

	| sentences |
	
	sentences := SentenceFinderByPrefix new.
	sentences push: 'una oracin en minsculas'; push: 'Una oracin en maysculas'.
	sentences find: 'oracin'; find: 'una'; find: 'ESTO'.

	self assert: sentences pop = 'Una oracin en maysculas'.
	self assert: sentences pop = 'una oracin en minsculas'.! !

SentenceFinderByPrefix removeSelector: #pushSentence:!

SentenceFinderByPrefix removeSelector: #push:!
!SentenceFinderByPrefix methodsFor: 'initialization' stamp: 'dr 9/18/2019 14:35:46'!
initializeWith: aStackOfSentences

	sentences := aStackOfSentences .! !

SentenceFinderByPrefix removeSelector: #initialize!
!SentenceFinderByPrefix methodsFor: 'converting' stamp: 'dr 9/18/2019 14:37:12' prior: 50744493!
sentencesAsCollection

	| sentencesContainer |
	
	sentencesContainer := OrderedCollection new.
	
	[ sentences isEmpty not ] whileTrue: [
		sentencesContainer addFirst: sentences pop.
	].

	sentencesContainer do: [ :sentence |
		sentences push: sentence.
	].

	^ sentencesContainer.! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:40:50'!
with: aStackOfSentences

	(aStackOfSentences  isKindOf: OOStack) ifFalse: [ self error: self wrongTypeOfParameterErrorDescription ].
	
	! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:41:23' prior: 50744614!
with: aStackOfSentences

	(aStackOfSentences  isKindOf: OOStack) ifFalse: [ self error: self wrongTypeOfParameterErrorDescription ].
	
	^ self new initializeWith: aStackOfSentences .! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:42:29'!
CollaboratorIsNotAStackErrorDescription

	^ 'The collaborator should be a stack'.! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:42:39' prior: 50744622!
with: aStackOfSentences

	(aStackOfSentences  isKindOf: OOStack) ifFalse: [ self error: self CollaboratorIsNotAStackErrorDescription ].
	
	^ self new initializeWith: aStackOfSentences .! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'dr 9/18/2019 14:42:57'!
collaboratorIsNotAStackErrorDescription

	^ 'The collaborator should be a stack'.! !

SentenceFinderByPrefix class removeSelector: #CollaboratorIsNotAStackErrorDescription!
!SentenceFinderByPrefix class methodsFor: 'instance creation' stamp: 'dr 9/18/2019 14:43:23' prior: 50744638!
with: aStackOfSentences

	(aStackOfSentences  isKindOf: OOStack) ifFalse: [ self error: self collaboratorIsNotAStackErrorDescription ].
	
	^ self new initializeWith: aStackOfSentences .! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 14:44:48' prior: 50744063!
test01EmptySentencesShouldReturnAnEmptyCollection
	
	| emptySentenceFinder |

	emptySentenceFinder := SentenceFinderByPrefix with: OOStack new.

	self assert: (emptySentenceFinder find: 'anything') = OrderedCollection new.! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 14:46:03' prior: 50744505!
test02APrefixNotFoundShouldReturnEmptyCollection

	| stackOfSentences sentences |
	
	stackOfSentences := OOStack new.
	stackOfSentences push: 'una oracin en minsculas'; push: 'otra oracin en minsculas'.
	
	sentences := SentenceFinderByPrefix with: stackOfSentences .
	
	self assert: (sentences find: 'cualquiera') = OrderedCollection new.

	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 14:48:44' prior: 50744517!
test03ACaseSensitivePrefixFindsOnlyMatchingCaseSentences

	| stackOfSentences sentences collectionWithCorrectSentence |
	
	stackOfSentences := OOStack new.
	stackOfSentences push: 'una oracin en minsculas'; push: 'Una oracin en maysculas'.
	
	sentences := SentenceFinderByPrefix new.
	
	collectionWithCorrectSentence := OrderedCollection new.
	collectionWithCorrectSentence add: 'Una oracin en maysculas'.
	
	self assert: (sentences find: 'Un') = collectionWithCorrectSentence.

	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 14:48:53' prior: 50744690!
test03ACaseSensitivePrefixFindsOnlyMatchingCaseSentences

	| stackOfSentences sentences collectionWithCorrectSentence |
	
	stackOfSentences := OOStack new.
	stackOfSentences push: 'una oracin en minsculas'; push: 'Una oracin en maysculas'.
	
	sentences := SentenceFinderByPrefix with: stackOfSentences .
	
	collectionWithCorrectSentence := OrderedCollection new.
	collectionWithCorrectSentence add: 'Una oracin en maysculas'.
	
	self assert: (sentences find: 'Un') = collectionWithCorrectSentence.

	! !
!SentenceFinderByPrefixTest methodsFor: 'setup' stamp: 'dr 9/18/2019 14:54:01'!
setUp

	| stackSameSentenceInMayusAndMinus |
	
	stackSameSentenceInMayusAndMinus := OOStack new.
	stackSameSentenceInMayusAndMinus push: 'una oracin'; push: 'Una oracin'.
	
	! !
!SentenceFinderByPrefixTest methodsFor: 'setup' stamp: 'dr 9/18/2019 14:54:31' prior: 50744728!
setUp

	| stackSameSentenceInMayusAndMinus emptySentenceFinder |
	
	stackSameSentenceInMayusAndMinus := OOStack new.
	stackSameSentenceInMayusAndMinus push: 'una oracin'; push: 'Una oracin'.
	
	emptySentenceFinder := SentenceFinderByPrefix with: OOStack new.
	! !
!SentenceFinderByPrefixTest methodsFor: 'setup' stamp: 'dr 9/18/2019 14:56:15' prior: 50744737!
setUp

	| stackSameSentenceInMayusAndMinus emptySentenceFinder |
	
	emptySentenceFinder := SentenceFinderByPrefix with: OOStack new.
	
	stackSameSentenceInMayusAndMinus := OOStack new.
	stackSameSentenceInMayusAndMinus push: 'una oracin'; push: 'Una oracin'.
	
	
	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 14:57:38' prior: 50744665!
test01EmptySentencesShouldReturnAnEmptyCollection
"
	self assert: (emptySentenceFinder find: 'anything') = OrderedCollection new."! !

TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'setup' stamp: 'dr 9/18/2019 15:00:49' prior: 50744749!
setUp

	| stackSameSentenceInMayusAndMinus emptySentenceFinder sentenceFinderSameSentenceInMinusAndMayus |
	
	emptySentenceFinder := SentenceFinderByPrefix with: OOStack new.
	
	stackSameSentenceInMayusAndMinus := OOStack new.
	stackSameSentenceInMayusAndMinus push: 'una oracin'; push: 'Una oracin'.

	sentenceFinderSameSentenceInMinusAndMayus := SentenceFinderByPrefix with: stackSameSentenceInMayusAndMinus .
	
	! !

TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptySentenceFinder sentenceFinderSameSentenceInMinusAndMayus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'setup' stamp: 'dr 9/18/2019 15:01:42' prior: 50744780!
setUp

	| stackSameSentenceInMayusAndMinus emptySentenceFinderA sentenceFinderSameSentenceInMinusAndMayusA |
	
	emptySentenceFinderA := SentenceFinderByPrefix with: OOStack new.
	
	stackSameSentenceInMayusAndMinus := OOStack new.
	stackSameSentenceInMayusAndMinus push: 'una oracin'; push: 'Una oracin'.

	sentenceFinderSameSentenceInMinusAndMayusA := SentenceFinderByPrefix with: stackSameSentenceInMayusAndMinus .
	
	! !

TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptySentenceFinder sentenceFinderSameSentenceInMinusAndMayus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptySentenceFinder sentenceFinderSameSentenceInMinusAndMayus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'setup' stamp: 'dr 9/18/2019 15:02:26' prior: 50744815!
setUp

	| stackSameSentenceInMayusAndMinus |
	
	emptySentenceFinder := SentenceFinderByPrefix with: OOStack new.
	
	stackSameSentenceInMayusAndMinus := OOStack new.
	stackSameSentenceInMayusAndMinus push: 'una oracin'; push: 'Una oracin'.

	sentenceFinderSameSentenceInMinusAndMayus := SentenceFinderByPrefix with: stackSameSentenceInMayusAndMinus .
	
	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 15:02:46' prior: 50744761!
test01EmptySentencesShouldReturnAnEmptyCollection

	self assert: (emptySentenceFinder find: 'anything') = OrderedCollection new.! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 15:04:41' prior: 50744676!
test02APrefixNotFoundShouldReturnEmptyCollection
	
	self assert: (sentenceFinderSameSentenceInMinusAndMayus find: 'cualquiera') = OrderedCollection new.

	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 15:05:17' prior: 50744709!
test03ACaseSensitivePrefixFindsOnlyMatchingCaseSentences

	| collectionWithCorrectSentence |
	
	collectionWithCorrectSentence := OrderedCollection new.
	collectionWithCorrectSentence add: 'Una oracin'.
	
	self assert: (sentenceFinderSameSentenceInMinusAndMayus find: 'Un') = collectionWithCorrectSentence.

	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 15:05:42' prior: 50744534!
test04FindSearchsPrefixAndNotSubstring

	self assert: (sentenceFinderSameSentenceInMinusAndMayus find: 'oracin') = OrderedCollection new.

	! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 15:06:34' prior: 50744546!
test05FindDoesNotChangeTheAmountOfSentences
	
	sentenceFinderSameSentenceInMinusAndMayus find: 'oracin'; find: 'una'; find: 'ESTO'.

	self assert: sentenceFinderSameSentenceInMinusAndMayus amountOfSentences = 2.
! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 15:10:00' prior: 50744577!
test06FindDoesNotChangeTheOrderOfSentences

	| collectionWithSentences |
	sentenceFinderSameSentenceInMinusAndMayus find: 'oracin'; find: 'una'; find: 'ESTO'.

	collectionWithSentences := OrderedCollection new.
	collectionWithSentences add: 'Una oracin'; add: 'una oracin'.

	self assert: sentenceFinderSameSentenceInMinusAndMayus sentencesAsCollection = collectionWithSentences.! !

sentenceFinderSameSentenceInMinusAndMayus  sentencesAsCollection!
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 15:12:59' prior: 50744909!
test06FindDoesNotChangeTheOrderOfSentences

	| collectionWithSentences |
	sentenceFinderSameSentenceInMinusAndMayus find: 'oracin'; find: 'una'; find: 'ESTO'.

	collectionWithSentences := OrderedCollection new.
	collectionWithSentences add: 'una oracin'; add: 'Una oracin'.

	self assert: sentenceFinderSameSentenceInMinusAndMayus sentencesAsCollection = collectionWithSentences.! !
!SentenceFinderByPrefix methodsFor: 'converting' stamp: 'dr 9/18/2019 15:14:03' prior: 50744602!
sentencesAsCollection
	"returns the stack of sentences starting with the oldest sentence and finishing with the top sentence"
	| sentencesContainer |
	
	sentencesContainer := OrderedCollection new.
	
	[ sentences isEmpty not ] whileTrue: [
		sentencesContainer addFirst: sentences pop.
	].

	sentencesContainer do: [ :sentence |
		sentences push: sentence.
	].

	^ sentencesContainer.! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 15:16:10' prior: 50744330!
test07CanNotFindAnEmptyPrefix

	self
	should: [ emptySentenceFinder find: '' ]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError |
		self assert: anError messageText = SentenceFinderByPrefix emptyPrefixErrorDescription ]
! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 15:16:41' prior: 50744369!
test08CanNotFindAPrefixWithEmptySpaces

	self
	should: [ emptySentenceFinder find: 'la la la lala' ]
	raise: Error - MessageNotUnderstood 
	withExceptionDo: [ :anError |
		self assert: anError messageText = SentenceFinderByPrefix emptySpacesInPrefixErrorDescription ]
! !
!SentenceFinderByPrefixTest methodsFor: 'setup' stamp: 'dr 9/18/2019 15:19:42' prior: 50744847!
setUp

	| stackSameSentenceInMayusAndMinus stackWithTwoSentencesWithSamePrefix |
	
	emptySentenceFinder := SentenceFinderByPrefix with: OOStack new.
	
	stackSameSentenceInMayusAndMinus := OOStack new.
	stackSameSentenceInMayusAndMinus push: 'una oracin'; push: 'Una oracin'.

	sentenceFinderSameSentenceInMinusAndMayus := SentenceFinderByPrefix with: stackSameSentenceInMayusAndMinus .
	
	stackWithTwoSentencesWithSamePrefix := OOStack new.
	stackWithTwoSentencesWithSamePrefix push: 'Esta es una oracin'; push: 'Esto podra decirlo'.
	
	"sentenceFinderWithTwoSentencesStartingWithEst := SentenceFinderByPrefix with: stackWithTwoSentencesWithSamePrefix"! !

TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptySentenceFinder sentenceFinderSameSentenceInMinusAndMayus sentenceFinderWithTwoSentencesStartingWithEst'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'emptySentenceFinder sentenceFinderSameSentenceInMinusAndMayus sentenceFinderWithTwoSentencesStartingWithEst'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'setup' stamp: 'dr 9/18/2019 15:20:15' prior: 50744982!
setUp

	| stackSameSentenceInMayusAndMinus stackWithTwoSentencesWithSamePrefix |
	
	emptySentenceFinder := SentenceFinderByPrefix with: OOStack new.
	
	stackSameSentenceInMayusAndMinus := OOStack new.
	stackSameSentenceInMayusAndMinus push: 'una oracin'; push: 'Una oracin'.

	sentenceFinderSameSentenceInMinusAndMayus := SentenceFinderByPrefix with: stackSameSentenceInMayusAndMinus .
	
	stackWithTwoSentencesWithSamePrefix := OOStack new.
	stackWithTwoSentencesWithSamePrefix push: 'Esta es una oracin'; push: 'Esto podra decirlo'.
	
	sentenceFinderWithTwoSentencesStartingWithEst := SentenceFinderByPrefix with: stackWithTwoSentencesWithSamePrefix.! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 15:21:10' prior: 50744559!
test09FindingAPrefixWithManyMatchesReturnAllThoseMatches

	| collectionWithTwoMatches |
	
	collectionWithTwoMatches := OrderedCollection new.
	collectionWithTwoMatches add: 'Esta es una oracin'; add: 'Esto podra decirlo'.
	
	self assert: (sentenceFinderWithTwoSentencesStartingWithEst find: 'Est') = collectionWithTwoMatches.! !
!SentenceFinderByPrefixTest methodsFor: 'test' stamp: 'dr 9/18/2019 15:21:21'!
test09FindingAPrefixWithMultipleMatchesReturnAllThoseMatches

	| collectionWithTwoMatches |
	
	collectionWithTwoMatches := OrderedCollection new.
	collectionWithTwoMatches add: 'Esta es una oracin'; add: 'Esto podra decirlo'.
	
	self assert: (sentenceFinderWithTwoSentencesStartingWithEst find: 'Est') = collectionWithTwoMatches.! !

SentenceFinderByPrefixTest removeSelector: #test09FindingAPrefixWithManyMatchesReturnAllThoseMatches!

----SNAPSHOT----(18 September 2019 15:21:47) clase2.image priorSource: 13209451!

----SNAPSHOT----(18 September 2019 15:24:24) clase2.image priorSource: 13229685!

----QUIT----(18 September 2019 15:28:02) clase2.image priorSource: 13229767!

----STARTUP---- (26 September 2019 19:24:59) as /home/mregnier/isw1/linux64/clase2.image!


TestCase subclass: #TestXYZ
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'XX'!

!classDefinition: #TestXYZ category: #XX!
TestCase subclass: #TestXYZ
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'XX'!

!classDefinition: #HolidayCalendar category: #XX!
Object subclass: #HolidayCalendar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'XX'!
!TestXYZ methodsFor: 'no messages' stamp: 'dr 9/26/2019 19:32:25'!
test01

	| aSunday holidayCalendar |
	holidayCalendar := HolidayCalendar new.
	aSunday := September/29/2019.
	
	self assert: (holidayCalendar isHoliday: aSunday)! !
!HolidayCalendar methodsFor: 'no messages' stamp: 'dr 9/26/2019 19:33:37'!
isHoliday

	^ true.! !
!HolidayCalendar methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:34:22'!
isHoliday: aFixedGregorianDate

	^ true.! !

HolidayCalendar removeSelector: #isHoliday!
!HolidayCalendar methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:37:21' prior: 50745115!
isHoliday: aDate

	^ true.! !
!HolidayCalendar methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:43:17' prior: 50745121!
isHoliday: aDate

	^ aDate = Sunday.! !
!TestXYZ methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:45:25'!
test02

	| aMonday holidayCalendar |
	
	holidayCalendar:= HolidayCalendar new.
	aMonday := September/30/2019.
	
	self deny: (holidayCalendar isHoliday: aMonday).! !
!TestXYZ methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:47:51'!
test03

	| aSunday holidayCalendar |
	holidayCalendar := HolidayCalendar new.
	aSunday := September/29/2019.
	
	self assert: (holidayCalendar isHoliday: aSunday)! !
!TestXYZ methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:48:16' prior: 50745138!
test03

	| aSaturday holidayCalendar |
	holidayCalendar := HolidayCalendar new.
	aSaturday := September/29/2019.
	
	self assert: (holidayCalendar isHoliday: aSaturday)! !

!classDefinition: #HolidayCalendar category: #XX!
Object subclass: #HolidayCalendar
	instanceVariableNames: 'dayOfWeekHoliday'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'XX'!
!HolidayCalendar methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:51:11' prior: 50745126!
isHoliday: aDate

	^ aDate = dayOfWeekHoliday.! !
!TestXYZ methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:54:55' prior: 50745146!
test03

	| aSaturday holidayCalendar |
	holidayCalendar := HolidayCalendar new.
	aSaturday := September/29/2019.
	holidayCalendar markDayOfWeekAsHoliday.
	
	self assert: (holidayCalendar isHoliday: aSaturday)! !
!TestXYZ methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:55:08' prior: 50745166!
test03

	| aSaturday holidayCalendar |
	holidayCalendar := HolidayCalendar new.
	aSaturday := September/29/2019.
	holidayCalendar markDayOfWeekAsHoliday: Sunday.
	
	self assert: (holidayCalendar isHoliday: aSaturday)! !
!TestXYZ methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:55:16' prior: 50745176!
test03

	| aSaturday holidayCalendar |
	holidayCalendar := HolidayCalendar new.
	aSaturday := September/29/2019.
	holidayCalendar markDayOfWeekAsHoliday: Saturday.
	
	self assert: (holidayCalendar isHoliday: aSaturday)! !
!TestXYZ methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:55:36' prior: 50745103!
test01

	| aSunday holidayCalendar |
	holidayCalendar := HolidayCalendar new.
	aSunday := September/29/2019.
	holidayCalendar markDayOfWeekAsHoliday: Sunday.
	
	self assert: (holidayCalendar isHoliday: aSunday)! !
!HolidayCalendar methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:56:57'!
markDayOfTheWeekAsHoliday: aDayOfWeek

	! !
!HolidayCalendar methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:57:15' prior: 50745206!
markDayOfTheWeekAsHoliday: aDayOfWeek
	
	dayOfWeekHoliday  := aDayOfWeek .! !
!HolidayCalendar methodsFor: 'as yet unclassified' stamp: 'dr 9/26/2019 19:57:41'!
markDayOfWeekAsHoliday: aDayOfWeek
	
	dayOfWeekHoliday  := aDayOfWeek .! !

HolidayCalendar removeSelector: #markDayOfTheWeekAsHoliday:!

----STARTUP---- (3 October 2019 20:10:13) as /home/mregnier/isw1/linux64/clase2.image!


Object subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRoverTest category: #MarsRover!
Object subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRoverTest category: #MarsRover!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

1@1!

!classDefinition: #MarsRover category: #MarsRover!
Object subclass: #MarsRover
	instanceVariableNames: 'position orientation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRoverTest methodsFor: 'no messages' stamp: 'dr 10/3/2019 20:17:40'!
test01NewMarsRoverBeginsAtPosition

	self assert: ((MarsRover at: 1@1 orientedAt: #North) position = 1@1).! !
!MarsRover class methodsFor: 'instance initialization' stamp: 'dr 10/3/2019 20:18:28'!
at: aPoint orientedAt: aSymbol 
	self shouldBeImplemented.! !
!MarsRover class methodsFor: 'instance initialization' stamp: 'dr 10/3/2019 20:19:30' prior: 50745122!
at: aPoint orientedAt: anOrientation 
	
	^ self new initializeAt: aPoint orientedAt: anOrientation.! !
!MarsRover methodsFor: 'initialization' stamp: 'dr 10/3/2019 20:20:03'!
initializeAt: aPoint orientedAt: aSymbol 
	self shouldBeImplemented.! !
!MarsRover methodsFor: 'initialization' stamp: 'dr 10/3/2019 20:21:04' prior: 50745134!
initializeAt: aPoint orientedAt: anOrientation
	
	position := aPoint.
	orientation := anOrientation.! !
!MarsRover methodsFor: 'nil' stamp: 'dr 10/3/2019 20:21:58'!
position

	^ 1@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'dr 10/3/2019 20:22:49' prior: 50745115!
test01NewMarsRoverBeginsAtPosition

	self assert: ((MarsRover at: 1@1 orientedAt: #North) position = (1@1)).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'dr 10/3/2019 20:23:38'!
test02NewMarsRoverBeginsAtOrientation

	self assert: ((MarsRover at: 1@1 orientedAt: #North) orientation = #North).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'dr 10/3/2019 20:25:05'!
test03MarsRoverMovesForwardInDirection

	self assert: ((MarsRover at: 1@1 orientedAt: #North) orientation = #North).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'dr 10/3/2019 20:25:59'!
test01NewMarsRoverBeginsAtAPosition

	self assert: ((MarsRover at: 1@1 orientedAt: #North) position = (1@1)).! !

MarsRoverTest removeSelector: #test01NewMarsRoverBeginsAtPosition!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'dr 10/3/2019 20:26:25'!
test02NewMarsRoverBeginsAtAnOrientation

	self assert: ((MarsRover at: 1@1 orientedAt: #North) orientation = #North).! !

MarsRoverTest removeSelector: #test02NewMarsRoverBeginsAtOrientation!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'dr 10/3/2019 20:30:21' prior: 50745163!
test03MarsRoverMovesForwardInDirection
	
	| marsRover |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	marsRover move: 'f'.

	self assert: ( marsRover position = (1@2)).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'dr 10/3/2019 20:37:08'!
test03MarsRoverMovesForwardHasOn
	
	| marsRover |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	marsRover move: 'f'.

	self assert: marsRover position equals: 1@2.! !

MarsRoverTest removeSelector: #test03MarsRoverMovesForwardHasOn!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'dr 10/3/2019 20:37:35' prior: 50745189!
test03MarsRoverMovesForwardInDirection
	
	| marsRover |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	marsRover move: 'f'.

	self assert: marsRover position equals: 1@2.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'dr 10/3/2019 20:38:26' prior: 50745179!
test02NewMarsRoverBeginsAtAnOrientation

	self assert: (MarsRover at: 1@1 orientedAt: #North) orientation equals: #North.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'dr 10/3/2019 20:43:30'!
test01EmptyInstructionDoesNotMove

	self assert: ((MarsRover at: 1@1 orientedAt: #North) position = (1@1)).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'dr 10/3/2019 20:44:43' prior: 50745225!
test01EmptyInstructionDoesNotMove

	| marsRover |
	
	marsRover := MarsRover at: 1@1 orientedAt: #North.
	marsRover instructionMove: ''.
	
	self assert: marsRover position equals: 1@1.! !

MarsRoverTest removeSelector: #test01NewMarsRoverBeginsAtAPosition!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'dr 10/3/2019 20:48:11' prior: 50745232!
test01EmptyInstructionDoesNotMove

	| marsRover |
	
	marsRover := MarsRover at: 1@1 orientedAt: #North.
	marsRover instructionMove: ''.
	
	self assert: marsRover position equals: 1@1.
	self assert: marsRover orientation equals: #North.! !

----SNAPSHOT----(3 October 2019 20:59:17) clase2.image priorSource: 13229849!

----QUIT----(3 October 2019 20:59:21) clase2.image priorSource: 13235310!

----STARTUP---- (6 October 2019 10:43:05) as /home/melissa/Mel/college shit/Ingeniera de Software I/isw1/linux64/clase2.image!

!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:44:23' prior: 50745244!
test01EmptyInstructionDoesNotMove

	| marsRover |
	
	marsRover := MarsRover at: 1@1 orientedAt: #North.
	marsRover instructionMove: ''.
	
	self assert: marsRover position equals: 1@1.! !

MarsRoverTest removeSelector: #test02NewMarsRoverBeginsAtAnOrientation!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:47:59'!
test02MarsRoverMovesForward
	
	| marsRover |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	marsRover move: 'f'.

	self assert: marsRover position equals: 1@2.! !

MarsRoverTest removeSelector: #test03MarsRoverMovesForwardInDirection!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:48:44' prior: 50745264!
test01EmptyInstructionDoesNotMove

	| marsRover |
	
	marsRover := MarsRover at: 1@1 orientedAt: #North.
	marsRover move: ''.
	
	self assert: marsRover position equals: 1@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:49:03' prior: 50745286!
test01EmptyInstructionDoesNotMove

	| marsRover |
	
	marsRover := MarsRover at: 1@1 orientedAt: #North.

	marsRover move: ''.
	
	self assert: marsRover position equals: 1@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:50:54' prior: 50745295!
test01EmptyInstructionDoesNotMove

	| marsRover newPosition |
	
	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: ''.
	
	self assert: newPosition equals: 1@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:51:26' prior: 50745275!
test02MarsRoverMovesForward
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'f'.

	self assert: newPosition equals: 1@2.! !
!MarsRover methodsFor: 'nil' stamp: 'mr 10/6/2019 10:51:59'!
move: anInstructionString

	! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:52:15' prior: 50745322!
move: anInstructionString

	^ 1@2! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:52:19' prior: 50745326!
move: anInstructionString

	^ 1@1! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:53:27' prior: 50745331!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ]
	^ 1@1! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:55:11' prior: 50745336!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].
	^ 1@1! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:57:45' prior: 50745342!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].
	^ position + 0@1.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:57:54' prior: 50745348!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	^ position + 0@1.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:58:24' prior: 50745355!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	^ position + (0@1).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 10:59:29'!
test03MarsRoverMovesBackward
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'b'.

	self assert: newPosition equals: 1@0.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:02:15' prior: 50745362!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ position + (0@1)].
	
	^ position + (0@-1).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:04:16'!
test04MarsRoverMovesForwardTwice
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'ff'.

	self assert: newPosition equals: 1@3.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:05:08' prior: 50745377!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ position + (0@1)].

	anInstructionString = 'f' ifTrue: [^ position + (0@2)].
		
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:05:12' prior: 50745395!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ position + (0@1)].

	anInstructionString = 'ff' ifTrue: [^ position + (0@2)].
		
	^ position + (0@-1).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:06:13'!
test05MarsRoverMovesBackwardTwice
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'bb'.

	self assert: newPosition equals: 1@-1.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:06:58' prior: 50745405!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ position + (0@1)].

	anInstructionString = 'ff' ifTrue: [^ position + (0@2)].

	anInstructionString = 'bb' ifTrue: [^ position + (0@-2)].
		
	^ position + (0@-1).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:07:45'!
test06MarsRoverMovesForwardThreeTimes
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'fff'.

	self assert: newPosition equals: 1@4.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:08:09' prior: 50745425!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ position + (0@1)].

	anInstructionString = 'ff' ifTrue: [^ position + (0@2)].

	anInstructionString = 'fff' ifTrue: [^ position + (0@2)].

	anInstructionString = 'bb' ifTrue: [^ position + (0@-2)].
		
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:08:13' prior: 50745447!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ position + (0@1)].

	anInstructionString = 'ff' ifTrue: [^ position + (0@2)].

	anInstructionString = 'fff' ifTrue: [^ position + (0@3)].

	anInstructionString = 'bb' ifTrue: [^ position + (0@-2)].
		
	^ position + (0@-1).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:08:51'!
test07MarsRoverMovesBackwardThreeTimes
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'bbb'.

	self assert: newPosition equals: 1@-2.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:09:29' prior: 50745461!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ position + (0@1)].

	anInstructionString = 'ff' ifTrue: [^ position + (0@2)].

	anInstructionString = 'fff' ifTrue: [^ position + (0@3)].

	anInstructionString = 'bb' ifTrue: [^ position + (0@-2)].

	anInstructionString = 'bbb' ifTrue: [^ position + (0@-2)].
		
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:09:33' prior: 50745485!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ position + (0@1)].

	anInstructionString = 'ff' ifTrue: [^ position + (0@2)].

	anInstructionString = 'fff' ifTrue: [^ position + (0@3)].

	anInstructionString = 'bb' ifTrue: [^ position + (0@-2)].

	anInstructionString = 'bbb' ifTrue: [^ position + (0@-3)].
		
	^ position + (0@-1).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:11:02'!
test06MarsRoverMovesForwardFourTimes
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'ffff'.

	self assert: newPosition equals: 1@5.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:11:22'!
test08MarsRoverMovesForwardFourTimes
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'ffff'.

	self assert: newPosition equals: 1@5.! !

MarsRoverTest removeSelector: #test06MarsRoverMovesForwardFourTimes!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:11:56' prior: 50745501!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ position + (0@1)].

	anInstructionString = 'ff' ifTrue: [^ position + (0@2)].

	anInstructionString = 'fff' ifTrue: [^ position + (0@3)].

	anInstructionString = 'fff' ifTrue: [^ position + (0@4)].

	anInstructionString = 'bb' ifTrue: [^ position + (0@-2)].

	anInstructionString = 'bbb' ifTrue: [^ position + (0@-3)].
		
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:12:00' prior: 50745538!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ position + (0@1)].

	anInstructionString = 'ff' ifTrue: [^ position + (0@2)].

	anInstructionString = 'fff' ifTrue: [^ position + (0@3)].

	anInstructionString = 'ffff' ifTrue: [^ position + (0@4)].

	anInstructionString = 'bb' ifTrue: [^ position + (0@-2)].

	anInstructionString = 'bbb' ifTrue: [^ position + (0@-3)].
		
	^ position + (0@-1).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:12:54'!
test09MarsRoverMovesBackwardFourTimes
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'bbbb'.

	self assert: newPosition equals: 1@-3.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:13:24' prior: 50745556!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ position + (0@1)].

	anInstructionString = 'ff' ifTrue: [^ position + (0@2)].

	anInstructionString = 'fff' ifTrue: [^ position + (0@3)].

	anInstructionString = 'ffff' ifTrue: [^ position + (0@4)].

	anInstructionString = 'bb' ifTrue: [^ position + (0@-2)].

	anInstructionString = 'bbb' ifTrue: [^ position + (0@-3)].
	
	anInstructionString = 'bbbb' ifTrue: [^ position + (0@-4)].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:16:23'!
increaseYtimes: aNumberOfTimes

	^ position + (0@(aNumberOfTimes)).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:17:35' prior: 50745584!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ self increaseYTimes: 1].

	anInstructionString = 'ff' ifTrue: [^ self increaseYTimes: 1].

	anInstructionString = 'fff' ifTrue: [^ position + (0@3)].

	anInstructionString = 'ffff' ifTrue: [^ position + (0@4)].

	anInstructionString = 'bb' ifTrue: [^ position + (0@-2)].

	anInstructionString = 'bbb' ifTrue: [^ position + (0@-3)].
	
	anInstructionString = 'bbbb' ifTrue: [^ position + (0@-4)].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:17:46'!
increaseYTimes: aNumberOfTimes

	^ position + (0@(aNumberOfTimes)).! !

MarsRover removeSelector: #increaseYtimes:!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:18:23' prior: 50745609!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ self increaseYTimes: 1].

	anInstructionString = 'ff' ifTrue: [^ self increaseYTimes: 2].

	anInstructionString = 'fff' ifTrue: [^ self increaseYTimes: 3].

	anInstructionString = 'ffff' ifTrue: [^ self increaseYTimes: 4].

	anInstructionString = 'bb' ifTrue: [^ position + (0@-2)].

	anInstructionString = 'bbb' ifTrue: [^ position + (0@-3)].
	
	anInstructionString = 'bbbb' ifTrue: [^ position + (0@-4)].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:19:25'!
decreaseYTimes: aNumberOfTimes

	^ position + (0@(-1 * aNumberOfTimes)).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:20:30' prior: 50745636!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ self increaseYTimes: 1].

	anInstructionString = 'ff' ifTrue: [^ self increaseYTimes: 2].

	anInstructionString = 'fff' ifTrue: [^ self increaseYTimes: 3].

	anInstructionString = 'ffff' ifTrue: [^ self increaseYTimes: 4].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:22:18' prior: 50745662!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'f' ifTrue: [^ self increaseYTimes: 1].

	anInstructionString = 'ff' ifTrue: [^ self increaseYTimes: 2].

	anInstructionString = 'fff' ifTrue: [^ self increaseYTimes: 3].

	anInstructionString = 'ffff' ifTrue: [^ self increaseYTimes: 4].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:30:48' prior: 50745683!
move: anInstructionString

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString inject: 0 into: [ :sum :elem | elem = 'f' ifTrue: [ sum + elem ]].
	
	anInstructionString = 'f' ifTrue: [^ self increaseYTimes: 1].

	anInstructionString = 'ff' ifTrue: [^ self increaseYTimes: 2].

	anInstructionString = 'fff' ifTrue: [^ self increaseYTimes: 3].

	anInstructionString = 'ffff' ifTrue: [^ self increaseYTimes: 4].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:31:08' prior: 50745704!
move: anInstructionString

	| amountOfForwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards = anInstructionString inject: 0 into: [ :sum :elem | elem = 'f' ifTrue: [ sum + elem ]].
	
	anInstructionString = 'f' ifTrue: [^ self increaseYTimes: 1].

	anInstructionString = 'ff' ifTrue: [^ self increaseYTimes: 2].

	anInstructionString = 'fff' ifTrue: [^ self increaseYTimes: 3].

	anInstructionString = 'ffff' ifTrue: [^ self increaseYTimes: 4].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:34:25' prior: 50745728!
move: anInstructionString

	| amountOfForwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards = anInstructionString inject: 0 into: [ :sum :elem | elem = 'f' ifTrue: [ sum + elem ]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].
	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:34:41' prior: 50745753!
move: anInstructionString

	| amountOfForwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = 'f' ifTrue: [ sum + elem ]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].
	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:34:49' prior: 50745772!
move: anInstructionString

	| amountOfForwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = 'f' ifTrue: [ sum + elem ]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:42:10' prior: 50745791!
move: anInstructionString

	| amountOfForwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = 'f' ifTrue: [ sum + elem ] ifFalse: [sum]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:46:42' prior: 50745811!
move: anInstructionString

	| amountOfForwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + elem ] ifFalse: [sum]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:46:55' prior: 50745831!
move: anInstructionString

	| amountOfForwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + elem ] ifFalse: [sum]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:49:33' prior: 50745851!
move: anInstructionString

	| amountOfForwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [sum]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:49:54' prior: 50745871!
move: anInstructionString

	| amountOfForwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:50:29' prior: 50745891!
move: anInstructionString

	| amountOfForwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:50:48' prior: 50745910!
move: anInstructionString

	| amountOfForwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = 'f' ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:50:59' prior: 50745930!
move: anInstructionString

	| amountOfForwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].

	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:51:53' prior: 50745950!
move: anInstructionString

	| amountOfForwards amountOfBackwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	amountOfBackwards = 0 ifFalse: [ ^ self decreaseYTimes: amountOfBackwards ].


	anInstructionString = 'bb' ifTrue: [^ self decreaseYTimes: 2].

	anInstructionString = 'bbb' ifTrue: [^ self decreaseYTimes: 3].
	
	anInstructionString = 'bbbb' ifTrue: [^ self decreaseYTimes: 4].
	
	^ position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:52:12' prior: 50745970!
move: anInstructionString

	| amountOfForwards amountOfBackwards |
	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	amountOfBackwards = 0 ifFalse: [ ^ self decreaseYTimes: amountOfBackwards ].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:52:18' prior: 50745997!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	amountOfForwards = 0 ifFalse: [ ^ self increaseYTimes: amountOfForwards ].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	amountOfBackwards = 0 ifFalse: [ ^ self decreaseYTimes: amountOfBackwards ].! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:53:44'!
test10MarsRoverMovesForwardAndBackward
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'fb'.

	self assert: newPosition equals: 1@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:54:09'!
test10MarsRoverMovesForwardOnceAndBackwardOnce
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'fb'.

	self assert: newPosition equals: 1@1.! !

MarsRoverTest removeSelector: #test10MarsRoverMovesForwardAndBackward!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:55:56' prior: 50746017!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self increaseYTimes:  amountOfForwards)  + (self decreaseYTimes: amountOfBackwards).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:57:00' prior: 50746058!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self increaseYTimes:  amountOfForwards)  + (self decreaseYTimes: amountOfBackwards) - position.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:59:34' prior: 50746076!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 11:59:45'!
moveYTimes: aNumberOfTimes

	^ position + (0@(aNumberOfTimes)).! !

MarsRover removeSelector: #increaseYTimes:!

MarsRover removeSelector: #decreaseYTimes:!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:02:13'!
test11MarsRoverMovesForwardOnceAndThenForwardAgainIsInCorrectPosition
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'f'.
	
	newPosition := marsRover move: 'f'.

	self assert: newPosition equals: 1@3.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:05:37' prior: 50746110!
moveYTimes: aNumberOfTimes

	^ position := position + (0@(aNumberOfTimes)).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:11:00'!
test12MarsRoverRotateLeftAndMoveForwardMovesToTheLeftOnce
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'lf'.

	self assert: newPosition equals: 2@1.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:13:33' prior: 50746094!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ self moveXTimes: 1 ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:14:07'!
moveXTimes: aNumberOfTimes

	^ position := position + (aNumberOfTimes@0).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:14:18' prior: 50746130!
moveYTimes: aNumberOfTimes

	^ position := position + (0@aNumberOfTimes).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:14:48' prior: 50746145!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: 1 ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:18:34'!
test12MarsRoverRotateRightAndMoveForwardMovesToTheRightOnce
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'rf'.

	self assert: newPosition equals: 2@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:18:40'!
test13MarsRoverRotateRightAndMoveForwardMovesToTheRightOnce
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'rf'.

	self assert: newPosition equals: 2@1.! !

MarsRoverTest removeSelector: #test12MarsRoverRotateRightAndMoveForwardMovesToTheRightOnce!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:18:54' prior: 50746135!
test12MarsRoverRotateLeftAndMoveForwardMovesToTheLeftOnce
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: #North.

	newPosition := marsRover move: 'lf'.

	self assert: newPosition equals: 0@1.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:19:06' prior: 50746175!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:19:31' prior: 50746227!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].	

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:30:32'!
obtainPositionOfMarsRoverStartedAt: aPoint inOrientation: anOrientation andMoved: aSequenceOfMovements 
	
	| marsRover newPosition |

	marsRover := MarsRover at: aPoint orientedAt: anOrientation .

  	^ newPosition := marsRover move: aSequenceOfMovements .! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:30:53' prior: 50746267!
obtainPositionOfMarsRoverStartedAt: aPoint inOrientation: anOrientation andMoved: aSequenceOfMovements 
	
	| marsRover |

	marsRover := MarsRover at: aPoint orientedAt: anOrientation .

  	^ marsRover move: aSequenceOfMovements .! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:32:01' prior: 50745304!
test01EmptyInstructionDoesNotMove

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: '') equals: 1@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:32:46' prior: 50745314!
test02MarsRoverMovesForward

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'f') equals: 1@2.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:33:07' prior: 50745368!
test03MarsRoverMovesBackward

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'b') equals: 1@0.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:33:21' prior: 50745385!
test04MarsRoverMovesForwardTwice

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'ff') equals: 1@3.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:33:36' prior: 50745415!
test05MarsRoverMovesBackwardTwice
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'bb') equals: 1@-1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:33:51' prior: 50745437!
test06MarsRoverMovesForwardThreeTimes

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'fff')equals: 1@4.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:34:03' prior: 50745475!
test07MarsRoverMovesBackwardThreeTimes

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'bbb') equals: 1@-2.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:34:24' prior: 50745526!
test08MarsRoverMovesForwardFourTimes
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'ffff') equals: 1@5.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:34:46' prior: 50745574!
test09MarsRoverMovesBackwardFourTimes
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'bbbb') equals: 1@-3.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:35:04' prior: 50746046!
test10MarsRoverMovesForwardOnceAndBackwardOnce
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'fb') equals: 1@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:35:33' prior: 50746217!
test12MarsRoverRotateLeftAndMoveForwardMovesToTheLeftOnce
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: '') equals: 0@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:35:43' prior: 50746371!
test12MarsRoverRotateLeftAndMoveForwardMovesToTheLeftOnce
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'lf') equals: 0@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:35:57' prior: 50746204!
test13MarsRoverRotateRightAndMoveForwardMovesToTheRightOnce
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'rf') equals: 2@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:37:41'!
test12MarsRoverRotateLeftAndMoveBackwardMovesToTheLeftOnce

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'lb') equals: 2@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:37:50'!
test14MarsRoverRotateLeftAndMoveBackwardMovesToTheLeftOnce

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'lb') equals: 2@1.! !

MarsRoverTest removeSelector: #test12MarsRoverRotateLeftAndMoveBackwardMovesToTheLeftOnce!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:38:31'!
test13MarsRoverRotateRightAndMoveBackwardMovesToTheRightOnce
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'rb') equals: 0@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:39:53'!
test15MarsRoverRotateRightAndMoveBackwardMovesToTheRightOnce
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'rb') equals: 0@1.! !

MarsRoverTest removeSelector: #test13MarsRoverRotateRightAndMoveBackwardMovesToTheRightOnce!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:41:04' prior: 50746246!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].	
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].	
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:44:02'!
test16MarsRoverRotateLeftAndMoveForwardTwoTimesMovesToTheLeftTwice
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'lflf') equals: 0@0.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:44:54' prior: 50746438!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'lflf' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].	
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].	
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:46:53'!
test16MarsRoverRotateRightAndMoveForwardTwoTimesMovesToTheRightTwice
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'rfrf') equals: 2@0.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:47:00'!
test17MarsRoverRotateRightAndMoveForwardTwoTimesMovesToTheRightTwice
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'rfrf') equals: 2@0.! !

MarsRoverTest removeSelector: #test16MarsRoverRotateRightAndMoveForwardTwoTimesMovesToTheRightTwice!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:47:56' prior: 50746472!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'lflf' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].	
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: -1 ].
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:48:08' prior: 50746520!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'lflf' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].	
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'rfrf' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: -1 ].
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:50:50'!
test18MarsRoverRotateLeftAndMoveBackwardTwoTimesMovesToTheLeftTwice
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'lblb') equals: 2@2.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:51:32' prior: 50746550!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'lflf' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: 1 ].
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'rfrf' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: -1 ].
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:51:47' prior: 50746589!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'lflf' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'lblb' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: 1 ].
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'rfrf' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: -1 ].
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:53:19'!
test19MarsRoverRotateRightAndMoveBackwardTwoTimesMovesToTheRightTwice
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'rbrb') equals: 0@1.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:53:58' prior: 50746622!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'lflf' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'lblb' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: 1 ].
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'rfrf' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: -1 ].
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'rbrb' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: 1 ].

	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/6/2019 12:54:39' prior: 50746654!
test19MarsRoverRotateRightAndMoveBackwardTwoTimesMovesToTheRightTwice
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'rbrb') equals: 0@2.! !

----SNAPSHOT----(6 October 2019 13:03:08) clase2.image priorSource: 13235389!

----QUIT----(6 October 2019 13:03:22) clase2.image priorSource: 13281787!

----STARTUP---- (7 October 2019 14:44:24) as /home/mregnier/isw1/linux64/clase2.image!

!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:46:30'!
test20MarsRoverRotateLeftAndMoveBackwardFourTimesMovesToTheLeftFourTimes
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'lblblblb') equals: 1@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:47:03'!
test21MarsRoverRotateRightAndMoveBackwardFourTimesMovesToTheRightFourTimes
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'rbrb') equals: 0@2.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:47:17' prior: 50746723!
test21MarsRoverRotateRightAndMoveBackwardFourTimesMovesToTheRightFourTimes
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: #North andMoved: 'rbrbrbrb') equals: 1@1.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:48:20' prior: 50746663!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'lflf' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'lblb' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: 1 ].
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'rfrf' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: -1 ].
	
	anInstructionString = 'rfrfrfrf' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: -1 ].
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'rbrb' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: 1 ].
	
	anInstructionString = 'rbrbrbrb' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: 1 ].


	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:49:07' prior: 50746743!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'lflf' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'lblb' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: 1 ].
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'rfrf' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: -1 ].
	
	anInstructionString = 'rfrfrfrf' ifTrue: [ ^ self moveXTimes: 0; moveYTimes: 0 ].
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'rbrb' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: 1 ].
	
	anInstructionString = 'rbrbrbrb' ifTrue: [ ^ self moveXTimes: 0; moveYTimes: 0 ].


	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:50:11' prior: 50746784!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'lflf' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'lblb' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: 1 ].
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'rfrf' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: -1 ].
	
	anInstructionString = 'rfrfrfrf' ifTrue: [ ^ self moveXTimes: 0; moveYTimes: 0 ].
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'rbrb' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: 1 ].
	
	anInstructionString = 'lblblblb' ifTrue: [ ^ self moveXTimes: 0; moveYTimes: 0 ].


	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:50:35' prior: 50746825!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'lflf' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'lblb' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: 1 ].
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'rfrf' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: -1 ].
	
	anInstructionString = 'rbrbrbrb' ifTrue: [ ^ self moveXTimes: 0; moveYTimes: 0 ].
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'rbrb' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: 1 ].
	
	anInstructionString = 'lblblblb' ifTrue: [ ^ self moveXTimes: 0; moveYTimes: 0 ].


	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:56:59' prior: 50746866!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  do: [:elem |
		elem = $f ifTrue: [ self moveForward ].
		elem = $b ifTrue: [ self moveBackward ].
		elem = $r ifTrue: [ self moveRight ].
		elem = $l ifTrue: [ self moveLeft ].
		
		].

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'lflf' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'lblb' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: 1 ].
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'rfrf' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: -1 ].
	
	anInstructionString = 'rbrbrbrb' ifTrue: [ ^ self moveXTimes: 0; moveYTimes: 0 ].
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'rbrb' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: 1 ].
	
	anInstructionString = 'lblblblb' ifTrue: [ ^ self moveXTimes: 0; moveYTimes: 0 ].


	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:57:11' prior: 50746907!
move: anInstructionString

	| amountOfForwards amountOfBackwards |

	anInstructionString  do: [:elem |
		elem = $f ifTrue: [ self moveForward ].
		elem = $b ifTrue: [ self moveBackward ].
		elem = $r ifTrue: [ self moveRight ].
		elem = $l ifTrue: [ self moveLeft ].
		].

	anInstructionString  isEmpty ifTrue: [ ^ position ].

	anInstructionString = 'lf' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'lflf' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: -1 ].
	
	anInstructionString = 'lb' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'lblb' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: 1 ].
	
	anInstructionString = 'rf' ifTrue: [ ^ self moveXTimes: 1 ].
	
	anInstructionString = 'rfrf' ifTrue: [ ^ self moveXTimes: 1; moveYTimes: -1 ].
	
	anInstructionString = 'rbrbrbrb' ifTrue: [ ^ self moveXTimes: 0; moveYTimes: 0 ].
	
	anInstructionString = 'rb' ifTrue: [ ^ self moveXTimes: -1 ].

	anInstructionString = 'rbrb' ifTrue: [ ^ self moveXTimes: -1; moveYTimes: 1 ].
	
	anInstructionString = 'lblblblb' ifTrue: [ ^ self moveXTimes: 0; moveYTimes: 0 ].


	amountOfForwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $f ifTrue: [ sum + 1 ] ifFalse: [ sum ]].

	amountOfBackwards := anInstructionString inject: 0 into: [ :sum :elem | elem = $b ifTrue: [ sum + 1 ] ifFalse: [ sum ]].
	
	^ (self moveYTimes:  amountOfForwards - amountOfBackwards ).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:57:59'!
moveForward
! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:58:06'!
moveBackwards
! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:58:10'!
moveBackward
! !

MarsRover removeSelector: #moveBackwards!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 14:59:44' prior: 50747000!
moveForward
	
	orientation  = #North ifTrue: [ .].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:00:00'!
increaseX
	^ position := position + (1@0).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:00:09'!
decreaseX
	^ position := position + (-1@0).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:00:19'!
decreaseY
	^ position := position + (0@-1).! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:00:26'!
increaseY
	^ position := position + (0@1).! !

MarsRover removeSelector: #moveXTimes:!

MarsRover removeSelector: #moveYTimes:!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:00:48' prior: 50747011!
moveForward
	
	orientation  = #North ifTrue: [ self increaseX.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:01:13' prior: 50747035!
moveForward
	
	orientation  = #North ifTrue: [ self increaseX.].
	
	orientation  = #East ifTrue: [ self increaseX.].
	
	orientation  = #South ifTrue: [ self increaseX.].
	
	orientation  = #West ifTrue: [ self increaseX.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:01:58' prior: 50747041!
moveForward
	
	orientation  = #North ifTrue: [ ^ self increaseX.].
	
	orientation  = #East ifTrue: [ ^ self increaseX.].
	
	orientation  = #South ifTrue: [ ^ self increaseX.].
	
	orientation  = #West ifTrue: [ ^ self increaseX.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:02:25' prior: 50747051!
moveForward
	
	orientation  = #North ifTrue: [ ^ self increaseX.].
	
	orientation  = #East ifTrue: [ ^ self increaseY.].
	
	orientation  = #South ifTrue: [ ^ self decreaseX.].
	
	orientation  = #West ifTrue: [ ^ self decreaseY.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:02:40' prior: 50747006!
moveBackward

	orientation  = #North ifTrue: [ ^ self increaseX.].
	
	orientation  = #East ifTrue: [ ^ self increaseY.].
	
	orientation  = #South ifTrue: [ ^ self decreaseX.].
	
	orientation  = #West ifTrue: [ ^ self decreaseY.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:03:10' prior: 50747073!
moveBackward

	orientation  = #North ifTrue: [ ^ self decreaseX.].
	
	orientation  = #East ifTrue: [ ^ self decreaseY.].
	
	orientation  = #South ifTrue: [ ^ self increaseX.].
	
	orientation  = #West ifTrue: [ ^ self increaseY.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:03:28'!
moveRight

	orientation  = #North ifTrue: [ ^ self decreaseX.].
	
	orientation  = #East ifTrue: [ ^ self decreaseY.].
	
	orientation  = #South ifTrue: [ ^ self increaseX.].
	
	orientation  = #West ifTrue: [ ^ self increaseY.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:03:59' prior: 50747094!
moveRight

	orientation  = #North ifTrue: [ orientation := #East.].
	
	orientation  = #East ifTrue: [ ^ self decreaseY.].
	
	orientation  = #South ifTrue: [ ^ self increaseX.].
	
	orientation  = #West ifTrue: [ ^ self increaseY.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:05:00' prior: 50747105!
moveRight

	orientation  = #North ifTrue: [ orientation := #East.].
	
	orientation  = #East ifTrue: [ orientation := #South. ].
	
	orientation  = #South ifTrue: [ orientation := #West. ].
	
	orientation  = #West ifTrue: [ orientation := #North.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:05:07'!
moveLeft

	orientation  = #North ifTrue: [ orientation := #East.].
	
	orientation  = #East ifTrue: [ orientation := #South. ].
	
	orientation  = #South ifTrue: [ orientation := #West. ].
	
	orientation  = #West ifTrue: [ orientation := #North.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:05:16' prior: 50747127!
moveLeft

	orientation  = #North ifTrue: [ orientation := #West.].
	
	orientation  = #East ifTrue: [ orientation := #South. ].
	
	orientation  = #South ifTrue: [ orientation := #West. ].
	
	orientation  = #West ifTrue: [ orientation := #North.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:05:47' prior: 50747138!
moveLeft

	orientation  = #North ifTrue: [ orientation := #West.].
	
	orientation  = #East ifTrue: [ orientation := #North. ].
	
	orientation  = #South ifTrue: [ orientation := #East. ].
	
	orientation  = #West ifTrue: [ orientation := #South.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:06:32' prior: 50746954!
move: anInstructionString

	| |

	anInstructionString  do: [:elem |
		elem = $f ifTrue: [ self moveForward ].
		elem = $b ifTrue: [ self moveBackward ].
		elem = $r ifTrue: [ self moveRight ].
		elem = $l ifTrue: [ self moveLeft ].
		].
	
	^ self position.! !

MarsRover removeSelector: #position!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:07:00' prior: 50747160!
move: anInstructionString

	anInstructionString  do: [:elem |
		elem = $f ifTrue: [ self moveForward ].
		elem = $b ifTrue: [ self moveBackward ].
		elem = $r ifTrue: [ self moveRight ].
		elem = $l ifTrue: [ self moveLeft ].
		].
	
	^ self position.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:07:05' prior: 50747173!
move: anInstructionString

	anInstructionString  do: [:elem |
		elem = $f ifTrue: [ self moveForward ].
		elem = $b ifTrue: [ self moveBackward ].
		elem = $r ifTrue: [ self moveRight ].
		elem = $l ifTrue: [ self moveLeft ].
		].
	
	^ position.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:08:16' prior: 50747062!
moveForward
	
	orientation  = #North ifTrue: [ ^ self increaseY.].
	
	orientation  = #East ifTrue: [ ^ self increaseX.].
	
	orientation  = #South ifTrue: [ ^ self decreaseY.].
	
	orientation  = #West ifTrue: [ ^ self decreaseX.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:08:39' prior: 50747084!
moveBackward

	orientation  = #North ifTrue: [ ^ self decreaseY.].
	
	orientation  = #East ifTrue: [ ^ self decreaseX.].
	
	orientation  = #South ifTrue: [ ^ self increaseY.].
	
	orientation  = #West ifTrue: [ ^ self increaseX.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:14:55' prior: 50747116!
moveRight

	orientation  = #North ifTrue: [ ^ orientation := #East.].
	
	orientation  = #East ifTrue: [ ^ orientation := #South. ].
	
	orientation  = #South ifTrue: [ ^ orientation := #West. ].
	
	orientation  = #West ifTrue: [ ^ orientation := #North.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:15:05' prior: 50747149!
moveLeft

	orientation  = #North ifTrue: [ ^ orientation := #West.].
	
	orientation  = #East ifTrue: [ orientation := #North. ].
	
	orientation  = #South ifTrue: [ orientation := #East. ].
	
	orientation  = #West ifTrue: [ orientation := #South.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:15:09' prior: 50747228!
moveLeft

	orientation  = #North ifTrue: [ ^ orientation := #West.].
	
	orientation  = #East ifTrue: [ ^ orientation := #North. ].
	
	orientation  = #South ifTrue: [ orientation := #East. ].
	
	orientation  = #West ifTrue: [ orientation := #South.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:15:15' prior: 50747239!
moveLeft

	orientation  = #North ifTrue: [ ^ orientation := #West.].
	
	orientation  = #East ifTrue: [ ^ orientation := #North. ].
	
	orientation  = #South ifTrue: [ ^ orientation := #East. ].
	
	orientation  = #West ifTrue: [ orientation := #South.].! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:15:19' prior: 50747250!
moveLeft

	orientation  = #North ifTrue: [ ^ orientation := #West.].
	
	orientation  = #East ifTrue: [ ^ orientation := #North. ].
	
	orientation  = #South ifTrue: [ ^ orientation := #East. ].
	
	orientation  = #West ifTrue: [ ^ orientation := #South.].! !

Object subclass: #MarsRoverCardinalPoint
	instanceVariableNames: 'position orientation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRoverCardinalPoint category: #MarsRover!
Object subclass: #MarsRoverCardinalPoint
	instanceVariableNames: 'position orientation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

MarsRoverCardinalPoint subclass: #North
	instanceVariableNames: 'position orientation'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

MarsRoverCardinalPoint subclass: #North
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #North category: #MarsRover!
MarsRoverCardinalPoint subclass: #North
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

MarsRoverCardinalPoint subclass: #East
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #East category: #MarsRover!
MarsRoverCardinalPoint subclass: #East
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

MarsRoverCardinalPoint subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #South category: #MarsRover!
MarsRoverCardinalPoint subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

MarsRoverCardinalPoint subclass: #West
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #West category: #MarsRover!
MarsRoverCardinalPoint subclass: #West
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

Object subclass: #MarsRoverCardinalPoint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRoverCardinalPoint category: #MarsRover!
Object subclass: #MarsRoverCardinalPoint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRoverCardinalPoint class methodsFor: 'no messages' stamp: 'mr 10/7/2019 15:18:33'!
new

	^self subclassResponsibility.! !

!classDefinition: 'East class' category: #MarsRover!
East class
	instanceVariableNames: 'uniqueInstance'!
!East class methodsFor: 'nil' stamp: 'mr 10/7/2019 15:19:56'!
new

	^ uniqueInstance.! !
!East class methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:20:40'!
intialize
	uniqueInstance  := self basicNew.! !
!East class methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:20:47' prior: 50747351!
intialize
	^ uniqueInstance  := self basicNew.! !
!East methodsFor: 'no messages' stamp: 'mr 10/7/2019 15:24:47'!
cardinalPointToTheLeft

	^ North new.! !
!East methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:24:57'!
cardinalPointToTheRight

	^ South new.! !
!North methodsFor: 'no messages' stamp: 'mr 10/7/2019 15:25:09'!
cardinalPointToTheLeft

	^ West new.! !
!North methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:25:19'!
cardinalPointToTheRight

	^ East new.! !
!South methodsFor: 'no messages' stamp: 'mr 10/7/2019 15:25:36'!
cardinalPointToTheLeft

	^ East new.! !
!South methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:25:50'!
cardinalPointToTheRight

	^ West new.! !
!West methodsFor: 'no messages' stamp: 'mr 10/7/2019 15:26:09'!
cardinalPointToTheLeft

	^ South new.! !
!West methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:26:20'!
cardinalPointToTheRight

	^ North new.! !
!MarsRoverCardinalPoint methodsFor: 'no messages' stamp: 'mr 10/7/2019 15:26:43'!
cardinalPointToTheLeft

	^ self subclassResponsibility.! !
!MarsRoverCardinalPoint methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:26:48'!
cardinalPointToTheRight

	^ self subclassResponsibility.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:27:46' prior: 50746290!
test01EmptyInstructionDoesNotMove

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: '') equals: 1@1.! !
!East class methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:28:44'!
initialize
	^ uniqueInstance  := self basicNew.! !

East class removeSelector: #intialize!

!classDefinition: 'North class' category: #MarsRover!
North class
	instanceVariableNames: 'uniqueInstance'!
!North class methodsFor: 'no messages' stamp: 'mr 10/7/2019 15:29:00'!
initialize
	^ uniqueInstance  := self basicNew.
! !

!classDefinition: 'South class' category: #MarsRover!
South class
	instanceVariableNames: 'uniqueInstance'!
!South class methodsFor: 'no messages' stamp: 'mr 10/7/2019 15:29:16'!
initialize
	^ uniqueInstance  := self basicNew.! !

!classDefinition: 'West class' category: #MarsRover!
West class
	instanceVariableNames: 'uniqueInstance'!
!West class methodsFor: 'no messages' stamp: 'mr 10/7/2019 15:29:24'!
initialize
	^ uniqueInstance  := self basicNew.! !

East class removeSelector: #new!
!East class methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:30:49'!
new

	^ uniqueInstance.! !
!East class methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:31:02' prior: 50747441!
new

	^ uniqueInstance.! !
!North class methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:31:07'!
new

	^ uniqueInstance.! !
!South class methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:31:13'!
new

	^ uniqueInstance.! !
!West class methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:31:32'!
new

	^ uniqueInstance.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:32:44' prior: 50746306!
test03MarsRoverMovesBackward

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'b') equals: 1@0.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:32:50' prior: 50746298!
test02MarsRoverMovesForward

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'f') equals: 1@2.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:32:57' prior: 50746314!
test04MarsRoverMovesForwardTwice

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'ff') equals: 1@3.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:33:03' prior: 50746322!
test05MarsRoverMovesBackwardTwice
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'bb') equals: 1@-1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:33:09' prior: 50746330!
test06MarsRoverMovesForwardThreeTimes

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'fff')equals: 1@4.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:33:21' prior: 50746338!
test07MarsRoverMovesBackwardThreeTimes

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'bbb') equals: 1@-2.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:33:31' prior: 50746346!
test08MarsRoverMovesForwardFourTimes
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'ffff') equals: 1@5.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:33:37' prior: 50746354!
test09MarsRoverMovesBackwardFourTimes
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'bbbb') equals: 1@-3.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:33:43' prior: 50746362!
test10MarsRoverMovesForwardOnceAndBackwardOnce
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'fb') equals: 1@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:33:52' prior: 50746118!
test11MarsRoverMovesForwardOnceAndThenForwardAgainIsInCorrectPosition
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: North new.

	newPosition := marsRover move: 'f'.
	
	newPosition := marsRover move: 'f'.

	self assert: newPosition equals: 1@3.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:34:00' prior: 50746380!
test12MarsRoverRotateLeftAndMoveForwardMovesToTheLeftOnce
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'lf') equals: 0@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:34:07' prior: 50746389!
test13MarsRoverRotateRightAndMoveForwardMovesToTheRightOnce
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'rf') equals: 2@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:34:14' prior: 50746406!
test14MarsRoverRotateLeftAndMoveBackwardMovesToTheLeftOnce

	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'lb') equals: 2@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:34:18' prior: 50746426!
test15MarsRoverRotateRightAndMoveBackwardMovesToTheRightOnce
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'rb') equals: 0@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:34:26' prior: 50746463!
test16MarsRoverRotateLeftAndMoveForwardTwoTimesMovesToTheLeftTwice
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'lflf') equals: 0@0.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:34:32' prior: 50746508!
test17MarsRoverRotateRightAndMoveForwardTwoTimesMovesToTheRightTwice
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'rfrf') equals: 2@0.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:34:38' prior: 50746580!
test18MarsRoverRotateLeftAndMoveBackwardTwoTimesMovesToTheLeftTwice
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'lblb') equals: 2@2.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:34:44' prior: 50746698!
test19MarsRoverRotateRightAndMoveBackwardTwoTimesMovesToTheRightTwice
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'rbrb') equals: 0@2.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:34:48' prior: 50746714!
test20MarsRoverRotateLeftAndMoveBackwardFourTimesMovesToTheLeftFourTimes
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'lblblblb') equals: 1@1.! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:34:55' prior: 50746733!
test21MarsRoverRotateRightAndMoveBackwardFourTimesMovesToTheRightFourTimes
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'rbrbrbrb') equals: 1@1.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:36:16' prior: 50747261!
moveLeft

	orientation := orientation cardinalPointToTheLeft! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:36:46' prior: 50747639!
moveLeft

	^ orientation := orientation cardinalPointToTheLeft! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:36:54' prior: 50747217!
moveRight

	^ orientation := orientation cardinalPointToTheLeft! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:36:58' prior: 50747649!
moveRight

	^ orientation := orientation cardinalPointToTheRight! !
!MarsRoverCardinalPoint methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:48:52'!
characteristicVersor

	^ self subclassResponsibility .! !
!MarsRoverCardinalPoint methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:49:02'!
oppositeCharacteristicVersor

	^ self subclassResponsibility .! !
!East methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:49:52'!
characteristicVersor

	^ 1@0.! !
!East methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:50:08'!
oppositeCharacteristicVersor

	^ -1@0.! !
!North methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:50:51'!
characteristicVersor

	^ 0@1.! !
!North methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:51:02'!
oppositeCharacteristicVersor

	^ 0@-1.! !
!South methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:55:43'!
oppositeCharacteristicVersor

	^ 0@1.! !
!South methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:55:50'!
characteristicVersor

	^ 0@-1.! !
!West methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:56:09'!
oppositeCharacteristicVersor

	^ 1@0.! !
!West methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:56:14'!
characteristicVersor

	^ -1@0.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:58:09' prior: 50747195!
moveForward
	
	position := position + orientation characteristicVersor. ! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 15:58:27' prior: 50747206!
moveBackward

	position := position + orientation oppositeCharacteristicVersor.! !

----SNAPSHOT----(7 October 2019 15:59:34) clase2.image priorSource: 13281866!

----SNAPSHOT----(7 October 2019 16:00:26) clase2.image priorSource: 13313970!

----QUIT----(7 October 2019 16:00:29) clase2.image priorSource: 13314049!

----STARTUP---- (7 October 2019 16:00:33) as /home/mregnier/isw1/linux64/clase2.image!


----SNAPSHOT----(7 October 2019 16:02:49) clase2.image priorSource: 13314128!

----QUIT----(7 October 2019 16:02:52) clase2.image priorSource: 13314292!

----STARTUP---- (7 October 2019 16:02:56) as /home/mregnier/isw1/linux64/clase2.image!


Smalltalk removeClassNamed: #West!

Smalltalk removeClassNamed: #South!

Smalltalk removeClassNamed: #North!

Smalltalk removeClassNamed: #East!

Smalltalk removeClassNamed: #MarsRoverCardinalPoint!

Smalltalk removeClassNamed: #MarsRover!

Smalltalk removeClassNamed: #MarsRoverTest!

----End fileIn of /home/mregnier/isw1/linux64/MarsRover.st----!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 16:10:27'!
rotateLeft

	^ orientation := orientation cardinalPointToTheLeft! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 16:10:27' prior: 50747974!
move: anInstructionString

	anInstructionString  do: [:elem |
		elem = $f ifTrue: [ self moveForward ].
		elem = $b ifTrue: [ self moveBackward ].
		elem = $r ifTrue: [ self moveRight ].
		elem = $l ifTrue: [ self rotateLeft ].
		].
	
	^ position.! !

MarsRover removeSelector: #moveLeft!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 16:10:56'!
rotateRight

	^ orientation := orientation cardinalPointToTheRight! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 16:10:56' prior: 50748239!
move: anInstructionString

	anInstructionString  do: [:elem |
		elem = $f ifTrue: [ self moveForward ].
		elem = $b ifTrue: [ self moveBackward ].
		elem = $r ifTrue: [ self rotateRight ].
		elem = $l ifTrue: [ self rotateLeft ].
		].
	
	^ position.! !

MarsRover removeSelector: #moveRight!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 16:13:15'!
test22MarsRoverRotateLeftTwiceAndRemembersOrientationAfterFirstRotation

! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/7/2019 16:14:16' prior: 50748269!
test22MarsRoverRotateLeftTwiceAndRemembersOrientationAfterFirstRotation

	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: North new.

	newPosition := marsRover move: 'l'.
	
	newPosition := marsRover move: 'lf'.

	self assert: newPosition equals: 1@0.! !

MarsRover removeSelector: #increaseY!

MarsRover removeSelector: #increaseX!

MarsRover removeSelector: #decreaseY!

MarsRover removeSelector: #decreaseX!

----SNAPSHOT----(7 October 2019 16:33:52) clase2.image priorSource: 13314371!

----QUIT----(7 October 2019 16:33:55) clase2.image priorSource: 13332496!

----STARTUP---- (9 October 2019 14:51:42) as /home/mregnier/isw1/linux64/clase2.image!


MarsRoverTest removeSelector: #test06MarsRoverMovesForwardThreeTimes!

MarsRoverTest removeSelector: #test07MarsRoverMovesBackwardThreeTimes!

MarsRoverTest removeSelector: #test08MarsRoverMovesForwardFourTimes!

MarsRoverTest removeSelector: #test09MarsRoverMovesBackwardFourTimes!

MarsRoverTest removeSelector: #test14MarsRoverRotateLeftAndMoveBackwardMovesToTheLeftOnce!

MarsRoverTest removeSelector: #test15MarsRoverRotateRightAndMoveBackwardMovesToTheRightOnce!

MarsRoverTest removeSelector: #test18MarsRoverRotateLeftAndMoveBackwardTwoTimesMovesToTheLeftTwice!

MarsRoverTest removeSelector: #test19MarsRoverRotateRightAndMoveBackwardTwoTimesMovesToTheRightTwice!

MarsRoverTest removeSelector: #test20MarsRoverRotateLeftAndMoveBackwardFourTimesMovesToTheLeftFourTimes!

MarsRoverTest removeSelector: #test21MarsRoverRotateRightAndMoveBackwardFourTimesMovesToTheRightFourTimes!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'mr 10/9/2019 15:07:30'!
test18MarsRoverDoAllPossibleInstructions
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'rflb') equals: 2@0.! !
!MarsRoverTest methodsFor: 'test' stamp: 'mr 10/9/2019 15:09:11'!
test06MarsRoverMovesForwardOnceAndBackwardOnce
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'fb') equals: 1@1.! !

MarsRoverTest removeSelector: #test10MarsRoverMovesForwardOnceAndBackwardOnce!
!MarsRoverTest methodsFor: 'test' stamp: 'mr 10/9/2019 15:09:55'!
test07MarsRoverMovesForwardOnceAndThenForwardAgain
	
	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: North new.

	newPosition := marsRover move: 'f'.
	
	newPosition := marsRover move: 'f'.

	self assert: newPosition equals: 1@3.! !

MarsRoverTest removeSelector: #test11MarsRoverMovesForwardOnceAndThenForwardAgainIsInCorrectPosition!
!MarsRoverTest methodsFor: 'test' stamp: 'mr 10/9/2019 15:10:20'!
test08MarsRoverRotatesLeftAndMovesForward
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'lf') equals: 0@1.! !

MarsRoverTest removeSelector: #test12MarsRoverRotateLeftAndMoveForwardMovesToTheLeftOnce!
!MarsRoverTest methodsFor: 'test' stamp: 'mr 10/9/2019 15:10:45'!
test09MarsRoverRotatesRightAndMovesForward
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'rf') equals: 2@1.! !

MarsRoverTest removeSelector: #test13MarsRoverRotateRightAndMoveForwardMovesToTheRightOnce!
!MarsRoverTest methodsFor: 'test' stamp: 'mr 10/9/2019 15:11:15'!
test10MarsRoverRotatesLeftAndMovesForwardTwoTimes
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'lflf') equals: 0@0.! !

MarsRoverTest removeSelector: #test16MarsRoverRotateLeftAndMoveForwardTwoTimesMovesToTheLeftTwice!

MarsRoverTest removeSelector: #test10MarsRoverRotatesLeftAndMovesForwardTwoTimes!

MarsRoverTest removeSelector: #test17MarsRoverRotateRightAndMoveForwardTwoTimesMovesToTheRightTwice!
!MarsRoverTest methodsFor: 'test' stamp: 'mr 10/9/2019 15:13:09'!
test22MarsRoverRotatesLeftTwiceAndRemembersOrientationAndPositionAfterFirstRotation

	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: East new.

	newPosition := marsRover move: 'lf'.
	
	newPosition := marsRover move: 'lf'.

	self assert: newPosition equals: 1@0.! !

MarsRoverTest removeSelector: #test22MarsRoverRotateLeftTwiceAndRemembersOrientationAfterFirstRotation!
!MarsRoverTest methodsFor: 'test' stamp: 'mr 10/9/2019 15:13:54' prior: 50748397!
test22MarsRoverRotatesLeftTwiceAndRemembersOrientationAndPositionAfterFirstRotation

	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: East new.

	newPosition := marsRover move: 'lf'.
	
	newPosition := marsRover move: 'lf'.

	self assert: newPosition equals: 0@0.! !
!MarsRoverTest methodsFor: 'test' stamp: 'mr 10/9/2019 15:14:26' prior: 50748412!
test22MarsRoverRotatesLeftTwiceAndRemembersOrientationAndPositionAfterFirstRotation

	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: East new.

	newPosition := marsRover move: 'lf'.
	
	newPosition := marsRover move: 'lf'.

	self assert: newPosition equals: 0@2.! !
!MarsRoverTest methodsFor: 'test' stamp: 'mr 10/9/2019 15:16:42'!
test10MarsRoverDoesAllPossibleInstructions
	
	self assert: (self obtainPositionOfMarsRoverStartedAt: 1@1 inOrientation: North new andMoved: 'rflb') equals: 2@0.! !

MarsRoverTest removeSelector: #test18MarsRoverDoAllPossibleInstructions!
!MarsRoverTest methodsFor: 'test' stamp: 'mr 10/9/2019 15:16:55'!
test11MarsRoverRotatesLeftTwiceAndRemembersOrientationAndPositionAfterFirstRotation

	| marsRover newPosition |

	marsRover := MarsRover at: 1@1 orientedAt: East new.

	newPosition := marsRover move: 'lf'.
	
	newPosition := marsRover move: 'lf'.

	self assert: newPosition equals: 0@2.! !

MarsRoverTest removeSelector: #test22MarsRoverRotatesLeftTwiceAndRemembersOrientationAndPositionAfterFirstRotation!

----SNAPSHOT----(9 October 2019 15:19:08) clase2.image priorSource: 13332575!

----SNAPSHOT----(9 October 2019 15:23:03) clase2.image priorSource: 13337941!

----QUIT----(9 October 2019 15:29:15) clase2.image priorSource: 13338020!

----STARTUP---- (10 October 2019 17:09:58) as /home/mregnier/isw1/linux64/clase2.image!


Object subclass: #TaTeTiGame
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TaTeTi'!

!classDefinition: #TaTeTiGame category: #TaTeTi!
Object subclass: #TaTeTiGame
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TaTeTi'!

TestCase subclass: #TaTeTiGameTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TaTeTi'!

!classDefinition: #TaTeTiGameTest category: #TaTeTi!
TestCase subclass: #TaTeTiGameTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TaTeTi'!
!TaTeTiGameTest methodsFor: 'no messages' stamp: 'mr 10/10/2019 17:13:29'!
test01Player1Starts

	| tatetiGame |
	tatetiGame := TaTeTiGame new.
	
! !
!TaTeTiGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:13:35' prior: 50748491!
test01Player1Starts

	| tatetiGame |
	
	tatetiGame := TaTeTiGame new.
	
! !
!TaTeTiGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:19:20' prior: 50748497!
test01Player1Starts

	| tatetiGame |
	
	tatetiGame := TaTeTiGame new.
	tatetiGame plays: #Player1 on: 1@3.
! !
!TaTeTiGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:20:15' prior: 50748503!
test01Player1Starts

	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	tatetiGame plays: #Player1 on: 1@3.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:21:05' prior: 50748510!
test01Player1Starts

	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	tatetiGame playsX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:21:42' prior: 50748517!
test01Player1Starts

	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	self assert: tatetiGame playsX.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:21:57'!
playsX
	self shouldBeImplemented.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:22:11' prior: 50748531!
playsX
	^ true.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:22:41'!
test01PlayerXStarts

	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	self assert: tatetiGame playsX.
! !

TerniLapilliGameTest removeSelector: #test01Player1Starts!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:23:00'!
test01PlayerODoesNotStart

	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	self assert: tatetiGame playsX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:23:19' prior: 50748549!
test01PlayerODoesNotStart

	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	self deny: tatetiGame playsO.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:23:35'!
playsO
	self shouldBeImplemented.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:23:55' prior: 50748563!
playsO
	^ false.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:24:10'!
test02PlayerODoesNotStart

	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	self deny: tatetiGame playsO.
! !

TerniLapilliGameTest removeSelector: #test01PlayerODoesNotStart!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:25:15'!
test03PlayerXPlacesChip

	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	self deny: tatetiGame playsO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:26:55'!
test03PlayerXPlacesChipInRange

	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	tatetiGame placeXChipAt: 1@1
	
	self deny: tatetiGame playsO.
! !

TerniLapilliGameTest removeSelector: #test03PlayerXPlacesChip!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:27:06' prior: 50748588!
test03PlayerXPlacesChipInRange

	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	tatetiGame placeXChipAt: 1@1.
	
	self deny: tatetiGame playsO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:28:29' prior: 50748599!
test03PlayerXPlacesChipInRange

	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	tatetiGame placeXChipAt: 1@1.
	
	self assert: (tatetiGame isXChip: 1@1).
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:28:58'!
placeXChipAt: aPoint 
	self shouldBeImplemented.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:30:36' prior: 50748616!
placeXChipAt: aCell
	
	^true! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:30:53'!
isXChip: aPoint 
	self shouldBeImplemented.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:31:00' prior: 50748625!
isXChip: aPoint 
	^ true.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:34:05' prior: 50748608!
test03PlayerXPlacesChipInRange

	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	tatetiGame placeXChipAt: 1@1.
	
	self assert: (tatetiGame isXChip: 1@1).
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:35:53'!
test04PlayerOPlaysAfterPlayerX
	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	tatetiGame placeXChipAt: 1@1.
	
	self assert: (tatetiGame isXChip: 1@1).
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:36:36' prior: 50748643!
test04PlayerOPlaysAfterPlayerX
	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	tatetiGame placeXChipAt: 1@1.
	
	self assert: (tatetiGame playsO).
! !

Object subclass: #TerniLapilliGame
	instanceVariableNames: 'turn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliGame category: #TerniLapilli!
Object subclass: #TerniLapilliGame
	instanceVariableNames: 'turn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:37:33' prior: 50748621!
placeXChipAt: aCell
	
	turn := #O.
	^true! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:38:20'!
initialize

	turn := #X.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:39:18' prior: 50748568!
playsO

	^ self playsX not.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:42:00' prior: 50748536!
playsX
	
	turn = #X.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:42:17' prior: 50748686!
playsX
	
	^ turn = #X.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:49:56'!
test05PlayerOPlaysAfterPlayerX
	| tatetiGame |
	
	tatetiGame := TerniLapilliGame new.
	tatetiGame placeXChipAt: 1@1.
	
	self assert: (tatetiGame playsO).
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:50:58' prior: 50748635!
test03PlayerXPlacesChipInRange

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	
	self assert: (game isXChip: 1@1).
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:51:14' prior: 50748540!
test01PlayerXStarts

	| game |
	
	game := TerniLapilliGame new.
	self assert: game playsX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:51:33' prior: 50748572!
test02PlayerODoesNotStart

	| game |
	
	game := TerniLapilliGame new.
	self deny: game playsO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:51:51' prior: 50748652!
test04PlayerOPlaysAfterPlayerX

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	
	self assert: (game playsO).
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 17:52:05' prior: 50748694!
test05PlayerOPlaysAfterPlayerX
	
	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	
	self assert: (game playsO).
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:15:05'!
test04PlayerXPlacesChipInRangeAndOtherCellsAreEmpty

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	
	self assert: (game isXChip: 1@1).
	
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:15:37'!
test03PlayerXPlacesChipInRangeAndTheCellIsNowOcuppied

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	
	self assert: (game isXChip: 1@1).
! !

TerniLapilliGameTest removeSelector: #test03PlayerXPlacesChipInRange!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:16:45' prior: 50748741!
test04PlayerXPlacesChipInRangeAndOtherCellsAreEmpty

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	
	self deny: (game isXChip: 0@0).
	self deny: (game isXChip: 0@1).
	self deny: (game isXChip: 0@2).
	self deny: (game isXChip: 1@0).
	self deny: (game isXChip: 1@2).
	self deny: (game isXChip: 2@0).
	self deny: (game isXChip: 2@1).
	self deny: (game isXChip: 2@2).	
! !

!classDefinition: #TerniLapilliGame category: #TerniLapilli!
Object subclass: #TerniLapilliGame
	instanceVariableNames: 'turn xChips'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:18:36' prior: 50748630!
isXChip: aPoint 
	^ xChips detect: []! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:19:35' prior: 50748782!
isXChip: aCell 
	^ xChips includes: aCell! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:20:23' prior: 50748671!
placeXChipAt: aCell
	
	xChips add: aCell .
	turn := #O.
	^true! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:21:03' prior: 50748676!
initialize

	turn := #X.
	xChips := OrderedCollection new.! !

TerniLapilliGameTest removeSelector: #test05PlayerOPlaysAfterPlayerX!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:21:38'!
test05PlayerOPlaysAfterPlayerX

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	
	self assert: (game playsO).
! !

TerniLapilliGameTest removeSelector: #test04PlayerOPlaysAfterPlayerX!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:23:30'!
test06PlayerOPlacesChipInRangeAndTheCellIsNowOcuppied

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	
	self assert: (game isXChip: 1@1).
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:25:16' prior: 50748815!
test06PlayerOPlacesChipInRangeAndTheCellIsNowOcuppied

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	game placeOChipAt: 0@0. 
	
	self assert: (game isOChip: 0@0).
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:25:28'!
placeOChipAt: aPoint 
	self shouldBeImplemented.! !

!classDefinition: #TerniLapilliGame category: #TerniLapilli!
Object subclass: #TerniLapilliGame
	instanceVariableNames: 'turn xChips oChips'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:26:11' prior: 50748833!
placeOChipAt: aCell
	oChips add: aCell.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:26:58' prior: 50748798!
initialize

	turn := #X.
	xChips := OrderedCollection new.
	oChips := OrderedCollection new.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:27:04' prior: 50748787!
isXChip: aCell 

	^ xChips includes: aCell! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:27:12'!
isOChip: aCell 

	^ xChips includes: aCell! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:27:18' prior: 50748862!
isOChip: aCell 

	^ oChips includes: aCell! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:28:54'!
test07PlayerOPlacesChipInRangeAndGameRemembersOtherCells

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	
	self deny: (game isXChip: 0@0).
	self deny: (game isXChip: 0@1).
	self deny: (game isXChip: 0@2).
	self deny: (game isXChip: 1@0).
	self deny: (game isXChip: 1@2).
	self deny: (game isXChip: 2@0).
	self deny: (game isXChip: 2@1).
	self deny: (game isXChip: 2@2).	
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:29:25' prior: 50748872!
test07PlayerOPlacesChipInRangeAndGameRemembersOtherCells

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	game placeOChipAt: 0@0.
	
	self deny: (game isXChip: 0@0).
	self deny: (game isXChip: 0@1).
	self deny: (game isXChip: 0@2).
	self deny: (game isXChip: 1@0).
	self deny: (game isXChip: 1@2).
	self deny: (game isXChip: 2@0).
	self deny: (game isXChip: 2@1).
	self deny: (game isXChip: 2@2).	
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:32:44' prior: 50748888!
test07PlayerOPlacesChipInRangeAndGameRemembersOtherCells

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	game placeOChipAt: 0@0.
	
	self assert: (game isOChip: 0@0).
	self deny: (game isXChip: 0@1).
	self deny: (game isXChip: 0@2).
	self deny: (game isXChip: 1@0).
	self deny: (game isXChip: 1@2).
	self deny: (game isXChip: 2@0).
	self deny: (game isXChip: 2@1).
	self deny: (game isXChip: 2@2).	
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:33:32'!
isOCell: aCell 

	^ oChips includes: aCell! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:33:32' prior: 50748905!
test07PlayerOPlacesChipInRangeAndGameRemembersOtherCells

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	game placeOChipAt: 0@0.
	
	self assert: (game isOCell: 0@0).
	self deny: (game isXChip: 0@1).
	self deny: (game isXChip: 0@2).
	self deny: (game isXChip: 1@0).
	self deny: (game isXChip: 1@2).
	self deny: (game isXChip: 2@0).
	self deny: (game isXChip: 2@1).
	self deny: (game isXChip: 2@2).	
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:33:32' prior: 50748824!
test06PlayerOPlacesChipInRangeAndTheCellIsNowOcuppied

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	game placeOChipAt: 0@0. 
	
	self assert: (game isOCell: 0@0).
! !

TerniLapilliGame removeSelector: #isOChip:!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:33:57'!
isXCell: aCell 

	^ xChips includes: aCell! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:33:57' prior: 50748749!
test03PlayerXPlacesChipInRangeAndTheCellIsNowOcuppied

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	
	self assert: (game isXCell: 1@1).
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:33:57' prior: 50748926!
test07PlayerOPlacesChipInRangeAndGameRemembersOtherCells

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	game placeOChipAt: 0@0.
	
	self assert: (game isOCell: 0@0).
	self deny: (game isXCell: 0@1).
	self deny: (game isXCell: 0@2).
	self deny: (game isXCell: 1@0).
	self deny: (game isXCell: 1@2).
	self deny: (game isXCell: 2@0).
	self deny: (game isXCell: 2@1).
	self deny: (game isXCell: 2@2).	
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:33:57' prior: 50748760!
test04PlayerXPlacesChipInRangeAndOtherCellsAreEmpty

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	
	self deny: (game isXCell: 0@0).
	self deny: (game isXCell: 0@1).
	self deny: (game isXCell: 0@2).
	self deny: (game isXCell: 1@0).
	self deny: (game isXCell: 1@2).
	self deny: (game isXCell: 2@0).
	self deny: (game isXCell: 2@1).
	self deny: (game isXCell: 2@2).	
! !

TerniLapilliGame removeSelector: #isXChip:!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:34:23'!
putOAt: aCell
	oChips add: aCell.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:34:23' prior: 50748967!
test07PlayerOPlacesChipInRangeAndGameRemembersOtherCells

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	game putOAt: 0@0.
	
	self assert: (game isOCell: 0@0).
	self deny: (game isXCell: 0@1).
	self deny: (game isXCell: 0@2).
	self deny: (game isXCell: 1@0).
	self deny: (game isXCell: 1@2).
	self deny: (game isXCell: 2@0).
	self deny: (game isXCell: 2@1).
	self deny: (game isXCell: 2@2).	
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:34:23' prior: 50748943!
test06PlayerOPlacesChipInRangeAndTheCellIsNowOcuppied

	| game |
	
	game := TerniLapilliGame new.
	game placeXChipAt: 1@1.
	game putOAt: 0@0. 
	
	self assert: (game isOCell: 0@0).
! !

TerniLapilliGame removeSelector: #placeOChipAt:!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:34:40'!
putXAt: aCell
	
	xChips add: aCell .
	turn := #O.
	^true! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:34:40' prior: 50748958!
test03PlayerXPlacesChipInRangeAndTheCellIsNowOcuppied

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	
	self assert: (game isXCell: 1@1).
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:34:40' prior: 50748805!
test05PlayerOPlaysAfterPlayerX

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	
	self assert: (game playsO).
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:34:40' prior: 50749006!
test07PlayerOPlacesChipInRangeAndGameRemembersOtherCells

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@0.
	
	self assert: (game isOCell: 0@0).
	self deny: (game isXCell: 0@1).
	self deny: (game isXCell: 0@2).
	self deny: (game isXCell: 1@0).
	self deny: (game isXCell: 1@2).
	self deny: (game isXCell: 2@0).
	self deny: (game isXCell: 2@1).
	self deny: (game isXCell: 2@2).	
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:34:40' prior: 50748984!
test04PlayerXPlacesChipInRangeAndOtherCellsAreEmpty

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	
	self deny: (game isXCell: 0@0).
	self deny: (game isXCell: 0@1).
	self deny: (game isXCell: 0@2).
	self deny: (game isXCell: 1@0).
	self deny: (game isXCell: 1@2).
	self deny: (game isXCell: 2@0).
	self deny: (game isXCell: 2@1).
	self deny: (game isXCell: 2@2).	
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:34:40' prior: 50749023!
test06PlayerOPlacesChipInRangeAndTheCellIsNowOcuppied

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@0. 
	
	self assert: (game isOCell: 0@0).
! !

TerniLapilliGame removeSelector: #placeXChipAt:!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:35:24'!
isPlayingO

	^ self playsX not.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:35:24' prior: 50749048!
test05PlayerOPlaysAfterPlayerX

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	
	self assert: (game isPlayingO).
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:35:24' prior: 50748718!
test02PlayerODoesNotStart

	| game |
	
	game := TerniLapilliGame new.
	self deny: game isPlayingO.
! !

TerniLapilliGame removeSelector: #playsO!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:35:45'!
isPlayingX
	
	^ turn = #X.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:35:45' prior: 50749099!
isPlayingO

	^ self isPlayingX not.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:35:45' prior: 50748711!
test01PlayerXStarts

	| game |
	
	game := TerniLapilliGame new.
	self assert: game isPlayingX.
! !

TerniLapilliGame removeSelector: #playsX!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:38:38' prior: 50749056!
test07PlayerOPlacesChipInRangeAndGameRemembersOtherCells

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@0.
	
	self assert: (game isOCell: 0@0).
	self assert: (game isXCell: 1@1).
	self deny: (game isXCell: 0@2).! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:38:52' prior: 50749138!
test07PlayerOPlacesChipInRangeAndGameRemembersOtherCells

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@0.
	
	self assert: (game isOCell: 0@0).
	self assert: (game isXCell: 1@1).
	self deny: (game isOCell: 0@2).! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:40:05'!
test07PlayerOPlacesChipInRangeAndGameRemembersOtherCellsOcuppied

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@0.
	
	self assert: (game isOCell: 0@0).
	self assert: (game isXCell: 1@1).
	self deny: (game isOCell: 0@2).! !

TerniLapilliGameTest removeSelector: #test07PlayerOPlacesChipInRangeAndGameRemembersOtherCells!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:41:17'!
test08PlayerXPlaysAfterPlayerO

	| game |
	
	game := TerniLapilliGame new.
	
	game putXAt: 1@1.
	game putOAt: 1@2.
	
	
	self assert: (game isPlayingX).
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:41:52' prior: 50749001!
putOAt: aCell

	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:49:23'!
test09PlayerCannotPlaceChipOutOfRange

	| game |
	
	game := TerniLapilliGame new.
	self should: [ game putXAt: -1@3. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: 'Cell not valid'.

! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:52:14' prior: 50749033!
putXAt: aCell
	
	self checkValidationOfCell: aCell.
	
	xChips add: aCell .
	turn := #O.
	^true! !

(1@1).!

(1@1).!

1@1 between: 0@0 and: 2@2.!

1@1 between: 0@0 and: 2@2.!

1@1 between: 0@0 and: 2@2.!

0@0 between: 0@0 and: 2@2.!

3@0 between: 0@0 and: 2@2.!

1@0 between: 0@0 and: 2@2.!

1@1 between: 0@0 and: 2@2.!

1@2 between: 0@0 and: 2@2.!

2@2 between: 0@0 and: 2@2.!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 18:57:12'!
checkValidationOfCell: aCell.
	
	^ (aCell between: 0@0 and: 2@2) ifFalse: [self error: 'Cell not valid']! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 19:14:26' prior: 50749213!
checkValidationOfCell: aCell.
	
	^ (aCell between: 0@0 and: 2@2) ifFalse: [self error: self class cellNotValidError]! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 19:15:24'!
cellNotValidError

	^ 'Cell not valid'! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 20:13:17' prior: 50749188!
test09PlayerCannotPlaceChipOutOfRange

	| game |
	
	game := TerniLapilliGame new.
	self should: [ game putXAt: -1@3. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: 'Cell not valid'.
	self deny: (game isXCell: -1@3).
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 20:13:52' prior: 50749232!
test09PlayerCannotPlaceChipOutOfRange

	| game |
	
	game := TerniLapilliGame new.
	self should: [ game putXAt: -1@3. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError.
	self deny: (game isXCell: -1@3).
! !
!TerniLapilliGame class methodsFor: 'no messages' stamp: 'mr 10/10/2019 20:14:38'!
cellNotValidError

	^ 'Cell not valid'! !

TerniLapilliGame removeSelector: #cellNotValidError!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 20:16:29'!
test04PlayerXPlacesChipInRangeAndAnotherCellIsEmpty

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	
	self deny: (game isXCell: 0@0).
	
! !

TerniLapilliGameTest removeSelector: #test04PlayerXPlacesChipInRangeAndOtherCellsAreEmpty!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 20:16:55' prior: 50749160!
test07PlayerOPlacesChipInRangeAndGameRemembersOtherCellsOcuppied

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@0.
	
	self deny: (game isOCell: 0@2).! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 20:33:08' prior: 50749220!
checkValidationOfCell: aCell.
	
	(aCell between: 0@0 and: 2@2) ifFalse: [self error: self class cellNotValidError]! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 20:38:43'!
test10PlayerOCannotPlaceChipOutOfRange

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	
	self should: [ game putOAt: -1@3. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError.
	
	self deny: (game isOCell: -1@3).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 20:38:57'!
test09PlayerXCannotPlaceChipOutOfRange

	| game |
	
	game := TerniLapilliGame new.
	self should: [ game putXAt: -1@3. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError.
	self deny: (game isXCell: -1@3).
! !

TerniLapilliGameTest removeSelector: #test09PlayerCannotPlaceChipOutOfRange!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 20:39:14' prior: 50749301!
test09PlayerXCannotPlaceChipOutOfRange

	| game |
	
	game := TerniLapilliGame new.
	self should: [ game putXAt: -1@3. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError.
	self deny: (game isXCell: -1@3).
	self assert: game isPlayingX .
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 20:39:47' prior: 50749183!
putOAt: aCell

	self checkValidationOfCell: aCell.

	
	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'mr 10/10/2019 20:42:38'!
test10PlayerXCannotPlaceChipsInAnOccupiedCell

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt:  0@0.
		
	self should: [ game putXAt: 0@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellOccupiedError.
	
	self deny: (game isOCell: 0@0).
	self assert: game isPlayingX.
! !

----SNAPSHOT----(10 October 2019 20:58:51) clase2.image priorSource: 13338099!

----QUIT----(10 October 2019 20:58:59) clase2.image priorSource: 13366250!

----STARTUP---- (15 October 2019 15:36:13) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!

!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 15:38:29'!
cellOccupiedError
	self shouldBeImplemented.! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 15:38:56' prior: 50749355!
cellOccupiedError
	^ 'La celda est ocupada'! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:42:27' prior: 50749198!
putXAt: aCell
	
	self checkValidationOfCell: aCell.
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [
		self error: self class cellOccupiedError
		]  .
	
	xChips add: aCell .
	turn := #O.
	^true! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:43:01' prior: 50749365!
putXAt: aCell
	
	self checkValidationOfCell: aCell.
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	
	xChips add: aCell .
	turn := #O.
	^true! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:44:11' prior: 50749333!
test10PlayerXCannotPlaceChipsInAnOccupiedCell

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt:  0@0.
		
	self should: [ game putXAt: 0@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellOccupiedError.
	
	self deny: (game isXCell: 0@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:44:55'!
test11PlayerXCannotPlaceChipsInAnOccupiedCell

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt:  0@0.
		
	self should: [ game putXAt: 0@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellOccupiedError.
	
	self deny: (game isXCell: 0@0).
	self assert: game isPlayingX.
! !

TerniLapilliGameTest removeSelector: #test10PlayerXCannotPlaceChipsInAnOccupiedCell!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:45:45'!
test12PlayerOCannotPlaceChipsInAnOccupiedCell

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
		
	self should: [ game putOAt: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellOccupiedError.
	
	self deny: (game isOCell: 0@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:45:51' prior: 50749415!
test12PlayerOCannotPlaceChipsInAnOccupiedCell

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
		
	self should: [ game putOAt: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellOccupiedError.
	
	self deny: (game isOCell: 0@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:46:13' prior: 50749327!
putOAt: aCell

	self checkValidationOfCell: aCell.
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	
	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:48:07' prior: 50749375!
putXAt: aCell
	
	self checkValidationOfCell: aCell.
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	
	xChips add: aCell .
	turn := #O.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:50:13'!
test13PlayerXCannotPlayTwoTimesInARow

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
		
	self should: [ game putXAt: 1@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayTwoTimesInARowError.
	
	self deny: (game isOCell: 0@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:50:38' prior: 50749461!
test13PlayerXCannotPlayTwoTimesInARow

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
		
	self should: [ game putXAt: 1@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayTwoTimesInARowError.
	
	self deny: (game isXCell: 1@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGame class methodsFor: 'error handling' stamp: 'D 10/15/2019 15:50:52'!
playerCannotPlayTwoTimesInARowError
	self shouldBeImplemented.! !
!TerniLapilliGame class methodsFor: 'error handling' stamp: 'D 10/15/2019 15:51:14' prior: 50749488!
playerCannotPlayTwoTimesInARowError
	^ ''! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 15:51:37' prior: 50749360!
cellOccupiedError
	^ 'The cell is occupied'! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 15:51:55' prior: 50749499!
cellOccupiedError
	^ 'You cannot play in an occupied cell'! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 15:52:26' prior: 50749494!
playerCannotPlayTwoTimesInARowError
	^ 'It is not your turn'! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:53:55' prior: 50749451!
putXAt: aCell
	
	self checkValidationOfCell: aCell.
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	
	xChips add: aCell .
	turn := #O.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:54:53'!
test14PlayerOCannotPlayTwoTimesInARow

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.	
	self should: [ game putOAt: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayTwoTimesInARowError.
	
	self deny: (game isOCell: 1@2).
	self assert: game isPlayingX.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:55:27' prior: 50749441!
putOAt: aCell

	self checkValidationOfCell: aCell.
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	self isPlayingX ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].

	
	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:56:33'!
test15PlayerOCannotPlayTwoTimesInARow

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.	
	self should: [ game putOAt: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isOCell: 1@2).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:57:30' prior: 50749554!
test15PlayerOCannotPlayTwoTimesInARow

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	game putOAt: 2@0.
		
	self should: [ game putXAt: 2@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isXCell: 2@2).
	self assert: game isPlayingX.
! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 15:57:44'!
playerCannotPlaceMoreThanThreeChips
	self shouldBeImplemented.! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 15:58:12' prior: 50749584!
playerCannotPlaceMoreThanThreeChips
	^ 'You have no more chips'! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:59:39' prior: 50749516!
putXAt: aCell
	
	self checkValidationOfCell: aCell.
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	
	xChips add: aCell .
	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:59:54' prior: 50749542!
putOAt: aCell

	self checkValidationOfCell: aCell.
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	self isPlayingX ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].

	
	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 15:59:57' prior: 50749612!
putOAt: aCell

	self checkValidationOfCell: aCell.
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	self isPlayingX ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	oChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].

	
	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:00:35'!
test15PlayerXCannotPlayTwoTimesInARow

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	game putOAt: 2@0.
		
	self should: [ game putXAt: 2@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isXCell: 2@2).
	self assert: game isPlayingX.
! !

TerniLapilliGameTest removeSelector: #test15PlayerOCannotPlayTwoTimesInARow!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:00:56'!
test15PlayerXCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	game putOAt: 2@0.
		
	self should: [ game putXAt: 2@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isXCell: 2@2).
	self assert: game isPlayingX.
! !

TerniLapilliGameTest removeSelector: #test15PlayerXCannotPlayTwoTimesInARow!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:01:09'!
test16PlayerOCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	game putOAt: 2@0.
		
	self should: [ game putXAt: 2@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isXCell: 2@2).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:02:40' prior: 50749681!
test16PlayerOCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	game putOAt: 2@0.
	game slideXFrom: 1@1 to: 0@2.
		
	self should: [ game putXAt: 2@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isXCell: 2@2).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:03:01' prior: 50749698!
test16PlayerOCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	game putOAt: 2@0.
	game slideXFrom: 1@1 to: 0@2.
		
	self should: [ game putOAt: 2@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isOCell: 2@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:03:18'!
slideXFrom: aPoint to: aPoint2 
	self shouldBeImplemented.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:03:49' prior: 50749733!
slideXFrom: originCell to: destinyCell 
	self shouldBeImplemented.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:03:58' prior: 50749739!
slideXFrom: originCell to: destinyCell 
	^ true.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:04:44' prior: 50749745!
slideXFrom: originCell to: destinyCell 
	turn := #O.
	^ true.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:07:32'!
test17PlayerXCannotSlideBeforePlacingThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	game putOAt: 2@0.
	game slideXFrom: 1@1 to: 0@2.
		
	self should: [ game putOAt: 2@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isOCell: 2@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:08:08' prior: 50749755!
test17PlayerXCannotSlideBeforePlacingThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	
	self should: [ game slideXFrom: 1@1 to: 0@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isOCell: 2@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:08:59' prior: 50749773!
test17PlayerXCannotSlideBeforePlacingThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	
	self should: [ game slideXFrom: 1@1 to: 0@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideBeforePlacingThreeChipsError.
	
	self deny: (game isOCell: 2@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:10:11' prior: 50749789!
test17PlayerXCannotSlideBeforePlacingThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	
	self should: [ game slideXFrom: 1@1 to: 0@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideBeforePlacingThreeChipsError.
	
	self deny: (game isXCell: 0@2).
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingX.
! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 16:10:27'!
playerCannotSlideBeforePlacingThreeChipsError
	self shouldBeImplemented.! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 16:11:00' prior: 50749823!
playerCannotSlideBeforePlacingThreeChipsError
	^ 'Place all your chips before sliding them'! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:11:33' prior: 50749750!
slideXFrom: originCell to: destinyCell 
	


	turn := #O.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:12:21' prior: 50749836!
slideXFrom: originCell to: destinyCell 
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 


	turn := #O.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:14:06'!
test18PlayerOCannotSlideBeforePlacingThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	
	self should: [ game slideXFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideBeforePlacingThreeChipsError.
	
	self deny: (game isOCell: 2@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:14:29' prior: 50749850!
test18PlayerOCannotSlideBeforePlacingThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	
	self should: [ game slideOFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideBeforePlacingThreeChipsError.
	
	self deny: (game isOCell: 2@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:14:40'!
slideOFrom: aPoint to: aPoint2 
	self shouldBeImplemented.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:14:56' prior: 50749842!
slideXFrom: originCell to: destinyCell 
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 


	turn := #X.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:15:06' prior: 50749892!
slideXFrom: originCell to: destinyCell 
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 


	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:15:40' prior: 50749886!
slideOFrom: originCell to: destinyCell 
	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 


	turn := #X.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:18:28'!
test19PlayerXCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	game putOAt: 2@0.
	self should: [ game slideXFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 2@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:19:13' prior: 50749918!
test19PlayerXCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	game putOAt: 2@0.
	self should: [ game slideXFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isXCell: 2@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 16:19:21'!
playerCannotSlideChipFromAPositionNotOwnedError
	self shouldBeImplemented.! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 16:19:56' prior: 50749955!
playerCannotSlideChipFromAPositionNotOwnedError
	^ 'You cannot slide a chip from a position you don not own'! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:22:42' prior: 50749901!
slideXFrom: originCell to: destinyCell 
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].


	turn := #O.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:24:37'!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	game putOAt: 2@0.
	game slideXFrom: 1@1 to: 2@2.
	self should: [ game slideOFrom: 1@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isXCell: 2@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:25:41' prior: 50749980!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	game putOAt: 2@0.
	game slideXFrom: 2@1 to: 2@2.
	self should: [ game slideOFrom: 1@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 1@2).
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:27:35' prior: 50750000!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 2@0.
	game slideXFrom: 2@1 to: 2@2.
	self should: [ game slideOFrom: 1@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 1@2).
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:27:56' prior: 50750020!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@1 to: 2@2.
	self should: [ game slideOFrom: 1@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 1@2).
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:28:17' prior: 50750040!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.
	self should: [ game slideOFrom: 1@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 1@2).
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:28:50' prior: 50750060!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.
	self should: [ game slideOFrom: 2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 1@2).
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:29:10' prior: 50750080!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.
	self should: [ game slideOFrom: 2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 2@1).
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:29:46' prior: 50750100!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.
	self should: [ game slideOFrom: 2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 2@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:30:21' prior: 50749910!
slideOFrom: originCell to: destinyCell 
	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	turn := #X.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:30:58' prior: 50749937!
test19PlayerXCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isXCell: 2@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:32:13' prior: 50749868!
test18PlayerOCannotSlideBeforePlacingThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	
	self should: [ game slideOFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideBeforePlacingThreeChipsError.
	
	self deny: (game isOCell: 2@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:32:44' prior: 50749716!
test16PlayerOCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
		game slideXFrom: 1@1 to: 0@2.
		
	self should: [ game putOAt: 2@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isOCell: 2@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:33:14' prior: 50750187!
test16PlayerOCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 1@1 to: 1@2.
		
	self should: [ game putOAt: 2@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isOCell: 2@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:34:14' prior: 50749628!
putOAt: aCell

	self checkValidationOfCell: aCell.
	oChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	self isPlayingX ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].

	
	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:34:25' prior: 50749596!
putXAt: aCell
	
	self checkValidationOfCell: aCell.
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	
	xChips add: aCell .
	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:34:38' prior: 50750239!
putXAt: aCell
	
	self checkValidationOfCell: aCell.
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	
	xChips add: aCell .
	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:34:47' prior: 50750223!
putOAt: aCell

	self checkValidationOfCell: aCell.
	oChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	self isPlayingX ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	
	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:35:14' prior: 50750205!
test16PlayerOCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 1@1 to: 1@2.
		
	self should: [ game putOAt: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isOCell: 2@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:35:27' prior: 50750287!
test16PlayerOCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 1@1 to: 1@2.
		
	self should: [ game putOAt: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isOCell: 1@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:36:31' prior: 50749662!
test15PlayerXCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
		
	self should: [ game putXAt: 2@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isXCell: 2@2).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:36:41' prior: 50750323!
test15PlayerXCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
		
	self should: [ game putXAt: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isXCell: 2@2).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:36:50' prior: 50750340!
test15PlayerXCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
		
	self should: [ game putXAt: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self deny: (game isXCell: 1@2).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:37:11' prior: 50750120!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 2@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:39:13'!
test21PlayerXCannotSlideFromAPositionNotOwned

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isXCell: 2@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:39:31'!
test22PlayerOCannotSlideFromAPositionNotOwned

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 2@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:39:50' prior: 50750150!
test19PlayerXCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: -1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isXCell: 2@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:40:16' prior: 50750429!
test19PlayerXCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: -1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAnInvalidPositionError.
	
	self deny: (game isXCell: 2@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 16:40:28'!
playerCannotSlideChipFromAnInvalidPositionError
	self shouldBeImplemented.! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 16:42:24' prior: 50750465!
playerCannotSlideChipFromAnInvalidPositionError
	
	^ 'You cannot slide from an invalid cell'! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:43:05' prior: 50749968!
slideXFrom: originCell to: destinyCell 
	self checkValidationOfCell: originCell.
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].


	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:44:43'!
checkValidationOfCell: aCell withError: anErrorMessage.
	
	(aCell between: 0@0 and: 2@2) ifFalse: [self error: anErrorMessage]! !

TerniLapilliGame removeSelector: #checkValidationOfCell:!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:45:09' prior: 50750271!
putOAt: aCell

	self checkValidationOfCell: aCell withError: self class cellNotValidError .
	oChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	self isPlayingX ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	
	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:45:27' prior: 50750255!
putXAt: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	((xChips includes: aCell) or: (oChips includes: aCell)) ifTrue: [ self error: self class cellOccupiedError. ].
	
	xChips add: aCell .
	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:45:51' prior: 50750478!
slideXFrom: originCell to: destinyCell 
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].


	turn := #O.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:46:31' prior: 50750374!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: -2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 2@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:47:00' prior: 50750551!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: -2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAnInvalidPositionError .
	
	self deny: (game isOCell: 2@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:47:41' prior: 50750138!
slideOFrom: originCell to: destinyCell 
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	turn := #X.! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 16:48:04'!
playerCannotSlideChipToAnInvalidPositionError
	self shouldBeImplemented.! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 16:48:23' prior: 50750608!
playerCannotSlideChipToAnInvalidPositionError
	
	^ 'You cannot slide into an invalid cell'! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:48:40' prior: 50750535!
slideXFrom: originCell to: destinyCell 
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].


	turn := #O.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:48:59'!
test23PlayerXCannotSlideFromAPositionNotOwned

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isXCell: 2@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:49:11'!
test24PlayerOCannotSlideFromAPositionNotOwned

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 2@1).
	self assert: game isPlayingO.
! !

TerniLapilliGameTest removeSelector: #test21PlayerXCannotSlideFromAPositionNotOwned!

TerniLapilliGameTest removeSelector: #test22PlayerOCannotSlideFromAPositionNotOwned!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:49:40'!
test21PlayerXCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: -1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAnInvalidPositionError.
	
	self deny: (game isXCell: 2@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:49:52'!
test22PlayerOCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: -2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAnInvalidPositionError .
	
	self deny: (game isOCell: 2@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:50:07' prior: 50750682!
test21PlayerXCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: -2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAnInvalidPositionError.
	
	self deny: (game isXCell: 2@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:50:20' prior: 50750718!
test21PlayerXCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: -2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAnInvalidPositionError.
	
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:50:54' prior: 50750699!
test22PlayerOCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: -2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAnInvalidPositionError .
	
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:51:06' prior: 50750754!
test22PlayerOCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: -2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnInvalidPositionError .
	
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:51:13' prior: 50750736!
test21PlayerXCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: -2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnInvalidPositionError.
	
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:54:14'!
test25PlayerXCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: 1@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isXCell: 2@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:54:31' prior: 50750809!
test25PlayerXCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: 1@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnOccupiedPositionError.
	
	self deny: (game isXCell: 2@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:54:45' prior: 50750828!
test25PlayerXCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: 1@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnOccupiedPositionError.
	
	self assert: (game isXCell: 1@1).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:55:02' prior: 50750847!
test25PlayerXCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: 1@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnOccupiedPositionError.
	
	self assert: (game isXCell: 1@1).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 16:55:23'!
playerCannotSlideChipToAnOccupiedPositionError
	self shouldBeImplemented.! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 16:55:51' prior: 50750884!
playerCannotSlideChipToAnOccupiedPositionError
	
	^ 'You cannot slide your chip to an occupied cell'! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:57:48' prior: 50750621!
slideXFrom: originCell to: destinyCell 
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:58:51'!
isEmptyCell: aCell

	^ (xChips includes: aCell) or: (oChips includes: aCell)
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:59:29' prior: 50750919!
isEmptyCell: aCell

	^ (xChips includes: aCell) not and: (oChips includes: aCell) not.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 16:59:49' prior: 50750925!
isEmptyCell: aCell

	^ (xChips excludes: aCell) and: (oChips excludes: aCell).
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:00:13' prior: 50750518!
putXAt: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].
	
	xChips add: aCell .
	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:00:34' prior: 50750501!
putOAt: aCell

	self checkValidationOfCell: aCell withError: self class cellNotValidError .
	oChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	self isPlayingX ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].
	
	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:04:05' prior: 50750931!
isEmptyCell: aCell

	^ (xChips includes: aCell) and: (oChips excludes: aCell).! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:04:14' prior: 50750969!
isEmptyCell: aCell

	^ (xChips includes: aCell) not and: (oChips includes: aCell) not.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:05:06' prior: 50750897!
slideXFrom: originCell to: destinyCell 
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].

	turn := #O.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:05:51'!
test26PlayerOCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self deny: (game isOCell: 2@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:06:14' prior: 50751004!
test26PlayerOCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnOccupiedPositionError.
	
	self deny: (game isOCell: 2@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:06:44' prior: 50751023!
test26PlayerOCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnOccupiedPositionError.
	
	self deny: (game isOCell: 2@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:10:07' prior: 50750589!
slideOFrom: originCell to: destinyCell 
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .

	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	turn := #X.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:10:21' prior: 50751042!
test26PlayerOCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnOccupiedPositionError.
	
	self deny: (game isOCell: 1@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:10:36' prior: 50751079!
test26PlayerOCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnOccupiedPositionError.
	
	self assert: (game isOCell: 1@0).
	self deny: (game isOCell: 1@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:10:42' prior: 50751098!
test26PlayerOCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnOccupiedPositionError.
	
	self assert: (game isOCell: 1@0).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:11:20' prior: 50751118!
test26PlayerOCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnOccupiedPositionError.
	
	self assert: (game isOCell: 1@0).
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:12:02' prior: 50751060!
slideOFrom: originCell to: destinyCell 
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .

	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].

	turn := #X.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:13:02'!
test13PlayerXCannotPlaceChipsTwoTimesInARow

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
		
	self should: [ game putXAt: 1@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayTwoTimesInARowError.
	
	self deny: (game isXCell: 1@0).
	self assert: game isPlayingO.
! !

TerniLapilliGameTest removeSelector: #test13PlayerXCannotPlayTwoTimesInARow!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:13:14'!
test14PlayerOCannotPlaceChipsTwoTimesInARow

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.	
	self should: [ game putOAt: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayTwoTimesInARowError.
	
	self deny: (game isOCell: 1@2).
	self assert: game isPlayingX.
! !

TerniLapilliGameTest removeSelector: #test14PlayerOCannotPlayTwoTimesInARow!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:16:18'!
test27PlayerXCannotSlideInTheTurnOfTheOtherPlayer

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.

	self should: [ game slideXFrom: 1@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideWhenIsNotTheirTurnError.
	
	self assert: (game isXCell: 1@1).
	self deny: (game isXCell: 1@2).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:16:38' prior: 50751213!
test27PlayerXCannotSlideInTheTurnOfTheOtherPlayer

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.

	self should: [ game slideXFrom: 1@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideWhenIsNotTheirTurnError.
	
	self assert: (game isXCell: 1@1).
	self deny: (game isXCell: 1@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 17:16:48'!
playerCannotSlideWhenIsNotTheirTurnError
	self shouldBeImplemented.! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 17:17:22' prior: 50751248!
playerCannotSlideWhenIsNotTheirTurnError
	
	^ 'You cannot slide when is not your turn'! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:17:53' prior: 50750981!
slideXFrom: originCell to: destinyCell 
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	
	
	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].

	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:18:38' prior: 50750953!
putOAt: aCell

	self isPlayingX ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	self checkValidationOfCell: aCell withError: self class cellNotValidError .
	oChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].
	
	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:18:51' prior: 50750937!
putXAt: aCell
	
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	self checkValidationOfCell: aCell withError: self class cellNotValidError.
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].
	
	xChips add: aCell .
	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:19:39' prior: 50751260!
slideXFrom: originCell to: destinyCell 
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	
	self isPlayingO ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].
	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].

	turn := #O.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:20:06'!
test28PlayerOCannotSlideInTheTurnOfTheOtherPlayer

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnOccupiedPositionError.
	
	self assert: (game isOCell: 1@0).
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:20:27' prior: 50751341!
test28PlayerOCannotSlideInTheTurnOfTheOtherPlayer

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnOccupiedPositionError.
	
	self assert: (game isOCell: 1@0).
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:21:18' prior: 50751361!
test28PlayerOCannotSlideInTheTurnOfTheOtherPlayer

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideOFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipToAnOccupiedPositionError.
	
	self assert: (game isOCell: 1@0).
	self deny: (game isOCell: 2@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:21:35' prior: 50751381!
test28PlayerOCannotSlideInTheTurnOfTheOtherPlayer

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideOFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideWhenIsNotTheirTurnError .
	
	self assert: (game isOCell: 1@0).
	self deny: (game isOCell: 2@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:22:07' prior: 50751158!
slideOFrom: originCell to: destinyCell 
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .

	self isPlayingX ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].

	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].

	turn := #X.! !

1@1 dist: 2@2.!

1@1 dist: 1@0.!

1@2 dist: 0@1.!

0@0 dist: 0@2.!

(0@0 dist: 0@2) floor.!

(0@0 dist: 1@1) floor.!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:29:38' prior: 50751299!
putXAt: aCell
	
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	self checkValidationOfCell: aCell withError: self class cellNotValidError.
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].
	
	xChips add: aCell .
	turn := #O.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:37:51'!
test29PlayerXCannotSlideToANotNeighbourPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.

	self should: [ game slideXFrom: 1@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideWhenIsNotTheirTurnError.
	
	self assert: (game isXCell: 1@1).
	self deny: (game isXCell: 1@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:38:18' prior: 50751465!
test29PlayerXCannotSlideToANotNeighbourPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideWhenIsNotTheirTurnError.
	
	self assert: (game isXCell: 1@1).
	self deny: (game isXCell: 1@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:39:50' prior: 50751483!
test29PlayerXCannotSlideToANotNeighbourPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 2@2 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToANotNeighbourPositionError.
	
	self assert: (game isXCell: 1@1).
	self deny: (game isXCell: 1@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:40:15' prior: 50751502!
test29PlayerXCannotSlideToANotNeighbourPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 2@2 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToANotNeighbourPositionError.
	
	self assert: (game isXCell: 2@2).
	self deny: (game isXCell: 2@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:40:23' prior: 50751521!
test29PlayerXCannotSlideToANotNeighbourPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 2@2 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToANotNeighbourPositionError.
	
	self assert: (game isXCell: 2@2).
	self deny: (game isXCell: 2@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 17:40:37'!
playerCannotSlideToANotNeighbourPositionError
	self shouldBeImplemented.! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 17:43:19'!
playerCannotSlideToAPositionNotFollowingPredefinedLinesError
	
	^ 'You cannot slide to that position. You can only slide to neighbouring positions set by the lines of the board.'! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:43:37' prior: 50751540!
test29PlayerXCannotSlideToANotNeighbourPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 2@2 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToAPositionNotFollowingPredefinedLinesError.
	
	self assert: (game isXCell: 2@2).
	self deny: (game isXCell: 2@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:43:52' prior: 50751315!
slideXFrom: originCell to: destinyCell 
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	
	self isPlayingO ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].
	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].

	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:46:34' prior: 50751592!
slideXFrom: originCell to: destinyCell 
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(originCell dist: destinyCell) floor = 1 ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
	
	self isPlayingO ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].
	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].

	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:48:09'!
connectedByLine: originCell to: destinyCell
	
	^ (originCell dist: destinyCell) floor = 1 ! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:48:18'!
connectedByLineFrom: originCell to: destinyCell
	
	^ (originCell dist: destinyCell) floor = 1 ! !

TerniLapilliGame removeSelector: #connectedByLine:to:!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:48:48' prior: 50751618!
slideXFrom: originCell to: destinyCell 
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
	
	self isPlayingO ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].
	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].

	turn := #O.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:50:21'!
test30PlayerOCannotSlideToANotNeighbourPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 1@1 to: 2@1.
	
	self should: [ game slideOFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideWhenIsNotTheirTurnError .
	
	self assert: (game isOCell: 1@0).
	self deny: (game isOCell: 2@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:51:04' prior: 50751692!
test30PlayerOCannotSlideToANotNeighbourPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 1@1 to: 2@1.
	
	self should: [ game slideOFrom: 1@0 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideWhenIsNotTheirTurnError .
	
	self assert: (game isOCell: 1@0).
	self deny: (game isOCell: 1@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:51:20' prior: 50751712!
test30PlayerOCannotSlideToANotNeighbourPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 1@1 to: 2@1.
	
	self should: [ game slideOFrom: 1@0 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToAPositionNotFollowingPredefinedLinesError.
	
	self assert: (game isOCell: 1@0).
	self deny: (game isOCell: 1@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:51:44' prior: 50751419!
slideOFrom: originCell to: destinyCell 

	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].

	self isPlayingX ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].

	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].

	turn := #X.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 17:52:37'!
test31PlayerXCannotSlideNotFollowingThePredefinedLines

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 2@2 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToAPositionNotFollowingPredefinedLinesError.
	
	self assert: (game isXCell: 2@2).
	self deny: (game isXCell: 2@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:09:36' prior: 50751782!
test31PlayerXCannotSlideNotFollowingThePredefinedLines

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 0@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToAPositionNotFollowingPredefinedLinesError.
	
	self assert: (game isXCell: 2@2).
	self deny: (game isXCell: 2@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:09:50' prior: 50751801!
test31PlayerXCannotSlideNotFollowingThePredefinedLines

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 0@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToAPositionNotFollowingPredefinedLinesError.
	
	self assert: (game isXCell: 0@1).
	self deny: (game isXCell: 1@2).
	self assert: game isPlayingX.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:14:40' prior: 50751654!
connectedByLineFrom: originCell to: destinyCell
	
	^ (originCell dist: destinyCell) floor = 1 and ! !

----SNAPSHOT----(15 October 2019 18:14:43) clase2.image priorSource: 13366330!

----QUIT----(15 October 2019 18:14:52) clase2.image priorSource: 13446213!

----STARTUP---- (15 October 2019 18:20:57) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!

!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:25:06' prior: 50751839!
connectedByLineFrom: originCell to: destinyCell
	
	^ (originCell dist: destinyCell) floor = 1 and self allowedMoveByLinesFrom: originCell to: destinyCell.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:30:22'!
allowedMoveByLinesFrom: originCell to: destinyCell

	| restrictedMoves |

	restrictedMoves = Dictionary new.
	restrictedMoves add: (Association key: 0@1 value: [1@2, 1@0]).
	restrictedMoves add: (Association key: 1@2 value: [0@1, 2@1]).
	restrictedMoves add: (Association key: 2@1 value: [1@2, 1@0]).
	restrictedMoves add: (Association key: 1@0 value: [0@1, 2@1]).
	
	^ Association! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:33:11' prior: 50751862!
allowedMoveByLinesFrom: originCell to: destinyCell

	| restrictedMoves |

	restrictedMoves = Dictionary new.
	restrictedMoves add: (Association key: 0@1 value: [1@2, 1@0]).
	restrictedMoves add: (Association key: 1@2 value: [0@1, 2@1]).
	restrictedMoves add: (Association key: 2@1 value: [1@2, 1@0]).
	restrictedMoves add: (Association key: 1@0 value: [0@1, 2@1]).
	
	^ (restrictedMoves associationAt: originCell ifAbsent: [ ^ true ]) includes: destinyCell. ! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:34:11' prior: 50751878!
allowedMoveByLinesFrom: originCell to: destinyCell

	| restrictedMoves |

	restrictedMoves = Dictionary new.
	restrictedMoves add: (Association key: 0@1 value: [1@2, 1@0]).
	restrictedMoves add: (Association key: 1@2 value: [0@1, 2@1]).
	restrictedMoves add: (Association key: 2@1 value: [1@2, 1@0]).
	restrictedMoves add: (Association key: 1@0 value: [0@1, 2@1]).
	
	^ ((restrictedMoves associationAt: originCell ifAbsent: [ ^ true ]) includes: destinyCell) not. ! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:34:25' prior: 50751896!
allowedMoveByLinesFrom: originCell to: destinyCell

	| restrictedMoves |

	restrictedMoves := Dictionary new.
	restrictedMoves add: (Association key: 0@1 value: [1@2, 1@0]).
	restrictedMoves add: (Association key: 1@2 value: [0@1, 2@1]).
	restrictedMoves add: (Association key: 2@1 value: [1@2, 1@0]).
	restrictedMoves add: (Association key: 1@0 value: [0@1, 2@1]).
	
	^ ((restrictedMoves associationAt: originCell ifAbsent: [ ^ true ]) includes: destinyCell) not. ! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:34:57' prior: 50751854!
connectedByLineFrom: originCell to: destinyCell
	
	^ (originCell dist: destinyCell) floor = 1 and: (self allowedMoveByLinesFrom: originCell to: destinyCell).! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:35:35' prior: 50751914!
allowedMoveByLinesFrom: originCell to: destinyCell

	| restrictedMoves |

	restrictedMoves := Dictionary new.
	restrictedMoves add: (Association key: 0@1 value: [1@2, 1@0]).
	restrictedMoves add: (Association key: 1@2 value: [0@1, 2@1]).
	restrictedMoves add: (Association key: 2@1 value: [1@2, 1@0]).
	restrictedMoves add: (Association key: 1@0 value: [0@1, 2@1]).
	
	^ ((restrictedMoves associationAt: originCell ifAbsent: [ ^ true ])  value includes: destinyCell) not. ! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:36:57' prior: 50751941!
allowedMoveByLinesFrom: originCell to: destinyCell

	| restrictedMoves |

	restrictedMoves := Dictionary new.
	restrictedMoves add: (Association key: 0@1 value: #(1@2, 1@0)).
	restrictedMoves add: (Association key: 1@2 value: #(0@1, 2@1)).
	restrictedMoves add: (Association key: 2@1 value: #(1@2, 1@0)).
	restrictedMoves add: (Association key: 1@0 value: #(0@1, 2@1)).
	
	^ ((restrictedMoves associationAt: originCell ifAbsent: [ ^ true ])  value includes: destinyCell) not. ! !

 (originCell dist: destinyCell) floor = 1 !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:44:09' prior: 50751959!
allowedMoveByLinesFrom: originCell to: destinyCell

	| restrictedMoves |

	restrictedMoves := Dictionary new.
	restrictedMoves add: (Association key: 0@1 value: {1@2, 1@0}).
	restrictedMoves add: (Association key: 1@2 value: {0@1, 2@1}).
	restrictedMoves add: (Association key: 2@1 value: {1@2, 1@0}).
	restrictedMoves add: (Association key: 1@0 value: {0@1, 2@1}).
	
	^ ((restrictedMoves associationAt: originCell ifAbsent: [ ^ true ])  value includes: destinyCell) not. ! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:35:35' prior: 50751979!
allowedMoveByLinesFrom: originCell to: destinyCell

	| restrictedMoves |

	restrictedMoves := Dictionary new.
	restrictedMoves add: (Association key: 0@1 value: [1@2, 1@0]).
	restrictedMoves add: (Association key: 1@2 value: [0@1, 2@1]).
	restrictedMoves add: (Association key: 2@1 value: [1@2, 1@0]).
	restrictedMoves add: (Association key: 1@0 value: [0@1, 2@1]).
	
	^ ((restrictedMoves associationAt: originCell ifAbsent: [ ^ true ])  value includes: destinyCell) not. ! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:36:57' prior: 50751997!
allowedMoveByLinesFrom: originCell to: destinyCell

	| restrictedMoves |

	restrictedMoves := Dictionary new.
	restrictedMoves add: (Association key: 0@1 value: #(1@2, 1@0)).
	restrictedMoves add: (Association key: 1@2 value: #(0@1, 2@1)).
	restrictedMoves add: (Association key: 2@1 value: #(1@2, 1@0)).
	restrictedMoves add: (Association key: 1@0 value: #(0@1, 2@1)).
	
	^ ((restrictedMoves associationAt: originCell ifAbsent: [ ^ true ])  value includes: destinyCell) not. ! !

#() add: 1@0!

#() add: 1!

#()!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:49:03' prior: 50752015!
allowedMoveByLinesFrom: originCell to: destinyCell

	| restrictedMoves |

	restrictedMoves := Dictionary new.
	restrictedMoves add: (Association key: 0@1 value: (OrderedCollection with: 1@2 with: 1@0)).
	restrictedMoves add: (Association key: 1@2 value: (OrderedCollection with: 0@1 with: 2@1)).
	restrictedMoves add: (Association key: 2@1 value: (OrderedCollection with: 1@2 with: 1@0)).
	restrictedMoves add: (Association key: 1@0 value: (OrderedCollection with: 0@1 with: 2@1)).
	
	^ ((restrictedMoves associationAt: originCell ifAbsent: [ ^ true ])  value includes: destinyCell) not. ! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:51:06'!
test32PlayerOCannotSlideNotFollowingThePredefinedLines

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.
	
	self should: [ game slideOFrom: 0@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToAPositionNotFollowingPredefinedLinesError.
	
	self assert: (game isXCell: 0@1).
	self deny: (game isXCell: 1@2).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:52:09' prior: 50752057!
test32PlayerOCannotSlideNotFollowingThePredefinedLines

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.
	
	self should: [ game slideOFrom: 1@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToAPositionNotFollowingPredefinedLinesError.
	
	self assert: (game isOCell: 1@0).
	self deny: (game isOCell: 2@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:55:59'!
test33PlayerXSlideUpdatesTheChipPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	
	game slideXFrom: 2@2 to: 1@2.
	
	self assert: (game isXCell: 1@2).
	self deny: (game isXCell: 2@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:58:57' prior: 50751662!
slideXFrom: originCell to: destinyCell 
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
	
	self isPlayingO ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].
	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	
	xChips remove: originCell.
	xChips add: destinyCell.
	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 18:59:43' prior: 50751752!
slideOFrom: originCell to: destinyCell 

	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].

	self isPlayingX ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].

	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	
	oChips remove: originCell .
	oChips  add: destinyCell.
	turn := #X.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:00:42'!
test34PlayerOSlideUpdatesTheChipPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.
	
	game slideOFrom: 1@0 to: 2@0.
	
	self assert: (game isOCell: 2@0).
	self deny: (game isOCell: 1@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:02:16'!
test35GameIsOver

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	
	self assert: (game isOver).
	! !
!TerniLapilliGame methodsFor: 'finalization' stamp: 'D 10/15/2019 19:02:32'!
isOver
	self shouldBeImplemented.! !
!TerniLapilliGame methodsFor: 'finalization' stamp: 'D 10/15/2019 19:09:01' prior: 50752200!
isOver
	^ self xWon or: self oWon.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:09:11'!
xWon
	self shouldBeImplemented.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:11:43' prior: 50752209!
xWon
	^ self canWinWithPositions: xChips.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:11:52'!
oWon
	^ self canWinWithPositions: oChips.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:14:20'!
canWinWithPositions: positions

	^ (self verticalLineIn: positions) or: ((self horizontalLineIn: positions) or: (self diagonalLineIn: positions)).! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:16:50'!
verticalLineIn: positions
	
	^ positions allSatisfy: [:position | position x = positions first x]! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:17:10'!
horizontalLineIn: positions

! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:17:33' prior: 50752238!
horizontalLineIn: positions

	^ positions allSatisfy: [:position | position x = positions first x]! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:17:42' prior: 50752243!
horizontalLineIn: positions

	^ positions allSatisfy: [:position | position y = positions first y]! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:18:29'!
diagonalLineIn: positions

	^false.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:19:34'!
test35GameIsOverWithHorizontalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	
	self assert: (game isOver).
	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:19:48'!
test36GameIsOverWithVerticalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	
	self assert: (game isOver).
	! !

TerniLapilliGameTest removeSelector: #test35GameIsOver!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:20:19' prior: 50752270!
test36GameIsOverWithVerticalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 1@2.
	game putOAt: 0@2.
	game putXAt: 1@0.
	
	self assert: (game isOver).
	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:20:43'!
test36GameIsOverWithDiagonalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 0@0.
	game putOAt: 0@2.
	game putXAt: 2@2.
	
	self assert: (game isOver).
	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:20:51'!
test37GameIsOverWithDiagonalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 0@0.
	game putOAt: 0@2.
	game putXAt: 2@2.
	
	self assert: (game isOver).
	! !

TerniLapilliGameTest removeSelector: #test36GameIsOverWithDiagonalLine!
!TerniLapilliGame methodsFor: 'private testing' stamp: 'D 10/15/2019 19:29:12' prior: 50752256!
diagonalLineIn: positions

	^ (self diagonalAscendingLineIn: positions) or: (self diagonalDescendingLineIn: positions).! !
!TerniLapilliGame methodsFor: 'private testing' stamp: 'D 10/15/2019 19:30:22'!
diagonalAscendingLineIn: positions

	^ (positions includes: 0@0) and: ((positions includes: 1@1) and: (positions includes: 2@2)).! !
!TerniLapilliGame methodsFor: 'private testing' stamp: 'D 10/15/2019 19:30:38'!
diagonalDescendingLineIn: positions

	^ (positions includes: 0@0) and: ((positions includes: 1@1) and: (positions includes: 2@2)).! !
!TerniLapilliGame methodsFor: 'private testing' stamp: 'D 10/15/2019 19:31:01' prior: 50752328!
diagonalDescendingLineIn: positions

	^ (positions includes: 0@2) and: ((positions includes: 1@1) and: (positions includes: 2@0)).! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:32:56'!
test38PlayerOCannotPlaceWhenGameIsOver

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 0@0.
	game putOAt: 0@2.
	game putXAt: 2@2.
		
	self assert: (game isOver).
	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:34:07' prior: 50752343!
test38PlayerOCannotPlaceWhenGameIsOver

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 0@0.
	game putOAt: 0@2.
	game putXAt: 2@2.
		
	self should: [ game putOAt: 1@0 ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayWhenGameIsOverError.
	
	self assert: (game isXCell: 2@2).
	self deny: (game isXCell: 2@0).
	self assert: game isPlayingX.

	self assert: (game isOver).
	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:34:42' prior: 50752353!
test38PlayerOCannotPlaceWhenGameIsOver

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 0@0.
	game putOAt: 0@2.
	game putXAt: 2@2.
		
	self should: [ game putOAt: 1@0 ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayWhenGameIsOverError.
	
	self deny: (game isOCell: 1@0).! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 19:34:55'!
playerCannotPlayWhenGameIsOverError
	self shouldBeImplemented.! !
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/15/2019 19:35:34' prior: 50752386!
playerCannotPlayWhenGameIsOverError
	^ 'You cannot play when game is over' ! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/15/2019 19:36:52' prior: 50751283!
putOAt: aCell

	self isPlayingX ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].
	self checkValidationOfCell: aCell withError: self class cellNotValidError .
	oChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].
	
	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGame methodsFor: 'private testing' stamp: 'D 10/15/2019 19:38:34' prior: 50752224!
canWinWithPositions: positions

	^ (positions size = 3) and: ((self verticalLineIn: positions) or: ((self horizontalLineIn: positions) or: (self diagonalLineIn: positions))).! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:41:11'!
test39PlayerXCannotSlideWhenGameIsOver

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 0@0.
	game putOAt: 0@2.
	game putXAt: 1@2.
	game putOAt: 0@0.
	
	self should: [game slideXFrom: 1@2 to:  2@2]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayWhenGameIsOverError.
	
	self deny: (game isXCell: 2@2).! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:41:44' prior: 50752425!
test39PlayerXCannotSlideWhenGameIsOver

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 1@0.
	game putOAt: 0@2.
	game putXAt: 1@2.
	game putOAt: 0@0.
	
	self should: [game slideXFrom: 1@2 to:  2@2]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayWhenGameIsOverError.
	
	self deny: (game isXCell: 2@2).! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:42:30' prior: 50752441!
test39PlayerXCannotSlideWhenGameIsOver

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 2@0.
	game putOAt: 0@2.
	game putXAt: 1@2.
	game putOAt: 0@0.
	
	self should: [game slideXFrom: 1@2 to:  2@2]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayWhenGameIsOverError.
	
	self deny: (game isXCell: 2@2).! !

----SNAPSHOT----(15 October 2019 19:43:45) clase2.image priorSource: 13446293!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:51:51'!
test39PlayerOCannotSlideWhenGameIsOver

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 0@2.
	game putOAt: 0@1.
	game putXAt: 1@2.
	game putOAt: 1@1.
	game putXAt: 2@1.
	game putOAt: 0@0.
	game slideXFrom: 2@1 to: 2@2.
	
	self should: [game slideOFrom: 1@1 to:  2@0]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayWhenGameIsOverError.
	
	self deny: (game isOCell: 2@0).! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:52:17' prior: 50752475!
test39PlayerOCannotSlideWhenGameIsOver

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 0@2.
	game putOAt: 0@1.
	game putXAt: 1@2.
	game putOAt: 1@1.
	game putXAt: 2@1.
	game putOAt: 0@0.
	game slideXFrom: 2@1 to: 2@2.
	
	self should: [game slideOFrom: 1@1 to:  2@0]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayWhenGameIsOverError.
	
	self deny: (game isOCell: 2@0).
	self assert: (game isOCell: 1@1).! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:52:23'!
test40PlayerOCannotSlideWhenGameIsOver

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 0@2.
	game putOAt: 0@1.
	game putXAt: 1@2.
	game putOAt: 1@1.
	game putXAt: 2@1.
	game putOAt: 0@0.
	game slideXFrom: 2@1 to: 2@2.
	
	self should: [game slideOFrom: 1@1 to:  2@0]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayWhenGameIsOverError.
	
	self deny: (game isOCell: 2@0).
	self assert: (game isOCell: 1@1).! !

TerniLapilliGameTest removeSelector: #test39PlayerOCannotSlideWhenGameIsOver!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:52:44' prior: 50752457!
test39PlayerXCannotSlideWhenGameIsOver

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 2@0.
	game putOAt: 0@2.
	game putXAt: 1@2.
	game putOAt: 0@0.
	
	self should: [game slideXFrom: 1@2 to:  2@2]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayWhenGameIsOverError.
	
	self deny: (game isXCell: 2@2).
	self assert: (game isXCell: 1@2).! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/15/2019 19:55:09' prior: 50752111!
slideXFrom: originCell to: destinyCell 
	
	self isPlayingO ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
	
	
	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	
	xChips remove: originCell.
	xChips add: destinyCell.
	turn := #O.! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/15/2019 19:55:32' prior: 50752144!
slideOFrom: originCell to: destinyCell 

	self isPlayingX ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].

	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].


	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	
	oChips remove: originCell .
	oChips  add: destinyCell.
	turn := #X.! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/15/2019 19:55:44' prior: 50752583!
slideOFrom: originCell to: destinyCell 

	self isPlayingX ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].

	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].


	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	
	oChips remove: originCell .
	oChips  add: destinyCell.
	turn := #X.! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/15/2019 19:55:47' prior: 50752615!
slideOFrom: originCell to: destinyCell 

	self isPlayingX ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].


	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	
	oChips remove: originCell .
	oChips  add: destinyCell.
	turn := #X.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:57:13'!
test41PlayerXHasWon

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game putXAt: 0@0.
	
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:57:34' prior: 50752685!
test41PlayerXHasWon

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game putXAt: 0@0.
	
	self assert: game hasWonX.
	
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:57:42'!
hasWonX
	self shouldBeImplemented.! !
!TerniLapilliGame methodsFor: 'private testing' stamp: 'D 10/15/2019 19:58:25'!
hasWonO
	^ self canWinWithPositions: oChips.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:58:25' prior: 50752205!
isOver
	^ self xWon or: self hasWonO.! !

TerniLapilliGame removeSelector: #oWon!

TerniLapilliGame removeSelector: #hasWonX!
!TerniLapilliGame methodsFor: 'private testing' stamp: 'D 10/15/2019 19:59:03'!
hasWonX
	^ self canWinWithPositions: xChips.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 19:59:03' prior: 50752712!
isOver
	^ self hasWonX or: self hasWonO.! !

TerniLapilliGame removeSelector: #xWon!
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 20:00:20'!
test42PlayerOHasWon

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@0.
	game putOAt: 1@1.
	game putXAt: 2@0.
	game putOAt: 2@2.
	game putXAt: 0@1.
	game putOAt: 0@0.
	
	self assert: game hasWonX.
	
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/15/2019 20:00:28' prior: 50752730!
test42PlayerOHasWon

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@0.
	game putOAt: 1@1.
	game putXAt: 2@0.
	game putOAt: 2@2.
	game putXAt: 0@1.
	game putOAt: 0@0.
	
	self assert: game hasWonO.
	
! !

----SNAPSHOT----(15 October 2019 20:02:25) clase2.image priorSource: 13466281!

----QUIT----(15 October 2019 20:02:38) clase2.image priorSource: 13475157!

----STARTUP---- (16 October 2019 15:08:59) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!

!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:13:20'!
test43GameIsTied

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@0.
	game putOAt: 1@1.
	game putXAt: 2@0.
	game putOAt: 2@2.

	
	self assert: game isTied.
	
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:13:54' prior: 50752694!
test41PlayerXHasWon

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game putXAt: 0@0.
	
	self assert: game hasWonX.
	self deny: game hasWonO.
	
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:14:13' prior: 50752740!
test42PlayerOHasWon

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@0.
	game putOAt: 1@1.
	game putXAt: 2@0.
	game putOAt: 2@2.
	game putXAt: 0@1.
	game putOAt: 0@0.
	
	self assert: game hasWonO.
	self deny: game hasWonX.
	
! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:14:37'!
isTied
	self shouldBeImplemented.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:14:56' prior: 50752789!
isTied
	^ self isOver not.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:15:59' prior: 50752260!
test35GameIsOverWithHorizontalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	
	self assert: (game isOver).
	self deny: game isTied.
	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:16:07' prior: 50752799!
test35GameIsOverWithHorizontalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	
	self assert: game isOver.
	self deny: game isTied.
	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:16:16' prior: 50752282!
test36GameIsOverWithVerticalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 1@2.
	game putOAt: 0@2.
	game putXAt: 1@0.
	
	self assert: (game isOver).
	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:16:31' prior: 50752821!
test36GameIsOverWithVerticalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 1@2.
	game putOAt: 0@2.
	game putXAt: 1@0.
	
	self assert: game isOver.
	self deny: game isTied.
	
	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:16:39' prior: 50752302!
test37GameIsOverWithDiagonalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 0@0.
	game putOAt: 0@2.
	game putXAt: 2@2.
	
	self assert: game isOver.
	self deny: game isTied.
	
	! !

Object subclass: #TerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliGameState category: #TerniLapilli!
Object subclass: #TerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TerniLapilliGameState subclass: #PlacingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #PlacingChipsTerniLapilliGameState category: #TerniLapilli!
TerniLapilliGameState subclass: #PlacingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TerniLapilliGameState subclass: #SlidingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #SlidingChipsTerniLapilliGameState category: #TerniLapilli!
TerniLapilliGameState subclass: #SlidingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TerniLapilliGameState subclass: #GameOverTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #GameOverTerniLapilliGameState category: #TerniLapilli!
TerniLapilliGameState subclass: #GameOverTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

Object subclass: #TerniLapilliTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliTurnState category: #TerniLapilli!
Object subclass: #TerniLapilliTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TerniLapilliTurnState subclass: #XTerniLapilliTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #XTerniLapilliTurnState category: #TerniLapilli!
TerniLapilliTurnState subclass: #XTerniLapilliTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TerniLapilliTurnState subclass: #OTerniLapilliTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #OTerniLapilliTurnState category: #TerniLapilli!
TerniLapilliTurnState subclass: #OTerniLapilliTurnState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliGame methodsFor: 'initialization' stamp: 'D 10/16/2019 15:43:28' prior: 50748850!
initialize

	turn := #X.
	xChips := OrderedCollection new.
	oChips := OrderedCollection new.! !

!classDefinition: #TerniLapilliGame category: #TerniLapilli!
Object subclass: #TerniLapilliGame
	instanceVariableNames: 'turn xChips oChips turnState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:44:13' prior: 50749120!
isPlayingX
	
	^ turnState = #X.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:44:13' prior: 50752650!
slideOFrom: originCell to: destinyCell 

	self isPlayingX ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].


	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	
	oChips remove: originCell .
	oChips  add: destinyCell.
	turnState := #X.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:44:13' prior: 50752548!
slideXFrom: originCell to: destinyCell 
	
	self isPlayingO ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
	
	
	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	
	xChips remove: originCell.
	xChips add: destinyCell.
	turnState := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:44:13' prior: 50752937!
initialize

	turnState := #X.
	xChips := OrderedCollection new.
	oChips := OrderedCollection new.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:44:13' prior: 50752398!
putOAt: aCell

	self isPlayingX ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].
	self checkValidationOfCell: aCell withError: self class cellNotValidError .
	oChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].
	
	turnState := #X.
	oChips add: aCell.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 15:44:13' prior: 50751449!
putXAt: aCell
	
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	self checkValidationOfCell: aCell withError: self class cellNotValidError.
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].
	
	xChips add: aCell .
	turnState := #O.
! !

!classDefinition: #TerniLapilliGame category: #TerniLapilli!
Object subclass: #TerniLapilliGame
	instanceVariableNames: 'xChips oChips turnState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

Object subclass: #TerniLapilliGame
	instanceVariableNames: 'xChips oChips turnState gameState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliGame category: #TerniLapilli!
Object subclass: #TerniLapilliGame
	instanceVariableNames: 'xChips oChips turnState gameState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliGame methodsFor: 'initialization' stamp: 'D 10/16/2019 15:45:22' prior: 50753026!
initialize

	turnState := #X.
	gameState := PlacingChipsTerniLapilliGameState new.
	xChips := OrderedCollection new.
	oChips := OrderedCollection new.! !
!TerniLapilliGame methodsFor: 'initialization' stamp: 'D 10/16/2019 15:45:37' prior: 50753087!
initialize

	turnState := XTerniLapilliTurnState new.
	gameState := PlacingChipsTerniLapilliGameState new.
	xChips := OrderedCollection new.
	oChips := OrderedCollection new.! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 16:09:46' prior: 50753052!
putXAt: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].

	"turnState := turnState canHandlePutX

	gameState := gameState putXAt: aCell atGame: self."
	
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	
	
	xChips add: aCell .
	turnState := #O.
! !

!classDefinition: #TerniLapilliGame category: #TerniLapilli!
Object subclass: #TerniLapilliGame
	instanceVariableNames: 'xChips oChips turnState gameState turn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:09:57' prior: 50752951!
isPlayingX
	
	^ turn = #X.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:09:57' prior: 50752956!
slideOFrom: originCell to: destinyCell 

	self isPlayingX ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].


	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	
	oChips remove: originCell .
	oChips  add: destinyCell.
	turn := #X.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:09:57' prior: 50752991!
slideXFrom: originCell to: destinyCell 
	
	self isPlayingO ifTrue: [ self error: self class playerCannotSlideWhenIsNotTheirTurnError ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
	
	
	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	
	xChips remove: originCell.
	xChips add: destinyCell.
	turn := #O.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:09:57' prior: 50753095!
initialize

	turn := XTerniLapilliTurnState new.
	gameState := PlacingChipsTerniLapilliGameState new.
	xChips := OrderedCollection new.
	oChips := OrderedCollection new.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:09:57' prior: 50753033!
putOAt: aCell

	self isPlayingX ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].
	self checkValidationOfCell: aCell withError: self class cellNotValidError .
	oChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].
	
	turn := #X.
	oChips add: aCell.! !
!TerniLapilliGame methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:09:57' prior: 50753104!
putXAt: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].

	"turnState := turnState canHandlePutX

	gameState := gameState putXAt: aCell atGame: self."
	
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	
	
	xChips add: aCell .
	turn := #O.
! !

!classDefinition: #TerniLapilliGame category: #TerniLapilli!
Object subclass: #TerniLapilliGame
	instanceVariableNames: 'xChips oChips gameState turn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 16:10:35' prior: 50753234!
putXAt: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].

	"turnState := turnState canHandlePutX

	gameState := gameState putXAt: aCell atGame: self."
	
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	
	
	xChips add: aCell .
	turn := #O.
! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 16:13:03' prior: 50753260!
putXAt: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].

	turn := turn canHandlePutX.

	gameState := gameState putXAt: aCell atGame: self.
	
"	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	
"	
	xChips add: aCell .
	"turn := OTurnTerniLapilli new."
! !

TurnTerniLapilli subclass: #OTurnTerniLapilli
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #OTurnTerniLapilli category: #TerniLapilli!
TurnTerniLapilli subclass: #OTurnTerniLapilli
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

Smalltalk removeClassNamed: #OTerniLapilliTurnState!

TurnTerniLapilli subclass: #XTurnTerniLapilli
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #XTurnTerniLapilli category: #TerniLapilli!
TurnTerniLapilli subclass: #XTurnTerniLapilli
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!TerniLapilliGame methodsFor: 'initialization' stamp: 'D 10/16/2019 16:15:32' prior: 50753206!
initialize

	turn := XTurnTerniLapilli new.
	gameState := PlacingChipsTerniLapilliGameState new.
	xChips := OrderedCollection new.
	oChips := OrderedCollection new.! !

Smalltalk removeClassNamed: #XTerniLapilliTurnState!
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 16:17:20' prior: 50753279!
putXAt: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].

	turn isXTurn.

	gameState := gameState putXAt: aCell atGame: self.
	
"	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	
"	
	xChips add: aCell .
	"turn := OTurnTerniLapilli new."
! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 16:20:02' prior: 50753332!
putXAt: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].

	turn checkIfItIsXTurn.

	gameState := gameState putXAt: aCell atGame: self.
	
"	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	
"	
	xChips add: aCell .
	"turn := OTurnTerniLapilli new."
! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 16:20:44' prior: 50753351!
putXAt: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].

	turn checkIfItIsXTurn.

	gameState := gameState putXAt: aCell atGame: self.
	
"	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	
	
	xChips add: aCell ."
	turn := OTurnTerniLapilli new.
! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 16:20:48' prior: 50753370!
putXAt: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].

	turn checkIfItIsXTurn.

	gameState := gameState putXAt: aCell atGame: self.
	
"	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError. ].
	
	xChips size = 3 ifTrue: [self error: self class playerCannotPlaceMoreThanThreeChips. ].
	
	
	xChips add: aCell ."

	turn := OTurnTerniLapilli new.
! !
!XTurnTerniLapilli methodsFor: 'no messages' stamp: 'D 10/16/2019 16:22:13'!
checkIfItIsOTurn

	^ self error: TerniLapilliGame playerCannotPlayTwoTimesInARowError.! !

TerniLapilliGame class removeSelector: #playerCannotSlideWhenIsNotTheirTurnError!
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/16/2019 16:24:20' prior: 50753136!
slideOFrom: originCell to: destinyCell 

	self isPlayingX ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].


	oChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].

	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	
	oChips remove: originCell .
	oChips  add: destinyCell.
	turn := #X.! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/16/2019 16:24:31' prior: 50753171!
slideXFrom: originCell to: destinyCell 
	
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
	
	
	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	
	xChips remove: originCell.
	xChips add: destinyCell.
	turn := #O.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:24:52' prior: 50751231!
test27PlayerXCannotSlideInTheTurnOfTheOtherPlayer

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.

	self should: [ game slideXFrom: 1@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayTwoTimesInARowError .
	
	self assert: (game isXCell: 1@1).
	self deny: (game isXCell: 1@2).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:25:01' prior: 50751400!
test28PlayerOCannotSlideInTheTurnOfTheOtherPlayer

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideOFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlayTwoTimesInARowError .
	
	self assert: (game isOCell: 1@0).
	self deny: (game isOCell: 2@0).
	self assert: game isPlayingX.
! !
!TurnTerniLapilli methodsFor: 'no messages' stamp: 'D 10/16/2019 16:25:19'!
checkIfItIsXTurn! !
!TurnTerniLapilli methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:25:22'!
checkIfItIsOTurn! !
!OTurnTerniLapilli methodsFor: 'no messages' stamp: 'D 10/16/2019 16:26:08'!
checkIfItIsXTurn
	
	^ self error: TerniLapilliGame playerCannotPlayTwoTimesInARowError .! !
!TerniLapilliGameState methodsFor: 'no messages' stamp: 'D 10/16/2019 16:30:26'!
putXAt: aCell atGame: aTerniLapilliGame

	self subclassResponsibility.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'no messages' stamp: 'D 10/16/2019 16:32:27'!
putXAt: aCell atGame: aTerniLapilliGame

	! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:34:58' prior: 50753543!
putXAt: aCell atGame: aTerniLapilliGame

	aTerniLapilliGame placeXChipAt: aCell.
	
	^ PlacingChipsTerniLapilliGameState new.! !
!TerniLapilliGame methodsFor: 'private placing' stamp: 'D 10/16/2019 16:35:45'!
placeXChipAt: aCell

	xChips add: aCell.! !
!TerniLapilliGame methodsFor: 'private placing' stamp: 'D 10/16/2019 16:35:53'!
placeOChipAt: aCell

	oChips add: aCell.! !
!TerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:36:11'!
putOAt: aCell atGame: aTerniLapilliGame

	self subclassResponsibility.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:37:20'!
putOAt: aCell atGame: aTerniLapilliGame

	aTerniLapilliGame placeOChipAt: aCell.
	
	aTerniLapilliGame amountOfXChips = 3 ifTrue: [ ^ SlidingChipsTerniLapilliGameState ].
	
	^ PlacingChipsTerniLapilliGameState new.! !
!TerniLapilliGame methodsFor: 'private accessing' stamp: 'D 10/16/2019 16:38:10'!
amountOfXChips

	^ xChips size.! !
!TerniLapilliGame methodsFor: 'private accessing' stamp: 'D 10/16/2019 16:38:18'!
amountOfOChips

	^ oChips size.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:38:37' prior: 50753571!
putOAt: aCell atGame: aTerniLapilliGame

	aTerniLapilliGame placeOChipAt: aCell.
	
	aTerniLapilliGame amountOfXChips = 3 ifTrue: [ ^ SlidingChipsTerniLapilliGameState new ].
	
	^ PlacingChipsTerniLapilliGameState new.! !
!GameOverTerniLapilliGameState methodsFor: 'no messages' stamp: 'D 10/16/2019 16:39:27'!
putOAt: aCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayWhenGameIsOverError .! !
!GameOverTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:39:33'!
putXAt: aCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayWhenGameIsOverError .! !
!SlidingChipsTerniLapilliGameState methodsFor: 'no messages' stamp: 'D 10/16/2019 16:40:12'!
putOAt: aCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlaceMoreThanThreeChips .! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:40:18'!
putXAt: aCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlaceMoreThanThreeChips .! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 16:41:10' prior: 50753389!
putXAt: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].

	turn checkIfItIsXTurn.

	gameState := gameState putXAt: aCell atGame: self.

	turn := OTurnTerniLapilli new.
! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 16:42:59' prior: 50753215!
putOAt: aCell

	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].

	turn checkIfItIsOTurn.

	gameState := gameState putOAt: aCell atGame: self.

	turn := XTurnTerniLapilli new.
! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 16:43:33' prior: 50753640!
putOAt: aCell

	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].

	turn checkIfItIsOTurn.

	gameState := gameState putOAt: aCell atGame: self.

	turn := XTurnTerniLapilli new.
 ! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/16/2019 16:50:31' prior: 50753452!
slideXFrom: originCell to: destinyCell 
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
		
	turn checkIfItIsXTurn.

	gameState := gameState slideXFrom: originCell to: destinyCell atGame: self.

"	
	self isPlayingO ifTrue: [ self error: self class playerCannotPlayTwoTimesInARowError ].
	self isOver ifTrue: [self error: self class playerCannotPlayWhenGameIsOverError. ].	
	xChips size < 3 ifTrue: [ self error: self class playerCannotSlideBeforePlacingThreeChipsError. ]. 

	xChips remove: originCell.
	xChips add: destinyCell.
"
	turn := OTurnTerniLapilli new.! !
!TerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:51:28'!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self subclassResponsibility .! !
!TerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:51:34'!
slideOFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self subclassResponsibility .! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:54:12'!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	aTerniLapilliGame slideXChipFrom: originCell to: destinyCell.
	
	aTerniLapilliGame isOver ifTrue: [ ^ GameOverTerniLapilliGameState new ].
	
	^ SlidingChipsTerniLapilliGameState new.! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:54:59'!
slideOFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	aTerniLapilliGame slideOChipFrom: originCell to: destinyCell.
	
	aTerniLapilliGame isOver ifTrue: [ ^ GameOverTerniLapilliGameState new ].
	
	^ SlidingChipsTerniLapilliGameState new.! !
!TerniLapilliGame methodsFor: 'private sliding' stamp: 'D 10/16/2019 16:56:24'!
slideXChipFrom: originCell to: destinyCell

	xChips remove: originCell.
	xChips add: destinyCell.! !
!TerniLapilliGame methodsFor: 'private sliding' stamp: 'D 10/16/2019 16:56:39'!
slideOChipFrom: originCell to: destinyCell

	oChips remove: originCell.
	oChips add: destinyCell.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:57:45'!
slideOFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotSlideBeforePlacingThreeChipsError.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:57:50'!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotSlideBeforePlacingThreeChipsError.! !
!GameOverTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:58:30'!
slideOFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayWhenGameIsOverError.! !
!GameOverTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 16:58:35'!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayWhenGameIsOverError.! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/16/2019 17:06:02' prior: 50753664!
slideXFrom: originCell to: destinyCell 
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
		
	turn checkIfItIsXTurn.

	gameState := gameState slideXFrom: originCell to: destinyCell atGame: self.

	turn := OTurnTerniLapilli new.! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/16/2019 17:06:39' prior: 50753417!
slideOFrom: originCell to: destinyCell 

	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkValidationOfCell: destinyCell withError: self class playerCannotSlideChipToAnInvalidPositionError .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	(oChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
		
	turn checkIfItIsOTurn.

	gameState := gameState slideOFrom: originCell to: destinyCell atGame: self.

	turn := XTurnTerniLapilli new.! !

----SNAPSHOT----(16 October 2019 17:06:53) clase2.image priorSource: 13475237!

----QUIT----(16 October 2019 17:06:57) clase2.image priorSource: 13510008!

----STARTUP---- (16 October 2019 17:09:52) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!

!TerniLapilliGame methodsFor: 'testing' stamp: 'D 10/16/2019 17:11:30' prior: 50753131!
isPlayingX
	
	^ turn isXTurn.! !
!XTurnTerniLapilli methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 17:11:55'!
isXTurn
^ true.! !
!XTurnTerniLapilli methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 17:11:58' prior: 50753851!
isXTurn
	
	^ true.! !
!OTurnTerniLapilli methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 17:12:09'!
isXTurn
	
	^ false.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 17:15:49' prior: 50753549!
putXAt: aCell atGame: aTerniLapilliGame

	aTerniLapilliGame placeXChipAt: aCell.
	
	aTerniLapilliGame isOver ifTrue: [ ^ GameOverTerniLapilliGameState new. ].
	
	^ PlacingChipsTerniLapilliGameState new.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 17:16:28' prior: 50753590!
putOAt: aCell atGame: aTerniLapilliGame

	aTerniLapilliGame placeOChipAt: aCell.
	
	aTerniLapilliGame isOver ifTrue: [ ^ GameOverTerniLapilliGameState new. ].
	
	aTerniLapilliGame amountOfXChips = 3 ifTrue: [ ^ SlidingChipsTerniLapilliGameState new ].
	
	^ PlacingChipsTerniLapilliGameState new.! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 17:23:46'!
checkIfIsAnInRangeEmptyCell: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].
! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 17:24:22' prior: 50753652!
putOAt: aCell

	self checkIfIsAnInRangeEmptyCell: aCell.
	
	turn checkIfItIsOTurn.

	gameState := gameState putOAt: aCell atGame: self.

	turn := XTurnTerniLapilli new.
 ! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/16/2019 17:24:30' prior: 50753628!
putXAt: aCell
	
	self checkIfIsAnInRangeEmptyCell: aCell.

	turn checkIfItIsXTurn.

	gameState := gameState putXAt: aCell atGame: self.

	turn := OTurnTerniLapilli new.
! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/16/2019 17:26:47' prior: 50753783!
slideXFrom: originCell to: destinyCell 
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkIfIsAnInRangeEmptyCell: destinyCell.
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
	(self isEmptyCell: destinyCell) ifFalse: [self error: self class playerCannotSlideChipToAnOccupiedPositionError . ].
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
		
	turn checkIfItIsXTurn.

	gameState := gameState slideXFrom: originCell to: destinyCell atGame: self.

	turn := OTurnTerniLapilli new.! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/16/2019 17:27:57' prior: 50753915!
slideXFrom: originCell to: destinyCell 
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	self checkIfIsAnInRangeEmptyCell: destinyCell.
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
		
	turn checkIfItIsXTurn.

	gameState := gameState slideXFrom: originCell to: destinyCell atGame: self.

	turn := OTurnTerniLapilli new.! !
!TerniLapilliGame methodsFor: 'private validations' stamp: 'D 10/16/2019 17:29:07'!
checkIfIsAnInRangeOccupiedByXCell: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].
! !
!TerniLapilliGame methodsFor: 'private validations' stamp: 'D 10/16/2019 17:29:10'!
checkIfIsAnInRangeOccupiedByOCell: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError.

	(self isEmptyCell: aCell) ifFalse: [ self error: self class cellOccupiedError. ].
! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/16/2019 17:29:31' prior: 50753941!
slideXFrom: originCell to: destinyCell 
	
	self checkValidationOfCell: originCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	(xChips includes: originCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
	self checkIfIsAnInRangeEmptyCell: destinyCell.
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
		
	turn checkIfItIsXTurn.

	gameState := gameState slideXFrom: originCell to: destinyCell atGame: self.

	turn := OTurnTerniLapilli new.! !
!TerniLapilliGame methodsFor: 'private validations' stamp: 'D 10/16/2019 17:29:52' prior: 50753963!
checkIfIsAnInRangeOccupiedByXCell: aCell
	
	self checkValidationOfCell: aCell withError: self class playerCannotSlideChipFromAnInvalidPositionError .
	(xChips includes: aCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
! !
!TerniLapilliGame methodsFor: 'private validations' stamp: 'D 10/16/2019 17:30:45' prior: 50754006!
checkIfIsAnInRangeOccupiedByXCell: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError .
	(xChips includes: aCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
! !
!TerniLapilliGame methodsFor: 'private validations' stamp: 'D 10/16/2019 17:31:05' prior: 50753973!
checkIfIsAnInRangeOccupiedByOCell: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError .
	(xChips includes: aCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
! !
!TerniLapilliGame methodsFor: 'private validations' stamp: 'D 10/16/2019 17:31:11' prior: 50754029!
checkIfIsAnInRangeOccupiedByOCell: aCell
	
	self checkValidationOfCell: aCell withError: self class cellNotValidError .
	(oChips includes: aCell) ifFalse: [self error: self class playerCannotSlideChipFromAPositionNotOwnedError. ].
! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/16/2019 17:31:48' prior: 50753983!
slideXFrom: originCell to: destinyCell 
	
	self checkIfIsAnInRangeOccupiedByXCell: originCell.
	self checkIfIsAnInRangeEmptyCell: destinyCell.
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
		
	turn checkIfItIsXTurn.

	gameState := gameState slideXFrom: originCell to: destinyCell atGame: self.

	turn := OTurnTerniLapilli new.! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/16/2019 17:32:51' prior: 50753811!
slideOFrom: originCell to: destinyCell 

	self checkIfIsAnInRangeOccupiedByOCell: originCell.
	self checkIfIsAnInRangeEmptyCell: destinyCell .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
		
	turn checkIfItIsOTurn.

	gameState := gameState slideOFrom: originCell to: destinyCell atGame: self.

	turn := XTurnTerniLapilli new.! !
!TerniLapilliGame methodsFor: 'private testing' stamp: 'D 10/16/2019 17:35:25'!
areNeighbouringCells: aCell with: anotherCell
	
	^ (aCell dist: anotherCell) floor = 1! !
!TerniLapilliGame methodsFor: 'private testing' stamp: 'D 10/16/2019 17:36:07' prior: 50751932!
connectedByLineFrom: originCell to: destinyCell
	
	^ (self areNeighbouringCells: originCell with: destinyCell) and: (self allowedMoveByLinesFrom: originCell to: destinyCell).! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 17:36:56' prior: 50750448!
test19PlayerXCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: -1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError.
	
	self deny: (game isXCell: 2@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 17:37:10' prior: 50750570!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: -2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError .
	
	self deny: (game isOCell: 2@1).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 17:37:21' prior: 50750792!
test21PlayerXCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: -2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError .
	
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 17:37:29' prior: 50750773!
test22PlayerOCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: -2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError .
	
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 17:37:38' prior: 50750866!
test25PlayerXCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: 1@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellOccupiedError .
	
	self assert: (game isXCell: 1@1).
	self assert: (game isOCell: 1@0).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/16/2019 17:37:45' prior: 50751138!
test26PlayerOCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellOccupiedError .
	
	self assert: (game isOCell: 1@0).
	self assert: (game isXCell: 1@1).
	self assert: game isPlayingO.
! !

----SNAPSHOT----(16 October 2019 17:39:56) clase2.image priorSource: 13510088!

----QUIT----(16 October 2019 17:40:01) clase2.image priorSource: 13521763!

----STARTUP---- (17 October 2019 13:33:22) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!


----QUIT----(17 October 2019 13:35:00) clase2.image priorSource: 13521843!

----STARTUP---- (17 October 2019 15:10:26) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!


----SNAPSHOT----(17 October 2019 15:11:09) clase2.image priorSource: 13522025!

TerniLapilliGameState subclass: #OPlacingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #OPlacingChipsTerniLapilliGameState category: #TerniLapilli!
TerniLapilliGameState subclass: #OPlacingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TerniLapilliGameState subclass: #XPlacingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #XPlacingChipsTerniLapilliGameState category: #TerniLapilli!
TerniLapilliGameState subclass: #XPlacingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

Smalltalk removeClassNamed: #XPlacingChipsTerniLapilliGameState!

Smalltalk removeClassNamed: #OPlacingChipsTerniLapilliGameState!

PlacingChipsTerniLapilliGameState subclass: #OPlacingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #OPlacingChipsTerniLapilliGameState category: #TerniLapilli!
PlacingChipsTerniLapilliGameState subclass: #OPlacingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

PlacingChipsTerniLapilliGameState subclass: #XPlacingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #XPlacingChipsTerniLapilliGameState category: #TerniLapilli!
PlacingChipsTerniLapilliGameState subclass: #XPlacingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TerniLapilliGameState subclass: #OSlidingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #OSlidingChipsTerniLapilliGameState category: #TerniLapilli!
TerniLapilliGameState subclass: #OSlidingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

TerniLapilliGameState subclass: #XSlidingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #XSlidingChipsTerniLapilliGameState category: #TerniLapilli!
TerniLapilliGameState subclass: #XSlidingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

Smalltalk removeClassNamed: #XSlidingChipsTerniLapilliGameState!

Smalltalk removeClassNamed: #OSlidingChipsTerniLapilliGameState!

SlidingChipsTerniLapilliGameState subclass: #XSlidingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #XSlidingChipsTerniLapilliGameState category: #TerniLapilli!
SlidingChipsTerniLapilliGameState subclass: #XSlidingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

SlidingChipsTerniLapilliGameState subclass: #OSlidingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #OSlidingChipsTerniLapilliGameState category: #TerniLapilli!
SlidingChipsTerniLapilliGameState subclass: #OSlidingChipsTerniLapilliGameState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!OSlidingChipsTerniLapilliGameState methodsFor: 'no messages' stamp: 'D 10/17/2019 15:22:20'!
putXAt: aCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayTwoTimesInARowError .! !
!XSlidingChipsTerniLapilliGameState methodsFor: 'no messages' stamp: 'D 10/17/2019 15:22:30'!
putXAt: aCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayTwoTimesInARowError .! !
!XSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:22:35'!
putOAt: aCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayTwoTimesInARowError .! !

XSlidingChipsTerniLapilliGameState removeSelector: #putXAt:atGame:!
!OSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:24:43'!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayTwoTimesInARowError .! !
!OSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:25:13'!
slideOFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	aTerniLapilliGame slideOChipFrom: originCell to: destinyCell.
	
	aTerniLapilliGame isOver ifTrue: [ ^ GameOverTerniLapilliGameState new ].
	
	^ XSlidingChipsTerniLapilliGameState new.! !
!XSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:25:32'!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	aTerniLapilliGame slideXChipFrom: originCell to: destinyCell.
	
	aTerniLapilliGame isOver ifTrue: [ ^ GameOverTerniLapilliGameState new ].
	
	^ OSlidingChipsTerniLapilliGameState new.! !
!XSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:25:58'!
slideOFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayTwoTimesInARowError .! !
!OPlacingChipsTerniLapilliGameState methodsFor: 'no messages' stamp: 'D 10/17/2019 15:26:55'!
putOAt: aCell atGame: aTerniLapilliGame

	aTerniLapilliGame placeOChipAt: aCell.
	
	aTerniLapilliGame isOver ifTrue: [ ^ GameOverTerniLapilliGameState new. ].
	
	aTerniLapilliGame amountOfXChips = 3 ifTrue: [ ^ SlidingChipsTerniLapilliGameState new ].
	
	^ XPlacingChipsTerniLapilliGameState new.! !
!OPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:27:25'!
putXAt: aCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayTwoTimesInARowError.! !
!XPlacingChipsTerniLapilliGameState methodsFor: 'no messages' stamp: 'D 10/17/2019 15:29:19'!
putXAt: aCell atGame: aTerniLapilliGame

	aTerniLapilliGame placeXChipAt: aCell.
	
	aTerniLapilliGame isOver ifTrue: [ ^ GameOverTerniLapilliGameState new. ].
		
	^ OPlacingChipsTerniLapilliGameState new.! !
!XPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:30:29'!
putOAt: aCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayTwoTimesInARowError .! !
!XPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:31:22'!
slideOFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayTwoTimesInARowError.! !
!OPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:31:38'!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlayTwoTimesInARowError .! !

TerniLapilliGame class removeSelector: #playerCannotSlideChipFromAnInvalidPositionError!

TerniLapilliGame class removeSelector: #playerCannotSlideChipToAnInvalidPositionError!

TerniLapilliGame class removeSelector: #playerCannotSlideChipToAnOccupiedPositionError!
!TerniLapilliGame class methodsFor: 'error messages' stamp: 'D 10/17/2019 15:33:04' prior: 50749961!
playerCannotSlideChipFromAPositionNotOwnedError
	^ 'You cannot slide a chip from a position you do not own'! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/17/2019 15:33:45' prior: 50753897!
putOAt: aCell

	self checkIfIsAnInRangeEmptyCell: aCell.

	gameState := gameState putOAt: aCell atGame: self.
 ! !
!TerniLapilliGame methodsFor: 'placing' stamp: 'D 10/17/2019 15:34:31' prior: 50753906!
putXAt: aCell
	
	self checkIfIsAnInRangeEmptyCell: aCell.

	gameState := gameState putXAt: aCell atGame: self.! !
!TerniLapilliGame methodsFor: 'testing' stamp: 'D 10/17/2019 15:36:42' prior: 50753847!
isPlayingX
	
	^ gameState isPlayingX.! !
!GameOverTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:37:19'!
isPlayingX

	^ false.! !
!GameOverTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:37:22'!
isPlayingO

	^ false.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:38:19'!
isPlayingO
	
	self subclassResponsibility ! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:38:22'!
isPlayingX
	
	self subclassResponsibility ! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:38:28'!
isPlayingO
	
	self subclassResponsibility ! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:38:36'!
isPlayingX
	
	self subclassResponsibility ! !
!OPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:39:03'!
isPlayingX

	^ false.! !
!OPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:39:16'!
isPlayingO

	^ true.! !
!XPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:39:34'!
isPlayingX

	^ true.! !
!XPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:39:37'!
isPlayingO

	^ false.! !
!OSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:39:51'!
isPlayingX

	^ false.! !
!OSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:40:02'!
isPlayingO

	^ true.! !
!XSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:40:08'!
isPlayingO

	^ false.! !
!XSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:40:14'!
isPlayingX

	^ true.! !
!TerniLapilliGame methodsFor: 'testing' stamp: 'D 10/17/2019 15:40:51' prior: 50749125!
isPlayingO

	^ gameState isPlayingO.! !
!TerniLapilliGame methodsFor: 'testing' stamp: 'D 10/17/2019 15:41:26'!
isGameOver
	^ self hasWonX or: self hasWonO.! !
!TerniLapilliGame methodsFor: 'testing' stamp: 'D 10/17/2019 15:42:23' prior: 50752724!
isOver
	^ gameState isOver.! !
!XPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:43:16' prior: 50754421!
putXAt: aCell atGame: aTerniLapilliGame

	aTerniLapilliGame placeXChipAt: aCell.
	
	aTerniLapilliGame isGameOver ifTrue: [ ^ GameOverTerniLapilliGameState new. ].
		
	^ OPlacingChipsTerniLapilliGameState new.! !
!OPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:43:32' prior: 50754401!
putOAt: aCell atGame: aTerniLapilliGame

	aTerniLapilliGame placeOChipAt: aCell.
	
	aTerniLapilliGame isGameOver ifTrue: [ ^ GameOverTerniLapilliGameState new. ].
	
	aTerniLapilliGame amountOfXChips = 3 ifTrue: [ ^ SlidingChipsTerniLapilliGameState new ].
	
	^ XPlacingChipsTerniLapilliGameState new.! !
!OSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:43:41' prior: 50754369!
slideOFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	aTerniLapilliGame slideOChipFrom: originCell to: destinyCell.
	
	aTerniLapilliGame isGameOver ifTrue: [ ^ GameOverTerniLapilliGameState new ].
	
	^ XSlidingChipsTerniLapilliGameState new.! !
!XSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:43:48' prior: 50754381!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	aTerniLapilliGame slideXChipFrom: originCell to: destinyCell.
	
	aTerniLapilliGame isGameOver ifTrue: [ ^ GameOverTerniLapilliGameState new ].
	
	^ OSlidingChipsTerniLapilliGameState new.! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:43:55' prior: 50753728!
slideOFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	aTerniLapilliGame slideOChipFrom: originCell to: destinyCell.
	
	aTerniLapilliGame isGameOver ifTrue: [ ^ GameOverTerniLapilliGameState new ].
	
	^ SlidingChipsTerniLapilliGameState new.! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:44:00' prior: 50753716!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	aTerniLapilliGame slideXChipFrom: originCell to: destinyCell.
	
	aTerniLapilliGame isGameOver ifTrue: [ ^ GameOverTerniLapilliGameState new ].
	
	^ SlidingChipsTerniLapilliGameState new.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:44:14' prior: 50753864!
putXAt: aCell atGame: aTerniLapilliGame

	aTerniLapilliGame placeXChipAt: aCell.
	
	aTerniLapilliGame isGameOver ifTrue: [ ^ GameOverTerniLapilliGameState new. ].
	
	^ PlacingChipsTerniLapilliGameState new.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:44:19' prior: 50753875!
putOAt: aCell atGame: aTerniLapilliGame

	aTerniLapilliGame placeOChipAt: aCell.
	
	aTerniLapilliGame isGameOver ifTrue: [ ^ GameOverTerniLapilliGameState new. ].
	
	aTerniLapilliGame amountOfXChips = 3 ifTrue: [ ^ SlidingChipsTerniLapilliGameState new ].
	
	^ PlacingChipsTerniLapilliGameState new.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:45:14' prior: 50754646!
putOAt: aCell atGame: aTerniLapilliGame

	self subclassResponsibility ! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:45:19' prior: 50754635!
putXAt: aCell atGame: aTerniLapilliGame

	self subclassResponsibility ! !
!OPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:45:34'!
slideOFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotSlideBeforePlacingThreeChipsError.! !
!XPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:45:48'!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotSlideBeforePlacingThreeChipsError.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:46:04' prior: 50753760!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self subclassResponsibility .! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:46:14' prior: 50753752!
slideOFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self subclassResponsibility .! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:46:43' prior: 50753614!
putOAt: aCell atGame: aTerniLapilliGame

	self subclassResponsibility .! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:46:56' prior: 50753621!
putXAt: aCell atGame: aTerniLapilliGame

	self subclassResponsibility .
	! !
!OSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:47:30'!
putOAt: aCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlaceMoreThanThreeChips .! !
!XSlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:47:44'!
putXAt: aCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlaceMoreThanThreeChips .! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:47:58' prior: 50754623!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self error: TerniLapilliGame playerCannotPlaceMoreThanThreeChips .! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:48:11' prior: 50754730!
slideXFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self subclassResponsibility .! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:48:17' prior: 50754611!
slideOFrom: originCell to: destinyCell atGame: aTerniLapilliGame

	self subclassResponsibility .! !
!TerniLapilliGame methodsFor: 'initialization' stamp: 'D 10/17/2019 15:49:48' prior: 50753322!
initialize

	turn := XTurnTerniLapilli new.
	gameState := XPlacingChipsTerniLapilliGameState new.
	xChips := OrderedCollection new.
	oChips := OrderedCollection new.! !
!TerniLapilliGame methodsFor: 'initialization' stamp: 'D 10/17/2019 15:49:53' prior: 50754752!
initialize

	gameState := XPlacingChipsTerniLapilliGameState new.
	xChips := OrderedCollection new.
	oChips := OrderedCollection new.! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/17/2019 15:50:16' prior: 50754068!
slideOFrom: originCell to: destinyCell 

	self checkIfIsAnInRangeOccupiedByOCell: originCell.
	self checkIfIsAnInRangeEmptyCell: destinyCell .
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].
		
	gameState := gameState slideOFrom: originCell to: destinyCell atGame: self.
! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/17/2019 15:50:25' prior: 50754051!
slideXFrom: originCell to: destinyCell 
	
	self checkIfIsAnInRangeOccupiedByXCell: originCell.
	self checkIfIsAnInRangeEmptyCell: destinyCell.
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].

	gameState := gameState slideXFrom: originCell to: destinyCell atGame: self.

	turn := OTurnTerniLapilli new.! !
!TerniLapilliGame methodsFor: 'sliding' stamp: 'D 10/17/2019 15:50:30' prior: 50754784!
slideXFrom: originCell to: destinyCell 
	
	self checkIfIsAnInRangeOccupiedByXCell: originCell.
	self checkIfIsAnInRangeEmptyCell: destinyCell.
	(self connectedByLineFrom: originCell to: destinyCell) ifFalse: [ self error: self class playerCannotSlideToAPositionNotFollowingPredefinedLinesError ].

	gameState := gameState slideXFrom: originCell to: destinyCell atGame: self.
! !

Object subclass: #TerniLapilliGame
	instanceVariableNames: 'xChips oChips gameState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!

!classDefinition: #TerniLapilliGame category: #TerniLapilli!
Object subclass: #TerniLapilliGame
	instanceVariableNames: 'xChips oChips gameState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli'!
!OPlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:51:18' prior: 50754573!
putOAt: aCell atGame: aTerniLapilliGame

	aTerniLapilliGame placeOChipAt: aCell.
	
	aTerniLapilliGame isGameOver ifTrue: [ ^ GameOverTerniLapilliGameState new. ].
	
	aTerniLapilliGame amountOfXChips = 3 ifTrue: [ ^ XSlidingChipsTerniLapilliGameState new ].
	
	^ XPlacingChipsTerniLapilliGameState new.! !
!GameOverTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:51:56'!
isOver

	^ true.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:52:08'!
isOver

	^ false.! !
!SlidingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:52:25'!
isOver

	^ false.! !
!TerniLapilliGame methodsFor: 'testing' stamp: 'D 10/17/2019 15:53:47'!
isXWinner
	^ self canWinWithPositions: xChips.! !
!TerniLapilliGame methodsFor: 'testing' stamp: 'D 10/17/2019 15:54:01'!
isOWinner
	^ self canWinWithPositions: oChips.! !
!TerniLapilliGame methodsFor: 'testing' stamp: 'D 10/17/2019 15:54:20' prior: 50752707!
hasWonO
	^ gameState hasWonO.! !
!TerniLapilliGame methodsFor: 'testing' stamp: 'D 10/17/2019 15:54:30' prior: 50752719!
hasWonX
	^ gameState hasWonX.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:54:56'!
hasWonX

	^ false.! !
!PlacingChipsTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:55:05'!
hasWonO

	^ false.! !
!TerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:55:45'!
hasWonO

	^ false.! !
!TerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:55:48'!
hasWonX

	^ false.! !

PlacingChipsTerniLapilliGameState removeSelector: #hasWonO!

PlacingChipsTerniLapilliGameState removeSelector: #hasWonX!
!TerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:56:12'!
isOver

	^ false.! !

PlacingChipsTerniLapilliGameState removeSelector: #isOver!

SlidingChipsTerniLapilliGameState removeSelector: #isOver!
!GameOverTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:57:06'!
hasWonXAtGame: aTerniLapilliGame

	^ aTerniLapilliGame isXWinner.

	! !
!GameOverTerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:57:16'!
hasWonOAtGame: aTerniLapilliGame

	^ aTerniLapilliGame isOWinner.

	! !
!TerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:57:34'!
hasWonOAtGame: aTerniLapilliGame

	^ false.! !
!TerniLapilliGameState methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 15:57:45'!
hasWonXAtGame: aTerniLapilliGame

	^ false.! !

TerniLapilliGameState removeSelector: #hasWonX!

TerniLapilliGameState removeSelector: #hasWonO!
!TerniLapilliGame methodsFor: 'testing' stamp: 'D 10/17/2019 15:58:05' prior: 50754861!
hasWonO
	^ gameState hasWonOAtGame: self.! !
!TerniLapilliGame methodsFor: 'testing' stamp: 'D 10/17/2019 15:58:13' prior: 50754865!
hasWonX
	^ gameState hasWonXAtGame: self.! !
!TerniLapilliGame methodsFor: 'private testing' stamp: 'D 10/17/2019 16:02:28' prior: 50754552!
isGameOver
	^ self isXWinner or: self isOWinner.! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 16:03:30' prior: 50752810!
test35GameIsOverWithHorizontalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	
	self assert: game isOver.
	self deny: game isTied.
	self deny: game isPlayingX.
	self deny: game isPlayingO.	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 16:03:39' prior: 50752831!
test36GameIsOverWithVerticalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 1@2.
	game putOAt: 0@2.
	game putXAt: 1@0.
	
	self assert: game isOver.
	self deny: game isTied.
	self deny: game isPlayingX.
	self deny: game isPlayingO.
	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 16:03:43' prior: 50752842!
test37GameIsOverWithDiagonalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 0@0.
	game putOAt: 0@2.
	game putXAt: 2@2.
	
	self assert: game isOver.
	self deny: game isTied.
	self deny: game isPlayingX.
	self deny: game isPlayingO.
	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 16:05:48'!
assertGameOverNotTiedAndNeitherPlayerTurnIn: game
	
	self assert: game isOver.
	self deny: game isTied.
	self deny: game isPlayingX.
	self deny: game isPlayingO.	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 16:06:13' prior: 50754938!
test35GameIsOverWithHorizontalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@1.
	
	self assertGameOverNotTiedAndNeitherPlayerTurnIn: game.	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 16:06:19' prior: 50754951!
test36GameIsOverWithVerticalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 1@2.
	game putOAt: 0@2.
	game putXAt: 1@0.
	
	self assertGameOverNotTiedAndNeitherPlayerTurnIn: game.
	! !
!TerniLapilliGameTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 16:06:27' prior: 50754964!
test37GameIsOverWithDiagonalLine

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 0@1.
	game putXAt: 0@0.
	game putOAt: 0@2.
	game putXAt: 2@2.
	
	self assertGameOverNotTiedAndNeitherPlayerTurnIn: game.
	! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:10:12'!
assertIsPlayerOTurnAndDoesNotOwn: aCell in: game
	
	self deny: (game isOCell: aCell).
	self assert: game isPlayingO.
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:10:44' prior: 50749315!
test09PlayerXCannotPlaceChipOutOfRange

	| game |
	
	game := TerniLapilliGame new.
	self should: [ game putXAt: -1@3. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError.
	self assertIsPlayerXTurnAndDoesNotOwn: -1@3 in: game
! !
!TerniLapilliGameTest methodsFor: 'private assertions' stamp: 'D 10/17/2019 16:11:00'!
assertIsPlayerXTurnAndDoesNotOwn: aCell in: game
	
	self deny: (game isXCell: aCell).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:11:15' prior: 50755024!
test09PlayerXCannotPlaceChipOutOfRange

	| game |
	
	game := TerniLapilliGame new.
	self should: [ game putXAt: -1@3. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError.
	
	self assertIsPlayerXTurnAndDoesNotOwn: -1@3 in: game
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:11:32' prior: 50749288!
test10PlayerOCannotPlaceChipOutOfRange

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	
	self should: [ game putOAt: -1@3. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError.
	
	self assertIsPlayerOTurnAndDoesNotOwn: -1@3 in: game
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:11:51' prior: 50749399!
test11PlayerXCannotPlaceChipsInAnOccupiedCell

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt:  0@0.
		
	self should: [ game putXAt: 0@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellOccupiedError.
	
	self assertIsPlayerXTurnAndDoesNotOwn: 0@0 in: game.
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:12:12' prior: 50749428!
test12PlayerOCannotPlaceChipsInAnOccupiedCell

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
		
	self should: [ game putOAt: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellOccupiedError.
	
	self assertIsPlayerOTurnAndDoesNotOwn: 0@0 in: game.
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:13:22' prior: 50750357!
test15PlayerXCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
		
	self should: [ game putXAt: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self assertIsPlayerXTurnAndDoesNotOwn: 1@2 in: game.
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:13:41' prior: 50750305!
test16PlayerOCannotPlaceMoreThanThreeChips

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 1@1 to: 1@2.
		
	self should: [ game putOAt: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotPlaceMoreThanThreeChips.
	
	self assertIsPlayerOTurnAndDoesNotOwn: 1@1 in: game.
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:14:37' prior: 50754100!
test19PlayerXCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: -1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError.
	
	self assertIsPlayerXTurnAndDoesNotOwn: 2@0 in: game.
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:14:53' prior: 50754117!
test20PlayerOCannotSlideFromAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: -2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError .
	
	self assertIsPlayerOTurnAndDoesNotOwn: 2@1 in: game.
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:15:10' prior: 50754135!
test21PlayerXCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: -2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError .
	
	self assertIsPlayerXTurnAndDoesNotOwn: 1@1 in: game.! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:15:24' prior: 50755159!
test21PlayerXCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: -2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError .
	
	self assertIsPlayerXTurnAndDoesNotOwn: 1@1 in: game.! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:15:59' prior: 50755175!
test21PlayerXCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: -2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError .
	
	self assertIsPlayerXTurnAndDoesOwn: 1@1 in: game.! !
!TerniLapilliGameTest methodsFor: 'private assertions' stamp: 'D 10/17/2019 16:16:31'!
assertIsPlayerXTurnAndDoesOwn: aCell in: game
	
	self assert: (game isXCell: aCell).
	self assert: game isPlayingX.
! !
!TerniLapilliGameTest methodsFor: 'private assertions' stamp: 'D 10/17/2019 16:16:45'!
assertIsPlayerOTurnAndDoesOwn: aCell in: game
	
	self assert: (game isOCell: aCell).
	self assert: game isPlayingO.
! !

Smalltalk removeClassNamed: #OTurnTerniLapilli!

Smalltalk removeClassNamed: #XTurnTerniLapilli!

Smalltalk removeClassNamed: #TurnTerniLapilli!
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:17:49' prior: 50754152!
test22PlayerOCannotSlideToAnInvalidPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: -2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellNotValidError .
	
	self assertIsPlayerOTurnAndDoesOwn: 1@0 in: game.
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:18:19' prior: 50750640!
test23PlayerXCannotSlideFromAPositionNotOwned

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@0 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self assert: (game isOCell: 1@0).
	self assertIsPlayerXTurnAndDoesNotOwn: 2@0 in: game.! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:18:34' prior: 50750658!
test24PlayerOCannotSlideFromAPositionNotOwned

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self assertIsPlayerXTurnAndDoesNotOwn: 2@1 in: game.
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:18:48' prior: 50755261!
test24PlayerOCannotSlideFromAPositionNotOwned

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 2@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideChipFromAPositionNotOwnedError.
	
	self assertIsPlayerOTurnAndDoesNotOwn: 2@1 in: game.
! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:19:16' prior: 50754170!
test25PlayerXCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 1@1 to: 1@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellOccupiedError .
	
	self assert: (game isOCell: 1@0).
	self assertIsPlayerXTurnAndDoesOwn: 1@1 in: game.! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:19:38' prior: 50754188!
test26PlayerOCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellOccupiedError .
	
	self assert: (game isXCell: 1@1).
	self assertIsPlayerXTurnAndDoesOwn: 1@0 in: game.! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:19:43' prior: 50755314!
test26PlayerOCannotSlideToAnOccupiedPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.

	self should: [ game slideOFrom: 1@0 to: 1@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame cellOccupiedError .
	
	self assert: (game isXCell: 1@1).
	self assertIsPlayerOTurnAndDoesOwn: 1@0 in: game.! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:20:37' prior: 50751573!
test29PlayerXCannotSlideToANotNeighbourPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 2@2 to: 2@0. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToAPositionNotFollowingPredefinedLinesError.
	
	self deny: (game isXCell: 2@0).
	self assertIsPlayerXTurnAndDoesOwn: 2@2 in: game.! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:21:01' prior: 50751732!
test30PlayerOCannotSlideToANotNeighbourPosition

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 1@1 to: 2@1.
	
	self should: [ game slideOFrom: 1@0 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToAPositionNotFollowingPredefinedLinesError.
	
	self deny: (game isOCell: 1@2).
	self assertIsPlayerOTurnAndDoesOwn: 1@0 in: game.! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:21:19' prior: 50751820!
test31PlayerXCannotSlideNotFollowingThePredefinedLines

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.

	self should: [ game slideXFrom: 0@1 to: 1@2. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToAPositionNotFollowingPredefinedLinesError.
	
	self deny: (game isXCell: 1@2).
	self assertIsPlayerXTurnAndDoesOwn: 0@1 in: game.! !
!TerniLapilliGameTest methodsFor: 'test' stamp: 'D 10/17/2019 16:21:39' prior: 50752077!
test32PlayerOCannotSlideNotFollowingThePredefinedLines

	| game |
	
	game := TerniLapilliGame new.
	game putXAt: 1@1.
	game putOAt: 1@0.
	game putXAt: 0@1.
	game putOAt: 0@0.
	game putXAt: 2@2.
	game putOAt: 0@2.
	game slideXFrom: 2@2 to: 1@2.
	
	self should: [ game slideOFrom: 1@0 to: 2@1. ]
		raise: Error -MessageNotUnderstood 
		withMessageText: TerniLapilliGame playerCannotSlideToAPositionNotFollowingPredefinedLinesError.
	
	self deny: (game isOCell: 2@1).
	self assertIsPlayerOTurnAndDoesOwn: 1@0 in: game.! !
!TerniLapilliGameState methodsFor: 'testing' stamp: 'D 10/17/2019 16:24:52'!
isPlayingX
	
	self subclassResponsibility .! !
!TerniLapilliGameState methodsFor: 'testing' stamp: 'D 10/17/2019 16:24:55'!
isPlayingO
	
	self subclassResponsibility .! !

----SNAPSHOT----(17 October 2019 16:29:36) clase2.image priorSource: 13522207!

Smalltalk removeClassNamed: #XSlidingChipsTerniLapilliGameState!

Smalltalk removeClassNamed: #OSlidingChipsTerniLapilliGameState!

Smalltalk removeClassNamed: #SlidingChipsTerniLapilliGameState!

Smalltalk removeClassNamed: #XPlacingChipsTerniLapilliGameState!

Smalltalk removeClassNamed: #OPlacingChipsTerniLapilliGameState!

Smalltalk removeClassNamed: #PlacingChipsTerniLapilliGameState!

Smalltalk removeClassNamed: #GameOverTerniLapilliGameState!

Smalltalk removeClassNamed: #TerniLapilliGameState!

Smalltalk removeClassNamed: #TerniLapilliGame!

Smalltalk removeClassNamed: #TerniLapilliGameTest!

----End fileIn of /home/drenteria/Documentos/isI/isw1/linux64/TerniLapilli.st----!

----QUIT----(17 October 2019 16:33:03) clase2.image priorSource: 13561006!

----STARTUP---- (17 October 2019 18:36:40) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!


----End fileIn of /home/drenteria/Documentos/isI/isw1/23-Portfolio/Portfolio-Ejercicio.st----!
!ReceptiveAccount methodsFor: 'balance' stamp: 'D 10/17/2019 18:44:12' prior: 50757034!
balance

	^transactions sum: [ :aTransaction | aTransaction xxxvalue ] ifEmpty: [ 0 ]! !
!Deposit methodsFor: 'value' stamp: 'D 10/17/2019 18:44:30'!
xxxvalue

	^ value.! !
!Withdraw methodsFor: 'value' stamp: 'D 10/17/2019 18:44:48'!
xxxvalue

	^ -1 * value.! !

TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #Portfolio
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
Object subclass: #Portfolio
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'no messages' stamp: 'D 10/17/2019 18:49:54'!
test01EmptyPortfolioHasZeroBalance
	
	| emptyPortfolio |
	emptyPortfolio := Portfolio new.
	

	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 18:50:52' prior: 50757081!
test01EmptyPortfolioHasZeroBalance
	
	| emptyPortfolio |
	
	emptyPortfolio := Portfolio new.
	
	self assert: emptyPortfolio  balance isZero.
	! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 18:52:11'!
balance
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 18:52:24' prior: 50757095!
balance
	^ 0.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 18:54:07'!
test02PortfolioWithOneAccountReturnsBalanceOfThatAccount
	
	| emptyPortfolio |
	
	emptyPortfolio := Portfolio new.
	
	self assert: emptyPortfolio  balance isZero.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 18:54:15' prior: 50757103!
test02PortfolioWithOneAccountReturnsBalanceOfThatAccount
	
	| portfolio |
	
	portfolio := Portfolio new.
	
	self assert: portfolio  balance isZero.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 18:55:35' prior: 50757112!
test02PortfolioWithOneAccountReturnsBalanceOfThatAccount
	
	| portfolio account |
	account := ReceptiveAccount new.
	
	portfolio := Portfolio new.
	"portfolio add: "
	
	self assert: portfolio  balance isZero.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 18:56:34' prior: 50757120!
test02PortfolioWithOneAccountReturnsBalanceOfThatAccount
	
	| portfolio account |
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
	
	portfolio := Portfolio new.
	"portfolio add: "
	
	self assert: portfolio  balance isZero.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 18:57:21' prior: 50757130!
test02PortfolioWithOneAccountReturnsBalanceOfThatAccount
	
	| portfolio account |
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
	
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: portfolio  balance equals: 100.
	! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 18:58:03'!
add
! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
Object subclass: #Portfolio
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:00:58'!
add: aContent

	contents add: aContent.

	

! !

Portfolio removeSelector: #add!
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:01:33'!
initialize

	contents := OrderedCollection new.! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:03:14' prior: 50757099!
balance
	contents sum: [ :anElem | anElem balance ].! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:03:20' prior: 50757171!
balance
	
	^contents sum: [ :anElem | anElem balance ].! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:03:30' prior: 50757176!
balance
	
	^ contents sum: [ :anElem | anElem balance ].! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:04:42' prior: 50757181!
balance
	
	^ contents sum: [ :anElem | anElem balance ] ifEmpty: [ 0 ].! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:05:18'!
test03PortfolioWithTwoAccountsReturnsBalanceOfBothAccount
	
	| portfolio account |
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
	
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: portfolio  balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:05:21'!
test03PortfolioWithTwoAccountsReturnsBalanceOfBothAccounts
	
	| portfolio account |
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
	
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: portfolio  balance equals: 100.
	! !

PortfolioTest removeSelector: #test03PortfolioWithTwoAccountsReturnsBalanceOfBothAccount!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:06:27' prior: 50757202!
test03PortfolioWithTwoAccountsReturnsBalanceOfBothAccounts
	
	| portfolio  anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
		
	self assert: portfolio  balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:06:42' prior: 50757217!
test03PortfolioWithTwoAccountsReturnsBalanceOfBothAccounts
	
	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
		
	self assert: portfolio  balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:07:28' prior: 50757233!
test03PortfolioWithTwoAccountsReturnsBalanceOfBothAccounts
	
	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: -50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
		
	self assert: portfolio  balance equals: 50.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:10:03' prior: 50757249!
test03PortfolioWithTwoAccountsReturnsBalanceOfBothAccounts
	
	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
		
	self assert: portfolio  balance equals: 150.
	! !
!Withdraw methodsFor: 'value' stamp: 'D 10/17/2019 19:11:14' prior: 50757056!
xxxvalue

	^ value negated.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:15:10'!
test04PortfolioWithTwoAccountsReturnsBalanceOfBothAccounts
	
	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
		
	self assert: portfolio  balance equals: 150.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:17:53'!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
		
	self assert: portfolio  balance equals: 150.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:19:46' prior: 50757301!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio anAccount anotherAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio  add: portfolioToInclude.
		
	self assert: portfolio  balance equals: 150.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:20:13' prior: 50757317!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio  add: portfolioToInclude.
		
	self assert: portfolio  balance equals: 100.
	! !

PortfolioTest removeSelector: #test04PortfolioWithTwoAccountsReturnsBalanceOfBothAccounts!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:21:04' prior: 50757333!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio  addPortfolio: portfolioToInclude.
		
	self assert: portfolio  balance equals: 100.
	! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:21:24'!
addAccount: aContent

	contents add: aContent.

	

! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:21:24' prior: 50757161!
add: aContent

	contents addAccount: aContent.

	

! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:21:24' prior: 50757351!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude addAccount: anAccount.
	
	portfolio := Portfolio new.
	portfolio  addPortfolio: portfolioToInclude.
		
	self assert: portfolio  balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:21:24' prior: 50757265!
test03PortfolioWithTwoAccountsReturnsBalanceOfBothAccounts
	
	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio addAccount: anAccount.
	portfolio addAccount: anotherAccount.
		
	self assert: portfolio  balance equals: 150.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:21:24' prior: 50757141!
test02PortfolioWithOneAccountReturnsBalanceOfThatAccount
	
	| portfolio account |
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
	
	portfolio := Portfolio new.
	portfolio addAccount: account.
	
	self assert: portfolio  balance equals: 100.
	! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:21:24' prior: 50757025!
register: aTransaction

	transactions addAccount: aTransaction 
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:21:24' prior: 50757366!
addAccount: aContent

	contents addAccount: aContent.

	

! !

Portfolio removeSelector: #add:!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:29:19' prior: 50757376!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude addAccount: anAccount.
	
	portfolio := Portfolio new.
	portfolio  addPortfolio: portfolioToInclude.
		
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:29:30' prior: 50757434!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude addAccount: anAccount.
	
	portfolio := Portfolio new.
	portfolio addPortfolio: portfolioToInclude.
		
	self assert: portfolio balance equals: 100.
	! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
Object subclass: #Portfolio
	instanceVariableNames: 'contents accounts'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:37:12' prior: 50757427!
addAccount: aContent

	accounts addAccount: aContent.

	

! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:37:34' prior: 50757186!
balance
	
	^ accounts sum: [ :anElem | anElem balance ] ifEmpty: [ 0 ].! !

Object subclass: #Portfolio
	instanceVariableNames: 'accounts'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:38:39'!
addPortfolio: aPortfolio

	portfolios add: aPortfolio .

	

! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:38:45' prior: 50757472!
addAccount: aContent

	accounts add: aContent.

	

! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:38:58' prior: 50757505!
addAccount: anAccount

	accounts add: anAccount.

	

! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:40:25' prior: 50757477!
balance
	
	^ (accounts sum: [ :anAccount | anAccount balance ] ifEmpty: [ 0 ]) + (portfolios sum: [ :aPortfolio | aPortfolio balance ] ifEmpty: [ 0 ]).! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:41:09' prior: 50757166!
initialize

	accounts := OrderedCollection new.
	portfolios := OrderedCollection new.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'D 10/17/2019 19:44:24' prior: 50757421!
register: aTransaction

	transactions add: aTransaction 
! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:45:59'!
test04PortfolioWithTwoPortfolioHasBalanceOfBothPortfolio
	
	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude addAccount: anAccount.
	
	portfolio := Portfolio new.
	portfolio addPortfolio: portfolioToInclude.
		
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:46:16'!
test05PortfolioWithTwoPortfoliosHasBalanceOfBothPortfolios
	
	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude addAccount: anAccount.
	
	portfolio := Portfolio new.
	portfolio addPortfolio: portfolioToInclude.
		
	self assert: portfolio balance equals: 100.
	! !

PortfolioTest removeSelector: #test04PortfolioWithTwoPortfolioHasBalanceOfBothPortfolio!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:47:31' prior: 50757549!
test05PortfolioWithTwoPortfoliosHasBalanceOfBothPortfolios
	
	| portfolio anAccount portfolioToInclude anotherAccount anotherPortfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude addAccount: anAccount.
	anotherPortfolioToInclude := Portfolio new.
	anotherPortfolioToInclude addAccount: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio addPortfolio: portfolioToInclude.
		
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:48:08' prior: 50757568!
test05PortfolioWithTwoPortfoliosHasBalanceOfBothPortfolios
	
	| portfolio anAccount portfolioToInclude anotherAccount anotherPortfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude addAccount: anAccount.
	anotherPortfolioToInclude := Portfolio new.
	anotherPortfolioToInclude addAccount: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio addPortfolio: portfolioToInclude.
	portfolio addPortfolio: anotherPortfolioToInclude.
		
	self assert: portfolio balance equals: 150.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:50:38'!
test06EmptyPortfolioHasNoTransactions
	
	| portfolio anAccount portfolioToInclude anotherAccount anotherPortfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude addAccount: anAccount.
	anotherPortfolioToInclude := Portfolio new.
	anotherPortfolioToInclude addAccount: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio addPortfolio: portfolioToInclude.
	portfolio addPortfolio: anotherPortfolioToInclude.
		
	self assert: portfolio balance equals: 150.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:51:13' prior: 50757615!
test06EmptyPortfolioHasNoTransactions
	
	| portfolio |
	
	portfolio := Portfolio new.
		
	self assert: portfolio transactions isEmpty.
	! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:51:36'!
transactions
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:52:06' prior: 50757646!
transactions
	
	^ OrderedCollection new.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:53:00'!
test07PortfolioWithOneAccountHasTransactionsOfThatAccount
	
	| portfolio |
	
	portfolio := Portfolio new.
		
	self assert: portfolio transactions isEmpty.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:54:24' prior: 50757654!
test07PortfolioWithOneAccountHasTransactionsOfThatAccount

	| portfolio account |
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
	
	portfolio := Portfolio new.
	portfolio addAccount: account.
	
	self assert: portfolio transactions equals: account transactions .
	! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:56:14' prior: 50757650!
transactions
	
	^ accounts .! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:56:30'!
add: anAccount

	accounts add: anAccount.

	

! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:56:30' prior: 50757409!
test02PortfolioWithOneAccountReturnsBalanceOfThatAccount
	
	| portfolio account |
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
	
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: portfolio  balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:56:30' prior: 50757450!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio addPortfolio: portfolioToInclude.
		
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:56:30' prior: 50757663!
test07PortfolioWithOneAccountHasTransactionsOfThatAccount

	| portfolio account |
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
	
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: portfolio transactions equals: account transactions .
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:56:30' prior: 50757392!
test03PortfolioWithTwoAccountsReturnsBalanceOfBothAccounts
	
	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
		
	self assert: portfolio  balance equals: 150.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:56:30' prior: 50757591!
test05PortfolioWithTwoPortfoliosHasBalanceOfBothPortfolios
	
	| portfolio anAccount portfolioToInclude anotherAccount anotherPortfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	anotherPortfolioToInclude := Portfolio new.
	anotherPortfolioToInclude add: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio addPortfolio: portfolioToInclude.
	portfolio addPortfolio: anotherPortfolioToInclude.
		
	self assert: portfolio balance equals: 150.
	! !

Portfolio removeSelector: #addAccount:!

Portfolio removeSelector: #addPortfolio:!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:57:15' prior: 50757696!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
		
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:57:20' prior: 50757739!
test05PortfolioWithTwoPortfoliosHasBalanceOfBothPortfolios
	
	| portfolio anAccount portfolioToInclude anotherAccount anotherPortfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	anotherPortfolioToInclude := Portfolio new.
	anotherPortfolioToInclude add: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	portfolio addPortfolio: anotherPortfolioToInclude.
		
	self assert: portfolio balance equals: 150.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:57:24' prior: 50757781!
test05PortfolioWithTwoPortfoliosHasBalanceOfBothPortfolios
	
	| portfolio anAccount portfolioToInclude anotherAccount anotherPortfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	anotherPortfolioToInclude := Portfolio new.
	anotherPortfolioToInclude add: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	portfolio add: anotherPortfolioToInclude.
		
	self assert: portfolio balance equals: 150.
	! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:58:04' prior: 50757515!
balance
	
	^ (accounts sum: [ :anAccount | anAccount balance ] ifEmpty: [ 0 ]).! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:58:13' prior: 50757523!
initialize

	accounts := OrderedCollection new.
! !

Object subclass: #Portfolio
	instanceVariableNames: 'accounts'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:58:51' prior: 50757675!
transactions
	
	^ contents .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:58:51' prior: 50757834!
initialize

	contents := OrderedCollection new.
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:58:51' prior: 50757679!
add: anAccount

	contents add: anAccount.

	

! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 19:58:51' prior: 50757828!
balance
	
	^ (contents sum: [ :anAccount | anAccount balance ] ifEmpty: [ 0 ]).! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
Object subclass: #Portfolio
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:59:18' prior: 50757866!
add: anElement

	contents add: anElement.

	

! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:59:30' prior: 50757871!
balance
	
	^ (contents sum: [ :anElement | anElement balance ] ifEmpty: [ 0 ]).! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 20:06:39'!
addTransactions: transactions to: aCollectionOfTransactions
	
	^ contents .! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 20:06:48' prior: 50757857!
transactions
	
	^ contents ! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 20:08:19' prior: 50757899!
transactions
	
	^ contents inject: OrderedCollection new into: [ :collectionOfTransactions :anElem | self addTransactions: anElem transactions to: collectionOfTransactions  ].! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 20:09:24' prior: 50757893!
addTransactions: transactions to: aCollectionOfTransactions
	
	^ transactions do: [ :aTransaction | aCollectionOfTransactions add: aTransaction ].! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 20:11:17' prior: 50757903!
transactions
	
	^ contents inject: OrderedCollection new into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: anElem transactions ].! !

Portfolio removeSelector: #addTransactions:to:!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:12:11'!
test08PortfolioWithTwoAccountsHasTransactionsOfBothAccounts

	| portfolio account |
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
	
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: portfolio transactions equals: account transactions .
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:13:05' prior: 50757930!
test08PortfolioWithTwoAccountsHasTransactionsOfBothAccounts

	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
	
	self assert: portfolio transactions equals: (anAccount transactions addAllLast: anotherAccount transactions) .
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:16:12' prior: 50757942!
test08PortfolioWithTwoAccountsHasTransactionsOfBothAccounts

	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
	
	self assert: portfolio transactions equals: (anAccount transactions) .
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:16:27' prior: 50757960!
test08PortfolioWithTwoAccountsHasTransactionsOfBothAccounts

	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
	
	self assert: portfolio transactions equals: (anAccount transactions addAllLast: anotherAccount transactions) .
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:20:05'!
test08PortfolioWithOnePortfolioHasTransactionsOfThePortfolio

	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
	
	self assert: portfolio transactions equals: (anAccount transactions addAllLast: anotherAccount transactions) .
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:20:41'!
test09PortfolioWithOnePortfolioHasTransactionsOfThePortfolio

	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	
	self assert: portfolio transactions equals: (anAccount transactions addAllLast: anAccount transactions) .
	! !

PortfolioTest removeSelector: #test08PortfolioWithOnePortfolioHasTransactionsOfThePortfolio!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:21:31' prior: 50758013!
test09PortfolioWithOnePortfolioHasTransactionsOfThePortfolio

	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	
	self assert: portfolio transactions equals: portfolioToInclude transactions .
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:24:48'!
test10PortfolioWithOnePortfolioAndOneAccountHasTransactionsOfThePortfolioAnTheAccount

	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	
	self assert: portfolio transactions equals: portfolioToInclude transactions .
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:24:59'!
test10PortfolioWithOnePortfolioAndOneAccountHasTransactionsOfThePortfolioAndTheAccount

	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	
	self assert: portfolio transactions equals: portfolioToInclude transactions .
	! !

PortfolioTest removeSelector: #test10PortfolioWithOnePortfolioAndOneAccountHasTransactionsOfThePortfolioAnTheAccount!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:25:31' prior: 50758066!
test10PortfolioWithOnePortfolioAndOneAccountHasTransactionsOfThePortfolioAndTheAccount

	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	
	self assert: portfolio transactions equals: portfolioToInclude transactions .
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:25:48' prior: 50758087!
test10PortfolioWithOnePortfolioAndOneAccountHasTransactionsOfThePortfolioAndTheAccount

	| portfolio anAccount portfolioToInclude anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	
	self assert: portfolio transactions equals: portfolioToInclude transactions .
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:26:48' prior: 50758104!
test10PortfolioWithOnePortfolioAndOneAccountHasTransactionsOfThePortfolioAndTheAccount

	| portfolio anAccount portfolioToInclude anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	portfolio add: anotherAccount .
		
	self assert: portfolio transactions equals: (portfolioToInclude transactions addAllLast: anotherAccount transactions).
	! !

PortfolioTest removeSelector: #test10PortfolioWithOnePortfolioAndOneAccountHasTransactionsOfThePortfolioAndTheAccount!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:36:56'!
test10EmptyPortfolioHasNoRegisteredTransactions

	| portfolio anAccount aTransaction |
	anAccount := ReceptiveAccount  new.
	aTransaction := Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.

	
	self deny: (portfolio hasRegistered: aTransaction).! !
!Portfolio methodsFor: 'testing' stamp: 'D 10/17/2019 20:37:15'!
hasRegistered: aDeposit 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'testing' stamp: 'D 10/17/2019 20:37:44' prior: 50758161!
hasRegistered: aTransaction 
	
	^ self transactions includes: aTransaction .! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:50:30'!
test11PortfolioWithAccountAndPortfolioTransactions

	| portfolio anAccount aTransaction |
	anAccount := ReceptiveAccount  new.
	aTransaction := Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.

	
	self deny: (portfolio hasRegistered: aTransaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'D 10/17/2019 20:51:05'!
test11PortfolioWithAccountAndPortfolioHasRegisteredTheirTransactions

	| portfolio anAccount aTransaction |
	anAccount := ReceptiveAccount  new.
	aTransaction := Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.

	
	self deny: (portfolio hasRegistered: aTransaction).! !

PortfolioTest removeSelector: #test11PortfolioWithAccountAndPortfolioTransactions!

----SNAPSHOT----(17 October 2019 21:24:55) clase2.image priorSource: 13605579!

----QUIT----(17 October 2019 21:24:58) clase2.image priorSource: 13649492!

----STARTUP---- (18 October 2019 17:39:45) as /home/melissa/Mel/college shit/Ingeniera de Software I/isw1/linux64/clase2.image!

!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 17:57:13'!
test12AddingAnAccountToAPortfolioThatAlreadyHasItRaisesError

	| portfolio anAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	self should: [ portfolio add: anAccount. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.
	! !
!Portfolio class methodsFor: 'no messages' stamp: 'mr 10/18/2019 17:57:58'!
cannotAddAnExistentAccountError

	 ^ 'You cannot add an already existent account'! !

Object subclass: #Portfolio
	instanceVariableNames: 'contents roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
Object subclass: #Portfolio
	instanceVariableNames: 'contents roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio'!
Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio'!
Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 18:00:34' prior: 50757883!
add: anElement

	anElement addRoot: self.
	contents add: anElement.

	

! !
!ReceptiveAccount methodsFor: 'nil' stamp: 'mr 10/18/2019 18:01:44'!
addRoot: anElement

	roots add: anElement .! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'mr 10/18/2019 18:02:01' prior: 50757020!
initialize

	transactions := OrderedCollection new.
	roots := OrderedCollection new.! !

Object subclass: #BankContainersXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #BankContainersXX category: #'Portfolio-Ejercicio'!
Object subclass: #BankContainersXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

BankContainers subclass: #Portfolio
	instanceVariableNames: 'contents roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
BankContainersXX subclass: #Portfolio
	instanceVariableNames: 'contents roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

BankContainersXX subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio'!
BankContainersXX subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

ReceptiveAccount removeSelector: #addRoot:!

BankContainersXX subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio'!
BankContainersXX subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

BankContainersXX subclass: #Portfolio
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
BankContainersXX subclass: #Portfolio
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #BankContainersXX
	instanceVariableNames: 'roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #BankContainersXX category: #'Portfolio-Ejercicio'!
Object subclass: #BankContainersXX
	instanceVariableNames: 'roots'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!BankContainersXX methodsFor: 'no messages' stamp: 'mr 10/18/2019 18:04:51'!
addRoot: anElement

	roots add: anElement .! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 18:14:00' prior: 50758265!
add: anElementToAdd

	roots detect: [:aRoot | (aRoot canAdd: anElementToAdd) not. ] 
		   ifFound: 
				   [ anElementToAdd addRoot: self.
				     contents add: anElementToAdd. ]
		   ifNone: [ self error: self class ]. 
	
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 18:15:21' prior: 50758358!
add: anElementToAdd

	roots detect: [:aRoot | (aRoot canAdd: anElementToAdd) not. ] 
		   ifFound: 
				   [ self error: self class cannotAddAnExistentAccountError. ]
		   ifNone: [ anElementToAdd addRoot: self.
				     contents add: anElementToAdd. ]. 
	
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 18:15:44' prior: 50758368!
add: anElementToAdd

	roots detect:   [:aRoot | (aRoot canAdd: anElementToAdd) not. ] 
		   ifFound: [ self error: self class cannotAddAnExistentAccountError. ]
		   ifNone:   [ anElementToAdd addRoot: self.
				     contents add: anElementToAdd. ]. 
	
	

! !
!BankContainersXX methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:16:47'!
includes: anElement! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 18:17:11' prior: 50758379!
add: anElementToAdd

	roots detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
		   ifFound: [ self error: self class cannotAddAnExistentAccountError. ]
		   ifNone:   [ anElementToAdd addRoot: self.
				     contents add: anElementToAdd. ]. 
	
	

! !
!BankContainersXX methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:18:00' prior: 50758390!
includes: anElement

	self subclassResponsibility .! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 18:23:21'!
includes: anElement! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 18:24:56' prior: 50758394!
add: anElementToAdd

	
	"roots do:" 
	roots detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
		   ifFound: [ self error: self class cannotAddAnExistentAccountError. ]
		   ifNone:   [ anElementToAdd addRoot: self.
				     contents add: anElementToAdd. ]. 
	
	

! !

!classDefinition: #BankContainersXX category: #'Portfolio-Ejercicio'!
Object subclass: #BankContainersXX
	instanceVariableNames: 'roots parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!BankContainersXX methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:25:20' prior: 50758353!
addRoot: anElement

	parents add: anElement .! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:25:20' prior: 50758275!
initialize

	transactions := OrderedCollection new.
	parents := OrderedCollection new.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:25:20' prior: 50758414!
add: anElementToAdd

	
	"roots do:" 
	parents detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
		   ifFound: [ self error: self class cannotAddAnExistentAccountError. ]
		   ifNone:   [ anElementToAdd addRoot: self.
				     contents add: anElementToAdd. ]. 
	
	

! !

!classDefinition: #BankContainersXX category: #'Portfolio-Ejercicio'!
Object subclass: #BankContainersXX
	instanceVariableNames: 'parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 18:25:45' prior: 50758444!
add: anElementToAdd

	
	| roots |
	roots := OrderedCollection new.
	parents detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
		   ifFound: [ self error: self class cannotAddAnExistentAccountError. ]
		   ifNone:   [ anElementToAdd addRoot: self.
				     contents add: anElementToAdd. ]. 
	
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 18:31:02'!
roots

	| roots |
	
	roots := OrderedCollection new.
	
	parents inject: roots into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
	 
	^ roots.
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 18:31:52' prior: 50758475!
roots

	^ parents inject: OrderedCollection new
			    into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 18:33:23' prior: 50758463!
add: anElementToAdd

	self roots detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
		          ifFound: [ self error: self class cannotAddAnExistentAccountError. ]
		          ifNone:   [ anElementToAdd addRoot: self.
				              contents add: anElementToAdd. ]. 
	
	

! !
!BankContainersXX methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:34:21'!
roots

	^ parents inject: OrderedCollection new
			    into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
! !

Portfolio removeSelector: #roots!
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 18:38:47' prior: 50758410!
includes: anElement

	contents detect: [:anElem | anElem includes: anElement ] ifNone: [].! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 18:38:56' prior: 50758513!
includes: anElementToInclude

	contents detect: [:anElem | anElem includes: anElementToInclude ] ifNone: [].! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 18:40:14' prior: 50758519!
includes: anElementToInclude

	contents detect: [:anElem | anElem includes: anElementToInclude ] ifNone: [ ^ false ].
	
	^ true. ! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:41:18'!
includes: anElementToInclude

	^ self = anElementToInclude.

	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:50:05'!
test13AddingToAnEmptyPortfolioRegisteredInTwoPortfoliosAnAccountRegisteredInOneOfThemRaisesError

	| portfolio anAccount anotherAccount anotherPortfolio emptyPortfolio |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 150 on: anotherAccount.
	
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anotherAccount.
	
	emptyPortfolio := Portfolio new.
	
	portfolio add: emptyPortfolio.
	anotherPortfolio add: emptyPortfolio.
	
	self should: [ portfolio add: anAccount. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:51:19' prior: 50758538!
test13AddingToAnEmptyPortfolioRegisteredInTwoPortfoliosAnAccountRegisteredInOneOfThemRaisesError

	| portfolio anAccount anotherAccount anotherPortfolio emptyPortfolio |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 150 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anotherAccount.
	
	emptyPortfolio := Portfolio new.
	
	portfolio add: emptyPortfolio.
	anotherPortfolio add: emptyPortfolio.
	
	self should: [ emptyPortfolio add: anAccount. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: emptyPortfolio balance equals: 0.	! !
!BankContainersXX methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:53:03'!
addParent: anElement

	parents add: anElement .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:53:03' prior: 50758492!
add: anElementToAdd

	self roots detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
		          ifFound: [ self error: self class cannotAddAnExistentAccountError. ]
		          ifNone:   [ anElementToAdd addParent: self.
				              contents add: anElementToAdd. ]. 
	
	

! !

BankContainersXX removeSelector: #addRoot:!
!BankContainersXX methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:53:35' prior: 50758594!
addParent: aParent

	parents add: aParent .! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 18:54:19' prior: 50758566!
test13AddingToAnEmptyPortfolioRegisteredInTwoPortfoliosAnAccountRegisteredInOneOfThemRaisesError

	| portfolio anAccount anotherAccount anotherPortfolio emptyPortfolio |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 150 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anotherAccount.
	
	emptyPortfolio := Portfolio new.
	
	portfolio add: emptyPortfolio.
	anotherPortfolio add: emptyPortfolio.
	
	self should: [ emptyPortfolio add: anAccount. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: emptyPortfolio balance equals: 0.	! !
!Portfolio methodsFor: 'initialization' stamp: 'mr 10/18/2019 18:55:55' prior: 50757861!
initialize

	contents := OrderedCollection new.
	parents := OrderedCollection new.
! !

self roots!

self roots.!

parents!

self roots!
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 19:05:03' prior: 50758599!
add: anElementToAdd

	(self includes: anElementToAdd) or: [
		 self roots detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
			           ifFound: [ self error: self class cannotAddAnExistentAccountError. ]
		  	           ifNone:   [ anElementToAdd addParent: self.
				                     contents add: anElementToAdd. ]. ]
	
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 19:09:03' prior: 50758653!
add: anElementToAdd

	self roots detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
	                ifFound: [ self error: self class cannotAddAnExistentAccountError. ]
		  	    ifNone:   [ 
				(self includes: anElementToAdd) ifTrue: [ self error: self class cannotAddAnExistentAccountError. ].
				anElementToAdd addParent: self.
				contents add: anElementToAdd. 
			    ].
	
	

! !

self roots!

self roots!

self parents!

parents!
!BankContainersXX methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 19:18:56' prior: 50758504!
roots

	parents isEmpty ifTrue: [ ^ OrderedCollection new; add: self ].

	^ parents inject: OrderedCollection new
			    into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
! !
!BankContainersXX methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 19:20:40' prior: 50758684!
roots

	parents isEmpty ifTrue: [ | roots |
		roots := OrderedCollection new.
		^ roots add: self. ].

	^ parents inject: OrderedCollection new
			    into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
! !
!BankContainersXX methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 19:21:34' prior: 50758694!
roots

	parents isEmpty ifTrue: [ | roots |
		roots := OrderedCollection new.
		roots add: self.
		^ roots ].

	^ parents inject: OrderedCollection new
			    into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 19:25:04' prior: 50758667!
add: anElementToAdd

	self roots detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
	                ifFound: [ :rootThatHasElement | self error: self class cannotAddAnExistentAccountError. ]
		  	    ifNone:   [ 
				(self includes: anElementToAdd) ifTrue: [ self error: self class cannotAddAnExistentAccountError. ].
				anElementToAdd addParent: self.
				contents add: anElementToAdd. 
			    ].
	
	

! !

self roots!

self roots!

self roots!

self roots!

self!

self roots!
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 19:31:49'!
roots

	parents isEmpty ifTrue: [ | roots |
		roots := OrderedCollection new.
		roots add: self.
		^ roots ].

	^ parents inject: OrderedCollection new
			    into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
! !

BankContainersXX removeSelector: #roots!

self roots!

aParent roots!

aParent roots!

parents inject: OrderedCollection new into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].!
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 19:41:20' prior: 50758734!
roots

	| rootsAux |
	parents isEmpty ifTrue: [ | roots |
		roots := OrderedCollection new.
		roots add: self.
		^ roots ].

	rootsAux := OrderedCollection new.
	
	parents inject: rootsAux
			 into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
	
	^ rootsAux.
! !

----SNAPSHOT----(18 October 2019 19:44:38) clase2.image priorSource: 13649572!

----QUIT----(18 October 2019 19:44:42) clase2.image priorSource: 13667625!

----STARTUP---- (18 October 2019 19:50:08) as /home/dago/Documents/Facultad/isw1/isw1/linux64/clase2.image!

!Portfolio methodsFor: 'accessing' stamp: 'DR 10/18/2019 19:51:50' prior: 50758752!
roots

	| |
	parents isEmpty ifTrue: [ | roots |
		roots := OrderedCollection new.
		roots add: self.
		^ roots ].

	
	
	^ parents inject: OrderedCollection new
			 into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
	
	
! !
!Portfolio methodsFor: 'accessing' stamp: 'DR 10/18/2019 19:52:00' prior: 50758773!
roots

	parents isEmpty ifTrue: [ | roots |
		roots := OrderedCollection new.
		roots add: self.
		^ roots ].

	^ parents inject: OrderedCollection new
			 into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
	
	
! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/18/2019 19:41:20' prior: 50758784!
roots

	| rootsAux |
	parents isEmpty ifTrue: [ | roots |
		roots := OrderedCollection new.
		roots add: self.
		^ roots ].

	rootsAux := OrderedCollection new.
	
	parents inject: rootsAux
			 into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
	
	^ rootsAux.
! !
!Portfolio methodsFor: 'accessing' stamp: 'DR 10/18/2019 19:54:54' prior: 50758795!
roots

	| roots |
	
	roots := OrderedCollection new.
	parents isEmpty ifTrue: [ 
		roots add: self.
		^ roots ].
	
	parents inject: roots
			 into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
	
	^ roots.
! !
!Portfolio methodsFor: 'testing' stamp: 'DR 10/18/2019 19:58:57' prior: 50758526!
includes: anElementToInclude

	contents detect: [:anElem | anElem includes: anElementToInclude ] ifNone: [ ^ false ].
	
	^ true. ! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 19:59:42'!
test14APortfolioCannotIncludeHimselfShouldRaiseError

	| portfolio anAccount anotherAccount anotherPortfolio emptyPortfolio |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 150 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anotherAccount.
	
	emptyPortfolio := Portfolio new.
	
	portfolio add: emptyPortfolio.
	anotherPortfolio add: emptyPortfolio.
	
	self should: [ emptyPortfolio add: anAccount. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: emptyPortfolio balance equals: 0.	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:00:29' prior: 50758825!
test14APortfolioCannotIncludeHimselfShouldRaiseError

	| portfolio anAccount emptyPortfolio |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	self should: [ portfolio add. portfolio. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: emptyPortfolio balance equals: 0.	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:00:58' prior: 50758852!
test14APortfolioCannotIncludeHimselfShouldRaiseError

	| portfolio anAccount |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	self should: [ portfolio add. portfolio. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:01:18' prior: 50758869!
test14APortfolioCannotIncludeHimselfShouldRaiseError

	| portfolio anAccount |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	self should: [ portfolio add: portfolio. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.	! !
!Portfolio methodsFor: 'testing' stamp: 'DR 10/18/2019 20:02:11' prior: 50758818!
includes: anElementToInclude
	
	^ self = anElementToInclude or: [
		contents detect: [:anElem | anElem includes: anElementToInclude ] ifNone: [ ^ false ].
	
		^ true. ]! !
!Portfolio methodsFor: 'testing' stamp: 'DR 10/18/2019 20:02:38' prior: 50758902!
includes: anElementToInclude
	
	^ self = anElementToInclude or: [ contents detect: [:anElem | anElem includes: anElementToInclude ] ifNone: [ ^ false ].
									   ^ true. ]! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:04:22'!
test15APortfolioWithAnAccountCannotAddAnotherPortfolioWithTheSameAccountAndShouldRaiseError

	| portfolio anAccount |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	self should: [ portfolio add: portfolio. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:04:33'!
test14APortfolioCannotIncludeAndHimselfShouldRaiseError

	| portfolio anAccount |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	self should: [ portfolio add: portfolio. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.	! !

PortfolioTest removeSelector: #test14APortfolioCannotIncludeHimselfShouldRaiseError!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:05:06' prior: 50758919!
test15APortfolioWithAnAccountCannotAddAnotherPortfolioWithTheSameAccountAndShouldRaiseError

	| portfolio anAccount anotherAccount anotherPortfolio |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 150 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anotherAccount.
	
	self should: [ portfolio add: portfolio. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:05:24' prior: 50758955!
test15APortfolioWithAnAccountCannotAddAnotherPortfolioWithTheSameAccountAndShouldRaiseError

	| portfolio anAccount anotherPortfolio |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anAccount.
	
	self should: [ portfolio add: portfolio. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:05:33' prior: 50758979!
test15APortfolioWithAnAccountCannotAddAnotherPortfolioWithTheSameAccountAndShouldRaiseError

	| portfolio anAccount anotherPortfolio |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anAccount.
	
	self should: [ portfolio add: anotherPortfolio. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.	! !
!Portfolio methodsFor: 'accessing' stamp: 'DR 10/18/2019 20:08:13' prior: 50758716!
add: anElementToAdd
	
	self assertIf: self isIncludedIn: anElementToAdd .
	self roots detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
	                ifFound: [ :rootThatHasElement | self error: self class cannotAddAnExistentAccountError. ]
		  	    ifNone:   [ 
				(self includes: anElementToAdd) ifTrue: [ self error: self class cannotAddAnExistentAccountError. ].
				anElementToAdd addParent: self.
				contents add: anElementToAdd. 
			    ].
	
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'DR 10/18/2019 20:10:32' prior: 50759020!
add: anElementToAdd
	
	self assertIfincludes: anElementToAdd.
	anElementToAdd  assertIfIncludes: self.
	self roots detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
	                ifFound: [ :rootThatHasElement | self error: self class cannotAddAnExistentAccountError. ]
		  	    ifNone:   [ 
				(self includes: anElementToAdd) ifTrue: [ self error: self class cannotAddAnExistentAccountError. ].
				anElementToAdd addParent: self.
				contents add: anElementToAdd. 
			    ].
	
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'DR 10/18/2019 20:11:31'!
assertIfincludes: anElementToAdd.
	
	self roots detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
	                ifFound: [ :rootThatHasElement | self error: self class cannotAddAnExistentAccountError. ]
		  	    ifNone:   [ 
				(self includes: anElementToAdd) ifTrue: [ self error: self class cannotAddAnExistentAccountError. ].
			    ].
	
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'DR 10/18/2019 20:12:12' prior: 50759038!
add: anElementToAdd
	
	self assertIfincludes: anElementToAdd.
	anElementToAdd  assertIfIncludes: self.
	
	anElementToAdd addParent: self.
	contents add: anElementToAdd. 
	

! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:12:40'!
assertIfIncludes: aPortfolio 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:12:48' prior: 50759079!
assertIfIncludes: aPortfolio 
	! !
!Portfolio methodsFor: 'accessing' stamp: 'DR 10/18/2019 20:15:21' prior: 50759070!
add: anElementToAdd
	
	self assertIfincludes: anElementToAdd.
	anElementToAdd assertIfincludes: self.
	
	anElementToAdd addParent: self.
	contents add: anElementToAdd. 
	

! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:16:06'!
assertIfincludes: aPortfolio 
	! !

ReceptiveAccount removeSelector: #assertIfincludes:!
!Portfolio methodsFor: 'accessing' stamp: 'DR 10/18/2019 20:16:33' prior: 50759089!
add: anElementToAdd
	
	self assertIfIncludes: anElementToAdd.
	anElementToAdd assertIfIncludes: self.
	
	anElementToAdd addParent: self.
	contents add: anElementToAdd. 
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'DR 10/18/2019 20:16:39'!
assertIfIncludes: anElementToAdd.
	
	self roots detect:   [:aRoot | aRoot includes: anElementToAdd. ] 
	                ifFound: [ :rootThatHasElement | self error: self class cannotAddAnExistentAccountError. ]
		  	    ifNone:   [ 
				(self includes: anElementToAdd) ifTrue: [ self error: self class cannotAddAnExistentAccountError. ].
			    ].
	
	

! !

Portfolio removeSelector: #assertIfincludes:!
!Portfolio methodsFor: 'accessing' stamp: 'DR 10/18/2019 20:19:30' prior: 50759104!
add: anElementToAdd
	
	self assertIfIncludes: anElementToAdd.
	
	anElementToAdd addParent: self.
	contents add: anElementToAdd. 
	

! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:23:33' prior: 50759085!
assertIfIncludes: anElement

 
	! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:24:12' prior: 50759136!
assertIfIncludes: anElement

	 
	! !

----SNAPSHOT----(18 October 2019 20:27:46) clase2.image priorSource: 13667705!

----QUIT----(18 October 2019 20:27:58) clase2.image priorSource: 13679812!

----STARTUP---- (18 October 2019 20:29:43) as /home/dago/Documents/Facultad/isw1/isw1/linux64/clase2.image!

!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:32:29' prior: 50757684!
test02PortfolioWithOneAccountReturnsBalanceOfThatAccount
	
	| portfolio account |

	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
	
	portfolio := Portfolio new.
	portfolio add: account.
	
	self addAccountWith: 100 toPortfolio: portfolio 
	
	self assert: portfolio  balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:33:52'!
addAccountWith: anAmount toPortfolio: aPortfolio 
	
	| account |

	account := ReceptiveAccount  new.
	Deposit register: anAmount on: account.
	
	aPortfolio add: account.
	^aPortfolio .
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:34:20' prior: 50759154!
test02PortfolioWithOneAccountReturnsBalanceOfThatAccount
	
	| portfolio |

	portfolio := Portfolio new.

	self addAccountWith: 100 toPortfolio: portfolio.
	
	self assert: portfolio  balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 20:36:39' prior: 50757723!
test03PortfolioWithTwoAccountsReturnsBalanceOfBothAccounts
	
	| portfolio |
	
	portfolio := Portfolio new.
	self addAccountWith: 100 toPortfolio: portfolio.
	self addAccountWith: 50 toPortfolio: portfolio.
		
	self assert: portfolio  balance equals: 150.
	! !

----SNAPSHOT----(18 October 2019 20:37:01) clase2.image priorSource: 13679892!

----QUIT----(18 October 2019 20:37:05) clase2.image priorSource: 13681475!

----STARTUP---- (18 October 2019 21:31:32) as /home/dago/Documents/Facultad/isw1/isw1/linux64/clase2.image!

!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 21:33:49' prior: 50757766!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio portfolioToInclude |

	portfolioToInclude := Portfolio new.
	portfolio := Portfolio new.
	
	self addAccountWith: 100 toPortfolio: portfolioToInclude.
	
	portfolio add: portfolioToInclude.
		
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 21:35:22' prior: 50759206!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio portfolioToInclude |

	portfolioToInclude := Portfolio new.
	portfolio := Portfolio new.
	
	self addPortfolioWithAccountWith: 100 toPortfolio: portfolioToInclude.
	
	portfolio add: portfolioToInclude.
		
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 21:36:19'!
addPortfolioWithAccountWith: anAmount toPortfolio: aPortfolio
	
	| portfolio portfolioToInclude |

	portfolioToInclude := Portfolio new.
	portfolio := Portfolio new.
	
	
	portfolio add: portfolioToInclude.
		
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 21:36:54' prior: 50759232!
addPortfolioWithAccountWith: anAmount toPortfolio: aPortfolios
	
	| portfolio portfolioToInclude |

	portfolioToInclude := Portfolio new.
	portfolio := Portfolio new.
	
	
	portfolio add: portfolioToInclude.
		
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 21:37:03' prior: 50759244!
addPortfolioWithAccountWith: anAmount toPortfolio: aPortfolios
	
	| aPortfolio portfolioToInclude |

	portfolioToInclude := Portfolio new.
	aPortfolio := Portfolio new.
	
	
	aPortfolio add: portfolioToInclude.
		
	self assert: aPortfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 21:38:23' prior: 50759256!
addPortfolioWithAccountWith: anAmount toPortfolio: aPortfolio
	
	| portfolioToInclude |

	portfolioToInclude := Portfolio new.
	self addAccountWith: anAmount toPortfolio: portfolioToInclude .
	aPortfolio add: portfolioToInclude.
	^aPortfolio.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 21:39:17' prior: 50759219!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio |

	portfolio := Portfolio new.
	
	self addPortfolioWithAccountWith: 100 toPortfolio: portfolio.
		
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 21:41:06' prior: 50757805!
test05PortfolioWithTwoPortfoliosHasBalanceOfBothPortfolios
	
	| portfolio portfolioToInclude anotherPortfolioToInclude |
	
	portfolioToInclude := Portfolio new.
	anotherPortfolioToInclude := Portfolio new.
	
	self addPortfolioWithAccountWith: 100 toPortfolio: portfolioToInclude.
	self addPortfolioWithAccountWith: 50 toPortfolio: anotherPortfolioToInclude .
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	portfolio add: anotherPortfolioToInclude.
		
	self assert: portfolio balance equals: 150.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 21:42:25' prior: 50757711!
test07PortfolioWithOneAccountHasTransactionsOfThatAccount

	| portfolio account |
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
	
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: portfolio transactions equals: account transactions .
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 21:44:13' prior: 50758207!
test12AddingAnAccountToAPortfolioThatAlreadyHasItRaisesError

	| portfolio anAccount |
	
	portfolio := Portfolio new.
	self addAccountWith: 100 toPortfolio: portfolio .
	
	self should: [ portfolio add: anAccount. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'DR 10/18/2019 21:45:16' prior: 50759321!
test12AddingAnAccountToAPortfolioThatAlreadyHasItRaisesError

	| portfolio anAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount .
	
	self should: [ portfolio add: anAccount. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.
	! !

----SNAPSHOT----(18 October 2019 21:45:35) clase2.image priorSource: 13681555!

----QUIT----(18 October 2019 21:45:41) clase2.image priorSource: 13686441!

----STARTUP---- (18 October 2019 22:27:59) as /home/melissa/Mel/college shit/Ingeniera de Software I/isw1/linux64/clase2.image!


ReceptiveAccount removeSelector: #assertIfIncludes:!
!ReceptiveAccount methodsFor: 'testing' stamp: 'mr 10/18/2019 23:31:16'!
hasElementsInCommonWith: anElementToInclude

	^ self = anElementToInclude.

	! !
!BankContainersXX methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 23:31:16'!
hasElementsInCommonWith: anElement

	self subclassResponsibility .! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 23:31:16'!
hasElementsInCommonWith: anElementToInclude
	
	^ self = anElementToInclude or: [ contents detect: [:anElem | anElem includes: anElementToInclude ] ifNone: [ ^ false ].
									   ^ true. ]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 23:31:16' prior: 50758166!
hasRegistered: aTransaction 
	
	^ self transactions hasElementsInCommonWith: aTransaction .! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 23:31:16' prior: 50758910!
includes: anElementToInclude
	
	^ self = anElementToInclude or: [ contents detect: [:anElem | anElem hasElementsInCommonWith: anElementToInclude ] ifNone: [ ^ false ].
									   ^ true. ]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 23:31:16' prior: 50759112!
assertIfIncludes: anElementToAdd.
	
	self roots detect:   [:aRoot | aRoot hasElementsInCommonWith: anElementToAdd. ] 
	                ifFound: [ :rootThatHasElement | self error: self class cannotAddAnExistentAccountError. ]
		  	    ifNone:   [ 
				(self hasElementsInCommonWith: anElementToAdd) ifTrue: [ self error: self class cannotAddAnExistentAccountError. ].
			    ].
	
	

! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 23:31:16' prior: 50757039!
hasRegistered: aTransaction

	^ transactions hasElementsInCommonWith: aTransaction 
! !
!ReceptiveAccountTest methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 23:31:16' prior: 50756904!
test07AccountKnowsItsTransactions 

	| account1 deposit1 |
	
	account1 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 100 on: account1.
		
	self assert: 1 equals: account1 transactions size .
	self assert: (account1 transactions hasElementsInCommonWith: deposit1).
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 23:31:16' prior: 50759374!
hasElementsInCommonWith: anElementToInclude
	
	^ self = anElementToInclude or: [ contents detect: [:anElem | anElem hasElementsInCommonWith: anElementToInclude ] ifNone: [ ^ false ].
									   ^ true. ]! !

ReceptiveAccount removeSelector: #includes:!

BankContainersXX removeSelector: #includes:!

Portfolio removeSelector: #includes:!
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 23:32:22'!
includes: anElementToInclude

	! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 23:32:46' prior: 50759446!
includes: anElementToInclude

	^ self = anElementToInclude or: [ contents detect: [:anElem | anElem hasElementsInCommonWith: anElementToInclude ] ifNone: [ ^ false ].
									   ^ true. ]

	! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 23:33:51' prior: 50759433!
hasElementsInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [ self includes: anElementToInclude ]. 
	! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'mr 10/18/2019 23:35:13'!
includes: anElementToInclude

	^ (anElementToInclude includes: self) or: [  ]! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'mr 10/18/2019 23:35:19' prior: 50759466!
includes: anElementToInclude

	! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'mr 10/18/2019 23:35:33' prior: 50759472!
includes: anElementToInclude

	^ self = anElementToInclude.

	! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'mr 10/18/2019 23:35:52' prior: 50759363!
hasElementsInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [ self includes: anElementToInclude ].

	! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 23:37:29' prior: 50759459!
hasElementsInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [ 
		
		self : anElementToInclude 
	
	   ]. 
	! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 23:42:45' prior: 50759488!
hasElementsInCommonWith: anElementToInclude

	"^ (anElementToInclude includes: self) or: ["
	contents detect: [ :anElem | anElem hasElementsInCommonWith: anElementToInclude ] ifNone: [ ^ false ].
		^ true.
		"]."
! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 23:43:02' prior: 50759495!
hasElementsInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [
		contents detect: [ :anElem | anElem hasElementsInCommonWith: anElementToInclude ] ifNone: [ ^ false ].
		^ true.
	].
! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 23:43:37' prior: 50759450!
includes: anElementToInclude

	^ self = anElementToInclude or: [ contents detect: [:anElem | anElem includes: anElementToInclude ] ifNone: [ ^ false ].
									   ^ true. ]

	! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'mr 10/18/2019 23:44:42' prior: 50759481!
hasElementsInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [ self includes: anElementToInclude ].

	! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 23:47:50' prior: 50759383!
hasRegistered: aTransaction 
	
	^ self transactions includes: aTransaction .! !
!Portfolio methodsFor: 'asserts' stamp: 'mr 10/18/2019 23:54:11' prior: 50759398!
assertIfIncludes: anElementToAdd.
	
	self roots detect:   [:aRoot | aRoot hasElementsInCommonWith: anElementToAdd. ] 
	                ifFound: [ :rootThatHasElement | self error: self class cannotAddAnExistentAccountError. ]
		  	    ifNone:   [ 
				"(self hasElementsInCommonWith: anElementToAdd) ifTrue: [ self error: self class cannotAddAnExistentAccountError. ]."
			    ].
	
	

! !
!Portfolio methodsFor: 'asserts' stamp: 'mr 10/18/2019 23:59:32' prior: 50759537!
assertIfIncludes: anElementToAdd.
	
	self roots detect:   [:aRoot | aRoot hasElementsInCommonWith: anElementToAdd. ] 
		  	    ifNone:   [ ^ self. ].
	
	self error: self class cannotAddAnExistentAccountError.	
	

! !
!Portfolio methodsFor: 'asserts' stamp: 'mr 10/18/2019 23:59:37' prior: 50759552!
assertIfIncludes: anElementToAdd.
	
	self roots detect:   [ :aRoot | aRoot hasElementsInCommonWith: anElementToAdd. ] 
		  	    ifNone:   [ ^ self. ].
	
	self error: self class cannotAddAnExistentAccountError.	
	

! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/19/2019 00:01:35' prior: 50759515!
includes: anElementToInclude

	^ self = anElementToInclude or: [ contents detect: [:anElem | anElem includes: anElementToInclude ] ifFound: [ ^ true. ] ifNone: [ ^ false ] ]

	! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/19/2019 00:06:06' prior: 50759572!
includes: anElementToInclude

	^ self = anElementToInclude or: [ contents anySatisfy: [:anElem | anElem includes: anElementToInclude ] ]

	! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/19/2019 00:06:10' prior: 50759581!
includes: anElementToInclude

	^ self = anElementToInclude or: [ contents anySatisfy: [:anElem | anElem includes: anElementToInclude ] ].

	! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/19/2019 00:06:43' prior: 50759505!
hasElementsInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [
		contents anySatisfy: [ :anElem | anElem hasElementsInCommonWith: anElementToInclude ] ].
! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/19/2019 00:06:52' prior: 50759597!
hasElementsInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [ contents anySatisfy: [ :anElem | anElem hasElementsInCommonWith: anElementToInclude ] ].
! !
!BankContainersXX methodsFor: 'testing - private' stamp: 'mr 10/19/2019 00:14:37'!
includes: anElement

	self subclassResponsibility .! !
!BankContainersXX methodsFor: 'nil' stamp: 'mr 10/19/2019 00:15:05'!
transactions

	self subclassResponsibility.! !
!BankContainersXX methodsFor: 'as yet unclassified' stamp: 'mr 10/19/2019 00:15:10'!
balance

	self subclassResponsibility.! !
!BankContainersXX methodsFor: 'as yet unclassified' stamp: 'mr 10/19/2019 00:15:24'!
hasRegistered: aTransaction

	self subclassResponsibility.! !

----SNAPSHOT----(19 October 2019 00:20:03) clase2.image priorSource: 13686521!

----QUIT----(19 October 2019 00:20:17) clase2.image priorSource: 13695421!

----STARTUP---- (21 October 2019 14:38:45) as /home/mregnier/isw1/linux64/clase2.image!

!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 14:41:44' prior: 50758183!
test11PortfolioWithAccountAndPortfolioHasRegisteredTheirTransactions

	| portfolio anAccount aTransaction |
	anAccount := ReceptiveAccount  new.
	aTransaction := Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	self assert: (portfolio hasRegistered: aTransaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 14:42:20'!
test03PortfolioWithManyAccountsReturnsBalanceOfAllAccounts
	
	| portfolio |
	
	portfolio := Portfolio new.
	self addAccountWith: 100 toPortfolio: portfolio.
	self addAccountWith: 50 toPortfolio: portfolio.
		
	self assert: portfolio  balance equals: 150.
	! !

PortfolioTest removeSelector: #test03PortfolioWithTwoAccountsReturnsBalanceOfBothAccounts!
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 14:42:38'!
test05PortfolioWithManyPortfoliosHasBalanceOfAllPortfolios
	
	| portfolio portfolioToInclude anotherPortfolioToInclude |
	
	portfolioToInclude := Portfolio new.
	anotherPortfolioToInclude := Portfolio new.
	
	self addPortfolioWithAccountWith: 100 toPortfolio: portfolioToInclude.
	self addPortfolioWithAccountWith: 50 toPortfolio: anotherPortfolioToInclude .
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	portfolio add: anotherPortfolioToInclude.
		
	self assert: portfolio balance equals: 150.
	! !

PortfolioTest removeSelector: #test05PortfolioWithTwoPortfoliosHasBalanceOfBothPortfolios!
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 14:42:56'!
test08PortfolioWithManyAccountsHasTransactionsOfAllAccounts

	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
	
	self assert: portfolio transactions equals: (anAccount transactions addAllLast: anotherAccount transactions) .
	! !

PortfolioTest removeSelector: #test08PortfolioWithTwoAccountsHasTransactionsOfBothAccounts!
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 14:47:38' prior: 50759641!
test11PortfolioWithAccountAndPortfolioHasRegisteredTheirTransactions

	| portfolio anotherPortfolio anAccount anotherAccount aTransaction anotherTransaction |
	
	anAccount := ReceptiveAccount  new.
	aTransaction := Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	anotherTransaction := Deposit register: 150 on: anotherAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherPortfolio.
	
	self assert: (portfolio hasRegistered: aTransaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 14:48:01' prior: 50759711!
test11PortfolioWithAccountAndPortfolioHasRegisteredTheirTransactions

	| portfolio anotherPortfolio anAccount anotherAccount aTransaction anotherTransaction |
	
	anAccount := ReceptiveAccount  new.
	aTransaction := Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	anotherTransaction := Deposit register: 150 on: anotherAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherPortfolio.
	
	self assert: (portfolio hasRegistered: aTransaction).
	self assert: (portfolio hasRegistered: anotherTransaction ).! !

anAccount transactions!

anotherAccount transactions!

anotherPortfolio transactions!

portfolio transactions!

portfolio hasRegistered: aTransaction!

portfolio transactions!

self transactions!

self transactions!

anElem transactions!

anElem transactions!

collectionOfTransactions!

collectionOfTransactions!

----SNAPSHOT----(21 October 2019 14:55:34) clase2.image priorSource: 13695501!

Smalltalk removeClassNamed: #ReceptiveAccount!

Smalltalk removeClassNamed: #Portfolio!

Smalltalk removeClassNamed: #BankContainersXX!

Smalltalk removeClassNamed: #Withdraw!

Smalltalk removeClassNamed: #Deposit!

Smalltalk removeClassNamed: #AccountTransaction!

Smalltalk removeClassNamed: #ReceptiveAccountTest!

Smalltalk removeClassNamed: #PortfolioTest!

----End fileIn of /home/mregnier/isw1/linux64/Portfolio-Ejercicio2.st----!

portfolio transactions!
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 14:59:39' prior: 50760274!
transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	
	^ contents inject: transactions into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: anElem transactions ].! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:00:00' prior: 50760395!
transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	
	contents inject: transactions into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: anElem transactions ].
	
	^ transactions.! !

collection addAllLast: otherCollection.!


|collection otherCollection|

collection := OrderedCollection new.
otherCollection := OrderedCollection new.
otherCollection add: 1.



collection addAllLast: otherCollection.!

|collection otherCollection|

collection := OrderedCollection new.
collection add: 2.

otherCollection := OrderedCollection new.
otherCollection add: 1.

collection addAllLast: otherCollection.!
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:03:58' prior: 50760405!
transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	
	contents inject: transactions into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: anElem transactions; self ].
	
	^ transactions.! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:04:05' prior: 50760428!
transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	
	contents inject: transactions into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: anElem transactions; yourself ].
	
	^ transactions.! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:04:58' prior: 50760439!
transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	
	contents inject: transactions into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: (anElem transactions); yourself ].
	
	^ transactions.! !

	transactions addAllLast: transactions2; yourself.!

| transactions transactions2 |
	
	transactions := OrderedCollection new.
	transactions add: 1.
	
	transactions2 :=OrderedCollection new.
	transactions2 add: 2.
	
	transactions addAllLast: transactions2; yourself.
!

	transactions addAllLast: transactions2.!

| transactions transactions2 |
	
	transactions := OrderedCollection new.
	transactions add: 1.
	
	transactions2 :=OrderedCollection new.
	transactions2 add: 2.
	
	transactions addAllLast: transactions2.!

	transactions union: transactions2.!

| transactions transactions2 |
	
	transactions := OrderedCollection new.
	transactions add: 1.
	
	transactions2 :=OrderedCollection new.
	transactions2 add: 2.
	
	transactions addAllLast: transactions2.
	
	transactions union: transactions2.
!

| transactions transactions2 |
	
	transactions := OrderedCollection new.
	transactions add: 1.
	
	transactions2 :=OrderedCollection new.
	transactions2 add: 2.
		
	transactions union: transactions2.
!

| transactions transactions2 |
	
	transactions := OrderedCollection new.
	transactions add: 1.
	
	transactions2 :=OrderedCollection new.
	transactions2 add: 2.
	
	transactions addAllLast: transactions2; yourself.!

portfolio transactions.!

anAccount transactions!
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 15:11:25' prior: 50759883!
test08PortfolioWithManyAccountsHasTransactionsOfAllAccounts

	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
	
	self assert: portfolio transactions includes: anAccount transactions.
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 15:12:40' prior: 50760500!
test08PortfolioWithManyAccountsHasTransactionsOfAllAccounts

	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
	
	self assert: (portfolio transactions includesAllOf: anAccount transactions).
	self assert: (portfolio transactions includesAllOf: anotherAccount transactions).
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 15:13:36' prior: 50759900!
test09PortfolioWithOnePortfolioHasTransactionsOfThePortfolio

	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	
	self assert: (portfolio transactions includesAllOf: portfolioToInclude transactions) .
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 15:13:45' prior: 50760536!
test09PortfolioWithOnePortfolioHasTransactionsOfThePortfolio

	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	
	self assert: (portfolio transactions includesAllOf: portfolioToInclude transactions).
	! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'mr 10/21/2019 15:17:35' prior: 50760101!
test07AccountKnowsItsTransactions 

	| account1 deposit1 |
	
	account1 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 100 on: account1.
		
	self assert: 1 equals: account1 transactions size .
	self assert: (account1 transactions includes: deposit1).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'mr 10/21/2019 15:17:55' prior: 50760089!
test06ReceptiveAccountDoNotKnowNotRegisteredTransactions

	| account deposit withdraw |
	
	account := ReceptiveAccount new.
	deposit :=  Deposit for: 100.
	withdraw := Withdraw for: 50.
		
	self deny: (account hasRegistered: deposit).
	self deny: (account hasRegistered: withdraw).
! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'mr 10/21/2019 15:18:18' prior: 50760364!
hasRegistered: aTransaction

	^ transactions includes: aTransaction 
! !

BankEntity subclass: #Portfolio
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
BankEntity subclass: #Portfolio
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
BankEntity subclass: #Portfolio
	instanceVariableNames: 'contents entities'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:19:11' prior: 50760321!
includes: anElementToInclude

	^ self = anElementToInclude or: [ entities anySatisfy: [:anElem | anElem includes: anElementToInclude ] ].

	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:19:11' prior: 50760312!
hasElementsInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [ entities anySatisfy: [ :anElem | anElem hasElementsInCommonWith: anElementToInclude ] ].
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:19:11' prior: 50760282!
initialize

	entities := OrderedCollection new.
	parents := OrderedCollection new.
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:19:11' prior: 50760262!
add: anElementToAdd
	
	self assertIfIncludes: anElementToAdd.
	
	anElementToAdd addParent: self.
	entities add: anElementToAdd. 
	

! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:19:11' prior: 50760450!
transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	
	entities inject: transactions into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: (anElem transactions); yourself ].
	
	^ transactions.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:19:11' prior: 50760269!
balance
	
	^ (entities sum: [ :anElement | anElement balance ] ifEmpty: [ 0 ]).! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
BankEntity subclass: #Portfolio
	instanceVariableNames: 'entities'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

TestCase subclass: #BankEntityTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #BankEntityTest category: #'Portfolio-Ejercicio'!
TestCase subclass: #BankEntityTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

BankEntity subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio'!
BankEntity subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

BankEntityTest subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio'!
BankEntityTest subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

BankEntityTest subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccountTest category: #'Portfolio-Ejercicio'!
BankEntityTest subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'operations' stamp: 'mr 10/21/2019 15:20:31' prior: 50760639!
add: anEntityToAdd
	
	self assertIfIncludes: anEntityToAdd.
	
	anEntityToAdd addParent: self.
	entities add: anEntityToAdd. 
	

! !
!Portfolio methodsFor: 'asserts - private' stamp: 'mr 10/21/2019 15:20:51' prior: 50760302!
assertIfIncludes: anEntityToAdd.
	
	self roots detect:   [ :aRoot | aRoot hasElementsInCommonWith: anEntityToAdd. ] 
		  	    ifNone:   [ ^ self. ].
	
	self error: self class cannotAddAnExistentAccountError.	
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:21:03' prior: 50760658!
balance
	
	^ (entities sum: [ :anEntity | anEntity balance ] ifEmpty: [ 0 ]).! !
!Portfolio methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:21:14' prior: 50760624!
hasElementsInCommonWith: anEntityToInclude

	^ (anEntityToInclude includes: self) or: [ entities anySatisfy: [ :anElem | anElem hasElementsInCommonWith: anEntityToInclude ] ].
! !
!Portfolio methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:21:28' prior: 50760739!
hasElementsInCommonWith: anEntityToInclude

	^ (anEntityToInclude includes: self) or: [ entities anySatisfy: [ :anEntity | anEntity hasElementsInCommonWith: anEntityToInclude ] ].
! !
!Portfolio methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:21:50' prior: 50760616!
includes: anEntityToInclude

	^ self = anEntityToInclude or: [ entities anySatisfy: [:anElem | anElem includes: anEntityToInclude ] ].

	! !
!Portfolio methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:22:00' prior: 50760757!
includes: anEntityToInclude

	^ self = anEntityToInclude or: [ entities anySatisfy: [:anEntity | anEntity includes: anEntityToInclude ] ].

	! !

emptyPortfolio roots!
!Portfolio methodsFor: 'accessing - private' stamp: 'mr 10/21/2019 15:25:13' prior: 50760292!
roots

	| roots |
	
	roots := OrderedCollection new.
	parents isEmpty ifTrue: [ 
		roots add: self.
		^ roots ].
	
	parents inject: roots
			 into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: (aParent roots); yourself. ].
	
	^ roots.
! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:25:40' prior: 50760647!
transactions
	
	^ entities inject: OrderedCollection new into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: (anElem transactions); yourself ].
! !

emptyPortfolio roots!
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:28:51' prior: 50760785!
transactions
	
	^ entities inject: OrderedCollection new into: [ :collectionOfTransactions :anEntity | collectionOfTransactions addAllLast: (anEntity transactions); yourself ].
! !
!Deposit methodsFor: 'value' stamp: 'mr 10/21/2019 15:30:26'!
valueForBalance

	^ value.! !

Deposit removeSelector: #xxxvalue!
!Withdraw methodsFor: 'value' stamp: 'mr 10/21/2019 15:30:45'!
valueForBalance

	^ value negated.! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:30:45' prior: 50760370!
balance

	^transactions sum: [ :aTransaction | aTransaction valueForBalance ] ifEmpty: [ 0 ]! !

Withdraw removeSelector: #xxxvalue!
!AccountTransaction methodsFor: 'nil' stamp: 'mr 10/21/2019 15:31:07'!
valueForBalance

	self subclassResponsibility.! !
!BankEntity methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:36:02'!
hasEntitiesInCommonWith: anElement

	self subclassResponsibility .! !
!ReceptiveAccount methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:36:02'!
hasEntitiesInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [ self includes: anElementToInclude ].

	! !
!Portfolio methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:36:02'!
hasEntitiesInCommonWith: anEntityToInclude

	^ (anEntityToInclude includes: self) or: [ entities anySatisfy: [ :anEntity | anEntity hasElementsInCommonWith: anEntityToInclude ] ].
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:36:02' prior: 50760748!
hasElementsInCommonWith: anEntityToInclude

	^ (anEntityToInclude includes: self) or: [ entities anySatisfy: [ :anEntity | anEntity hasEntitiesInCommonWith: anEntityToInclude ] ].
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:36:02' prior: 50760723!
assertIfIncludes: anEntityToAdd.
	
	self roots detect:   [ :aRoot | aRoot hasEntitiesInCommonWith: anEntityToAdd. ] 
		  	    ifNone:   [ ^ self. ].
	
	self error: self class cannotAddAnExistentAccountError.	
	

! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:36:02' prior: 50760835!
hasEntitiesInCommonWith: anEntityToInclude

	^ (anEntityToInclude includes: self) or: [ entities anySatisfy: [ :anEntity | anEntity hasEntitiesInCommonWith: anEntityToInclude ] ].
! !

BankEntity removeSelector: #hasElementsInCommonWith:!

ReceptiveAccount removeSelector: #hasElementsInCommonWith:!

Portfolio removeSelector: #hasElementsInCommonWith:!

----STARTUP---- (21 October 2019 15:44:17) as /home/mregnier/isw1/linux64/clase2.image!


Smalltalk removeClassNamed: #ReceptiveAccount!

Smalltalk removeClassNamed: #Portfolio!

Smalltalk removeClassNamed: #BankContainersXX!

Smalltalk removeClassNamed: #Withdraw!

Smalltalk removeClassNamed: #Deposit!

Smalltalk removeClassNamed: #AccountTransaction!

Smalltalk removeClassNamed: #ReceptiveAccountTest!

Smalltalk removeClassNamed: #PortfolioTest!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'testing - private' stamp: 'DR 10/18/2019 20:33:52'!
addAccountWith: anAmount toPortfolio: aPortfolio 
	
	| account |

	account := ReceptiveAccount  new.
	Deposit register: anAmount on: account.
	
	aPortfolio add: account.
	^aPortfolio .
	! !
!PortfolioTest methodsFor: 'testing - private' stamp: 'DR 10/18/2019 21:38:23'!
addPortfolioWithAccountWith: anAmount toPortfolio: aPortfolio
	
	| portfolioToInclude |

	portfolioToInclude := Portfolio new.
	self addAccountWith: anAmount toPortfolio: portfolioToInclude .
	aPortfolio add: portfolioToInclude.
	^aPortfolio.
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'D 10/17/2019 18:50:52'!
test01EmptyPortfolioHasZeroBalance
	
	| emptyPortfolio |
	
	emptyPortfolio := Portfolio new.
	
	self assert: emptyPortfolio  balance isZero.
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'DR 10/18/2019 20:34:20'!
test02PortfolioWithOneAccountReturnsBalanceOfThatAccount
	
	| portfolio |

	portfolio := Portfolio new.

	self addAccountWith: 100 toPortfolio: portfolio.
	
	self assert: portfolio  balance equals: 100.
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 14:42:20'!
test03PortfolioWithManyAccountsReturnsBalanceOfAllAccounts
	
	| portfolio |
	
	portfolio := Portfolio new.
	self addAccountWith: 100 toPortfolio: portfolio.
	self addAccountWith: 50 toPortfolio: portfolio.
		
	self assert: portfolio  balance equals: 150.
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'DR 10/18/2019 21:39:17'!
test04PortfolioWithAPortfolioHasBalanceOfThePortfolio
	
	| portfolio |

	portfolio := Portfolio new.
	
	self addPortfolioWithAccountWith: 100 toPortfolio: portfolio.
		
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 14:42:38'!
test05PortfolioWithManyPortfoliosHasBalanceOfAllPortfolios
	
	| portfolio portfolioToInclude anotherPortfolioToInclude |
	
	portfolioToInclude := Portfolio new.
	anotherPortfolioToInclude := Portfolio new.
	
	self addPortfolioWithAccountWith: 100 toPortfolio: portfolioToInclude.
	self addPortfolioWithAccountWith: 50 toPortfolio: anotherPortfolioToInclude .
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	portfolio add: anotherPortfolioToInclude.
		
	self assert: portfolio balance equals: 150.
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'D 10/17/2019 19:51:13'!
test06EmptyPortfolioHasNoTransactions
	
	| portfolio |
	
	portfolio := Portfolio new.
		
	self assert: portfolio transactions isEmpty.
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'DR 10/18/2019 21:42:25'!
test07PortfolioWithOneAccountHasTransactionsOfThatAccount

	| portfolio account |
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
	
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: portfolio transactions equals: account transactions .
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 14:42:56'!
test08PortfolioWithManyAccountsHasTransactionsOfAllAccounts

	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
	
	self assert: portfolio transactions equals: (anAccount transactions addAllLast: anotherAccount transactions) .
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'D 10/17/2019 20:21:31'!
test09PortfolioWithOnePortfolioHasTransactionsOfThePortfolio

	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	
	self assert: portfolio transactions equals: portfolioToInclude transactions .
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'D 10/17/2019 20:36:56'!
test10EmptyPortfolioHasNoRegisteredTransactions

	| portfolio anAccount aTransaction |
	anAccount := ReceptiveAccount  new.
	aTransaction := Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.

	
	self deny: (portfolio hasRegistered: aTransaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 14:48:01'!
test11PortfolioWithAccountAndPortfolioHasRegisteredTheirTransactions

	| portfolio anotherPortfolio anAccount anotherAccount aTransaction anotherTransaction |
	
	anAccount := ReceptiveAccount  new.
	aTransaction := Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	anotherTransaction := Deposit register: 150 on: anotherAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherPortfolio.
	
	self assert: (portfolio hasRegistered: aTransaction).
	self assert: (portfolio hasRegistered: anotherTransaction ).! !
!PortfolioTest methodsFor: 'tests' stamp: 'DR 10/18/2019 21:45:16'!
test12AddingAnAccountToAPortfolioThatAlreadyHasItRaisesError

	| portfolio anAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount .
	
	self should: [ portfolio add: anAccount. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/18/2019 18:54:19'!
test13AddingToAnEmptyPortfolioRegisteredInTwoPortfoliosAnAccountRegisteredInOneOfThemRaisesError

	| portfolio anAccount anotherAccount anotherPortfolio emptyPortfolio |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 150 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anotherAccount.
	
	emptyPortfolio := Portfolio new.
	
	portfolio add: emptyPortfolio.
	anotherPortfolio add: emptyPortfolio.
	
	self should: [ emptyPortfolio add: anAccount. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: emptyPortfolio balance equals: 0.	! !
!PortfolioTest methodsFor: 'tests' stamp: 'DR 10/18/2019 20:04:33'!
test14APortfolioCannotIncludeAndHimselfShouldRaiseError

	| portfolio anAccount |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	self should: [ portfolio add: portfolio. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.	! !
!PortfolioTest methodsFor: 'tests' stamp: 'DR 10/18/2019 20:05:33'!
test15APortfolioWithAnAccountCannotAddAnotherPortfolioWithTheSameAccountAndShouldRaiseError

	| portfolio anAccount anotherPortfolio |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anAccount.
	
	self should: [ portfolio add: anotherPortfolio. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentAccountError.
	
	self assert: portfolio balance equals: 100.	! !

!classDefinition: #ReceptiveAccountTest category: #'Portfolio-Ejercicio'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccountTest category: #'Portfolio-Ejercicio'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:19:48'!
test01ReceptiveAccountHaveZeroAsBalanceWhenCreated 

	| account |
	
	account := ReceptiveAccount new.

	self assert: 0 equals: account balance .
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:19:54'!
test02DepositIncreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
		
	self assert: 100 equals: account balance .
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:02'!
test03WithdrawDecreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	Withdraw register: 50 on: account.
		
	self assert: 50 equals: account balance .
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:32'!
test04WithdrawValueMustBePositive 

	| account withdrawValue |
	
	account := ReceptiveAccount new.
	withdrawValue := 50.
	
	self assert: withdrawValue equals: (Withdraw register: withdrawValue on: account) value
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:46'!
test05ReceptiveAccountKnowsRegisteredTransactions 

	| account deposit withdraw |
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	withdraw := Withdraw register: 50 on: account.
		
	self assert: (account hasRegistered: deposit).
	self assert: (account hasRegistered: withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:54'!
test06ReceptiveAccountDoNotKnowNotRegisteredTransactions

	| account deposit withdraw |
	
	account := ReceptiveAccount new.
	deposit :=  Deposit for: 100.
	withdraw := Withdraw for: 50.
		
	self deny: (account hasRegistered: deposit).
	self deny: (account hasRegistered:withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'mr 10/18/2019 23:31:16'!
test07AccountKnowsItsTransactions 

	| account1 deposit1 |
	
	account1 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 100 on: account1.
		
	self assert: 1 equals: account1 transactions size .
	self assert: (account1 transactions hasElementsInCommonWith: deposit1).
! !

!classDefinition: #AccountTransaction category: #'Portfolio-Ejercicio'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountTransaction category: #'Portfolio-Ejercicio'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountTransaction methodsFor: 'value' stamp: 'HernanWilkinson 9/12/2011 12:25'!
value 

	self subclassResponsibility ! !

!classDefinition: 'AccountTransaction class' category: #'Portfolio-Ejercicio'!
AccountTransaction class
	instanceVariableNames: ''!

!classDefinition: 'AccountTransaction class' category: #'Portfolio-Ejercicio'!
AccountTransaction class
	instanceVariableNames: ''!
!AccountTransaction class methodsFor: 'instance creation' stamp: 'NR 10/17/2019 03:22:00'!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction! !

!classDefinition: #Deposit category: #'Portfolio-Ejercicio'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Deposit category: #'Portfolio-Ejercicio'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Deposit methodsFor: 'initialization' stamp: 'HernanWilkinson 7/13/2011 18:45'!
initializeFor: aValue

	value := aValue ! !
!Deposit methodsFor: 'value' stamp: 'HernanWilkinson 7/13/2011 18:38'!
value

	^ value! !
!Deposit methodsFor: 'value' stamp: 'D 10/17/2019 18:44:30'!
xxxvalue

	^ value.! !

!classDefinition: 'Deposit class' category: #'Portfolio-Ejercicio'!
Deposit class
	instanceVariableNames: ''!

!classDefinition: 'Deposit class' category: #'Portfolio-Ejercicio'!
Deposit class
	instanceVariableNames: ''!
!Deposit class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:38'!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #Withdraw category: #'Portfolio-Ejercicio'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Withdraw category: #'Portfolio-Ejercicio'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Withdraw methodsFor: 'initialization' stamp: 'HernanWilkinson 7/13/2011 18:46'!
initializeFor: aValue

	value := aValue ! !
!Withdraw methodsFor: 'value' stamp: 'HernanWilkinson 7/13/2011 18:33'!
value

	^ value! !
!Withdraw methodsFor: 'value' stamp: 'D 10/17/2019 19:11:14'!
xxxvalue

	^ value negated.! !

!classDefinition: 'Withdraw class' category: #'Portfolio-Ejercicio'!
Withdraw class
	instanceVariableNames: ''!

!classDefinition: 'Withdraw class' category: #'Portfolio-Ejercicio'!
Withdraw class
	instanceVariableNames: ''!
!Withdraw class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:33'!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #BankContainersXX category: #'Portfolio-Ejercicio'!
Object subclass: #BankContainersXX
	instanceVariableNames: 'parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #BankContainersXX category: #'Portfolio-Ejercicio'!
Object subclass: #BankContainersXX
	instanceVariableNames: 'parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!BankContainersXX methodsFor: 'operations - private' stamp: 'mr 10/18/2019 18:53:35'!
addParent: aParent

	parents add: aParent .! !
!BankContainersXX methodsFor: 'testing - private' stamp: 'mr 10/18/2019 23:31:16'!
hasElementsInCommonWith: anElement

	self subclassResponsibility .! !
!BankContainersXX methodsFor: 'testing - private' stamp: 'mr 10/19/2019 00:14:37'!
includes: anElement

	self subclassResponsibility .! !
!BankContainersXX methodsFor: 'testing' stamp: 'mr 10/19/2019 00:15:24'!
hasRegistered: aTransaction

	self subclassResponsibility.! !
!BankContainersXX methodsFor: 'accessing' stamp: 'mr 10/19/2019 00:15:10'!
balance

	self subclassResponsibility.! !
!BankContainersXX methodsFor: 'accessing' stamp: 'mr 10/19/2019 00:15:05'!
transactions

	self subclassResponsibility.! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
BankContainersXX subclass: #Portfolio
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
BankContainersXX subclass: #Portfolio
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'operations' stamp: 'DR 10/18/2019 20:19:30'!
add: anElementToAdd
	
	self assertIfIncludes: anElementToAdd.
	
	anElementToAdd addParent: self.
	contents add: anElementToAdd. 
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 19:59:30'!
balance
	
	^ (contents sum: [ :anElement | anElement balance ] ifEmpty: [ 0 ]).! !
!Portfolio methodsFor: 'accessing' stamp: 'D 10/17/2019 20:11:17'!
transactions
	
	^ contents inject: OrderedCollection new into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: anElem transactions ].! !
!Portfolio methodsFor: 'initialization' stamp: 'mr 10/18/2019 18:55:55'!
initialize

	contents := OrderedCollection new.
	parents := OrderedCollection new.
! !
!Portfolio methodsFor: 'testing' stamp: 'mr 10/18/2019 23:47:50'!
hasRegistered: aTransaction 
	
	^ self transactions includes: aTransaction .! !
!Portfolio methodsFor: 'accessing - private' stamp: 'DR 10/18/2019 19:54:54'!
roots

	| roots |
	
	roots := OrderedCollection new.
	parents isEmpty ifTrue: [ 
		roots add: self.
		^ roots ].
	
	parents inject: roots
			 into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: aParent roots. ].
	
	^ roots.
! !
!Portfolio methodsFor: 'asserts - private' stamp: 'mr 10/18/2019 23:59:37'!
assertIfIncludes: anElementToAdd.
	
	self roots detect:   [ :aRoot | aRoot hasElementsInCommonWith: anElementToAdd. ] 
		  	    ifNone:   [ ^ self. ].
	
	self error: self class cannotAddAnExistentAccountError.	
	

! !
!Portfolio methodsFor: 'testing - private' stamp: 'mr 10/19/2019 00:06:52'!
hasElementsInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [ contents anySatisfy: [ :anElem | anElem hasElementsInCommonWith: anElementToInclude ] ].
! !
!Portfolio methodsFor: 'testing - private' stamp: 'mr 10/19/2019 00:06:10'!
includes: anElementToInclude

	^ self = anElementToInclude or: [ contents anySatisfy: [:anElem | anElem includes: anElementToInclude ] ].

	! !

!classDefinition: 'Portfolio class' category: #'Portfolio-Ejercicio'!
Portfolio class
	instanceVariableNames: ''!

!classDefinition: 'Portfolio class' category: #'Portfolio-Ejercicio'!
Portfolio class
	instanceVariableNames: ''!
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'mr 10/18/2019 17:57:58'!
cannotAddAnExistentAccountError

	 ^ 'You cannot add an already existent account'! !

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio'!
BankContainersXX subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio'!
BankContainersXX subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccount methodsFor: 'initialization' stamp: 'mr 10/18/2019 18:25:20'!
initialize

	transactions := OrderedCollection new.
	parents := OrderedCollection new.! !
!ReceptiveAccount methodsFor: 'operations' stamp: 'D 10/17/2019 19:44:24'!
register: aTransaction

	transactions add: aTransaction 
! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'mr 10/18/2019 23:31:16'!
hasRegistered: aTransaction

	^ transactions hasElementsInCommonWith: aTransaction 
! !
!ReceptiveAccount methodsFor: 'accessing' stamp: 'D 10/17/2019 18:44:12'!
balance

	^transactions sum: [ :aTransaction | aTransaction xxxvalue ] ifEmpty: [ 0 ]! !
!ReceptiveAccount methodsFor: 'accessing' stamp: 'HernanWilkinson 7/13/2011 18:37'!
transactions 

	^ transactions copy! !
!ReceptiveAccount methodsFor: 'testing - private' stamp: 'mr 10/18/2019 23:44:42'!
hasElementsInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [ self includes: anElementToInclude ].

	! !
!ReceptiveAccount methodsFor: 'testing - private' stamp: 'mr 10/18/2019 23:35:33'!
includes: anElementToInclude

	^ self = anElementToInclude.

	! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 14:59:39' prior: 50761400!
transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	
	^ contents inject: transactions into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: anElem transactions ].! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:00:00' prior: 50761521!
transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	
	contents inject: transactions into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: anElem transactions ].
	
	^ transactions.! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:03:58' prior: 50761531!
transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	
	contents inject: transactions into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: anElem transactions; self ].
	
	^ transactions.! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:04:05' prior: 50761541!
transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	
	contents inject: transactions into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: anElem transactions; yourself ].
	
	^ transactions.! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:04:58' prior: 50761552!
transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	
	contents inject: transactions into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: (anElem transactions); yourself ].
	
	^ transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 15:11:25' prior: 50760996!
test08PortfolioWithManyAccountsHasTransactionsOfAllAccounts

	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
	
	self assert: portfolio transactions includes: anAccount transactions.
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 15:12:40' prior: 50761574!
test08PortfolioWithManyAccountsHasTransactionsOfAllAccounts

	| portfolio anAccount anotherAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 50 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	portfolio add: anotherAccount.
	
	self assert: (portfolio transactions includesAllOf: anAccount transactions).
	self assert: (portfolio transactions includesAllOf: anotherAccount transactions).
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 15:13:36' prior: 50761013!
test09PortfolioWithOnePortfolioHasTransactionsOfThePortfolio

	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	
	self assert: (portfolio transactions includesAllOf: portfolioToInclude transactions) .
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'mr 10/21/2019 15:13:45' prior: 50761610!
test09PortfolioWithOnePortfolioHasTransactionsOfThePortfolio

	| portfolio anAccount portfolioToInclude |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolioToInclude := Portfolio new.
	portfolioToInclude add: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: portfolioToInclude.
	
	self assert: (portfolio transactions includesAllOf: portfolioToInclude transactions).
	! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'mr 10/21/2019 15:17:35' prior: 50761216!
test07AccountKnowsItsTransactions 

	| account1 deposit1 |
	
	account1 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 100 on: account1.
		
	self assert: 1 equals: account1 transactions size .
	self assert: (account1 transactions includes: deposit1).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'mr 10/21/2019 15:17:55' prior: 50761204!
test06ReceptiveAccountDoNotKnowNotRegisteredTransactions

	| account deposit withdraw |
	
	account := ReceptiveAccount new.
	deposit :=  Deposit for: 100.
	withdraw := Withdraw for: 50.
		
	self deny: (account hasRegistered: deposit).
	self deny: (account hasRegistered: withdraw).
! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'mr 10/21/2019 15:18:18' prior: 50761493!
hasRegistered: aTransaction

	^ transactions includes: aTransaction 
! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
ProtoObject subclass: #Portfolio
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
ProtoObject subclass: #Portfolio
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
ProtoObject subclass: #Portfolio
	instanceVariableNames: 'contents entities'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:19:11' prior: 50761447!
includes: anElementToInclude

	^ self = anElementToInclude or: [ entities anySatisfy: [:anElem | anElem includes: anElementToInclude ] ].

	! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:19:11' prior: 50761438!
hasElementsInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [ entities anySatisfy: [ :anElem | anElem hasElementsInCommonWith: anElementToInclude ] ].
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:19:11' prior: 50761408!
initialize

	entities := OrderedCollection new.
	parents := OrderedCollection new.
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:19:11' prior: 50761388!
add: anElementToAdd
	
	self assertIfIncludes: anElementToAdd.
	
	anElementToAdd addParent: self.
	entities add: anElementToAdd. 
	

! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:19:11' prior: 50761563!
transactions
	
	| transactions |
	
	transactions := OrderedCollection new.
	
	entities inject: transactions into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: (anElem transactions); yourself ].
	
	^ transactions.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:19:11' prior: 50761395!
balance
	
	^ (entities sum: [ :anElement | anElement balance ] ifEmpty: [ 0 ]).! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio'!
ProtoObject subclass: #Portfolio
	instanceVariableNames: 'entities'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #BankEntityTest category: #'Portfolio-Ejercicio'!
TestCase subclass: #BankEntityTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #BankEntityTest category: #'Portfolio-Ejercicio'!
TestCase subclass: #BankEntityTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio'!
ProtoObject subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio'!
ProtoObject subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio'!
BankEntityTest subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio'!
BankEntityTest subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccountTest category: #'Portfolio-Ejercicio'!
BankEntityTest subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccountTest category: #'Portfolio-Ejercicio'!
BankEntityTest subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'operations' stamp: 'mr 10/21/2019 15:20:31' prior: 50761715!
add: anEntityToAdd
	
	self assertIfIncludes: anEntityToAdd.
	
	anEntityToAdd addParent: self.
	entities add: anEntityToAdd. 
	

! !
!Portfolio methodsFor: 'asserts - private' stamp: 'mr 10/21/2019 15:20:51' prior: 50761428!
assertIfIncludes: anEntityToAdd.
	
	self roots detect:   [ :aRoot | aRoot hasElementsInCommonWith: anEntityToAdd. ] 
		  	    ifNone:   [ ^ self. ].
	
	self error: self class cannotAddAnExistentAccountError.	
	

! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:21:03' prior: 50761734!
balance
	
	^ (entities sum: [ :anEntity | anEntity balance ] ifEmpty: [ 0 ]).! !
!Portfolio methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:21:14' prior: 50761700!
hasElementsInCommonWith: anEntityToInclude

	^ (anEntityToInclude includes: self) or: [ entities anySatisfy: [ :anElem | anElem hasElementsInCommonWith: anEntityToInclude ] ].
! !
!Portfolio methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:21:28' prior: 50761824!
hasElementsInCommonWith: anEntityToInclude

	^ (anEntityToInclude includes: self) or: [ entities anySatisfy: [ :anEntity | anEntity hasElementsInCommonWith: anEntityToInclude ] ].
! !
!Portfolio methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:21:50' prior: 50761692!
includes: anEntityToInclude

	^ self = anEntityToInclude or: [ entities anySatisfy: [:anElem | anElem includes: anEntityToInclude ] ].

	! !
!Portfolio methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:22:00' prior: 50761842!
includes: anEntityToInclude

	^ self = anEntityToInclude or: [ entities anySatisfy: [:anEntity | anEntity includes: anEntityToInclude ] ].

	! !
!Portfolio methodsFor: 'accessing - private' stamp: 'mr 10/21/2019 15:25:13' prior: 50761418!
roots

	| roots |
	
	roots := OrderedCollection new.
	parents isEmpty ifTrue: [ 
		roots add: self.
		^ roots ].
	
	parents inject: roots
			 into: [ :collectionOfRoots :aParent | collectionOfRoots addAllLast: (aParent roots); yourself. ].
	
	^ roots.
! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:25:40' prior: 50761723!
transactions
	
	^ entities inject: OrderedCollection new into: [ :collectionOfTransactions :anElem | collectionOfTransactions addAllLast: (anElem transactions); yourself ].
! !
!Portfolio methodsFor: 'accessing' stamp: 'mr 10/21/2019 15:28:51' prior: 50761869!
transactions
	
	^ entities inject: OrderedCollection new into: [ :collectionOfTransactions :anEntity | collectionOfTransactions addAllLast: (anEntity transactions); yourself ].
! !
!Deposit methodsFor: 'value' stamp: 'mr 10/21/2019 15:30:26'!
valueForBalance

	^ value.! !

Deposit removeSelector: #xxxvalue!
!Withdraw methodsFor: 'value' stamp: 'mr 10/21/2019 15:30:45'!
valueForBalance

	^ value negated.! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:30:45' prior: 50761499!
balance

	^transactions sum: [ :aTransaction | aTransaction valueForBalance ] ifEmpty: [ 0 ]! !

Withdraw removeSelector: #xxxvalue!
!AccountTransaction methodsFor: 'nil' stamp: 'mr 10/21/2019 15:31:07'!
valueForBalance

	self subclassResponsibility.! !
!ReceptiveAccount methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:36:02'!
hasEntitiesInCommonWith: anElementToInclude

	^ (anElementToInclude includes: self) or: [ self includes: anElementToInclude ].

	! !
!Portfolio methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:36:02'!
hasEntitiesInCommonWith: anEntityToInclude

	^ (anEntityToInclude includes: self) or: [ entities anySatisfy: [ :anEntity | anEntity hasElementsInCommonWith: anEntityToInclude ] ].
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:36:02' prior: 50761833!
hasElementsInCommonWith: anEntityToInclude

	^ (anEntityToInclude includes: self) or: [ entities anySatisfy: [ :anEntity | anEntity hasEntitiesInCommonWith: anEntityToInclude ] ].
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:36:02' prior: 50761808!
assertIfIncludes: anEntityToAdd.
	
	self roots detect:   [ :aRoot | aRoot hasEntitiesInCommonWith: anEntityToAdd. ] 
		  	    ifNone:   [ ^ self. ].
	
	self error: self class cannotAddAnExistentAccountError.	
	

! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:36:02' prior: 50761915!
hasEntitiesInCommonWith: anEntityToInclude

	^ (anEntityToInclude includes: self) or: [ entities anySatisfy: [ :anEntity | anEntity hasEntitiesInCommonWith: anEntityToInclude ] ].
! !

ReceptiveAccount removeSelector: #hasElementsInCommonWith:!

Portfolio removeSelector: #hasElementsInCommonWith:!

Smalltalk removeClassNamed: #Portfolio!

Smalltalk removeClassNamed: #ReceptiveAccount!

Smalltalk removeClassNamed: #BankContainersXX!

Smalltalk removeClassNamed: #Withdraw!

Smalltalk removeClassNamed: #Deposit!

Smalltalk removeClassNamed: #AccountTransaction!

Smalltalk removeClassNamed: #ReceptiveAccountTest!

Smalltalk removeClassNamed: #PortfolioTest!

Smalltalk removeClassNamed: #BankEntityTest!

----End fileIn of /home/mregnier/isw1/linux64/Portfolio-Ejercicio.st----!
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:48:02'!
cannotAddAnExistentEntityError

	 ^ 'You cannot add an already existent account'! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:48:02' prior: 50762509!
assertIfIncludes: anEntityToAdd.
	
	self roots detect:   [ :aRoot | aRoot hasEntitiesInCommonWith: anEntityToAdd. ] 
		  	    ifNone:   [ ^ self. ].
	
	self error: self class cannotAddAnExistentEntityError.	
	

! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:48:02' prior: 50762195!
test14APortfolioCannotIncludeAndHimselfShouldRaiseError

	| portfolio anAccount |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	self should: [ portfolio add: portfolio. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentEntityError.
	
	self assert: portfolio balance equals: 100.	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:48:02' prior: 50762211!
test15APortfolioWithAnAccountCannotAddAnotherPortfolioWithTheSameAccountAndShouldRaiseError

	| portfolio anAccount anotherPortfolio |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anAccount.
	
	self should: [ portfolio add: anotherPortfolio. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentEntityError.
	
	self assert: portfolio balance equals: 100.	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:48:02' prior: 50762168!
test13AddingToAnEmptyPortfolioRegisteredInTwoPortfoliosAnAccountRegisteredInOneOfThemRaisesError

	| portfolio anAccount anotherAccount anotherPortfolio emptyPortfolio |

	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	anotherAccount := ReceptiveAccount  new.
	Deposit register: 150 on: anotherAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount.
	
	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anotherAccount.
	
	emptyPortfolio := Portfolio new.
	
	portfolio add: emptyPortfolio.
	anotherPortfolio add: emptyPortfolio.
	
	self should: [ emptyPortfolio add: anAccount. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentEntityError.
	
	self assert: emptyPortfolio balance equals: 0.	! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:48:02' prior: 50762152!
test12AddingAnAccountToAPortfolioThatAlreadyHasItRaisesError

	| portfolio anAccount |
	anAccount := ReceptiveAccount  new.
	Deposit register: 100 on: anAccount.
	
	portfolio := Portfolio new.
	portfolio add: anAccount .
	
	self should: [ portfolio add: anAccount. ]
	       raise: Error - MessageNotUnderstood
		 withMessageText: Portfolio cannotAddAnExistentEntityError.
	
	self assert: portfolio balance equals: 100.
	! !

Portfolio class removeSelector: #cannotAddAnExistentAccountError!
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 15:48:12' prior: 50762601!
cannotAddAnExistentEntityError

	 ^ 'You cannot add an already existent entity'! !
!ReceptiveAccount methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:54:09' prior: 50762593!
includes: anEntityToInclude

	^ self = anEntityToInclude.

	! !
!ReceptiveAccount methodsFor: 'testing - private' stamp: 'mr 10/21/2019 15:54:30' prior: 50762586!
hasEntitiesInCommonWith: anEntityToInclude

	^ (anEntityToInclude includes: self) or: [ self includes: anEntityToInclude ].

	! !

----SNAPSHOT----(21 October 2019 16:00:50) clase2.image priorSource: 13699686!

----QUIT----(21 October 2019 16:00:54) clase2.image priorSource: 13794241!

----STARTUP---- (21 October 2019 17:55:25) as /home/mregnier/isw1/linux64/clase2.image!


Smalltalk removeClassNamed: #ReceptiveAccount!

Smalltalk removeClassNamed: #Portfolio!

Smalltalk removeClassNamed: #BankEntity!

Smalltalk removeClassNamed: #Withdraw!

Smalltalk removeClassNamed: #Deposit!

Smalltalk removeClassNamed: #AccountTransaction!

Smalltalk removeClassNamed: #ReceptiveAccountTest!

Smalltalk removeClassNamed: #PortfolioTest!

Smalltalk removeClassNamed: #BankEntityTest!

----End fileIn of /home/mregnier/isw1/23-Portfolio/solucion/Portfolio-Solucion.st----!

TestCase subclass: #TransferTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferTest category: #'Portfolio-Solucion'!
TestCase subclass: #TransferTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!TransferTest methodsFor: 'no messages' stamp: 'mr 10/21/2019 19:15:58'!
Test01TransferChangeBalanceOfSender

	| aPortfolio anotherPortfolio |
	aPortfolio := Portfolio new.
	anotherPortfolio := Portfolio new.
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:17:13'!
test01TransferChangeBalanceOfSender

	| aPortfolio anotherPortfolio |
	
	aPortfolio := Portfolio new.
	anotherPortfolio := Portfolio new.
	
	self addAccountWith: 100 to: aPortfolio.
	self addAccountWith: 100 to: aPortfolio.

	! !

TransferTest removeSelector: #Test01TransferChangeBalanceOfSender!
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:17:35'!
test01TransferChangeBalanceOfExtractee

	| aPortfolio anotherPortfolio |
	
	aPortfolio := Portfolio new.
	anotherPortfolio := Portfolio new.
	
	self addAccountWith: 100 to: aPortfolio.
	self addAccountWith: 100 to: aPortfolio.

	! !

TransferTest removeSelector: #test01TransferChangeBalanceOfSender!
!TransferTest methodsFor: 'test - private' stamp: 'mr 10/21/2019 19:18:04'!
addAccountWith: aSmallInteger to: aPortfolio 
	self shouldBeImplemented.! !
!TransferTest methodsFor: 'test - private' stamp: 'mr 10/21/2019 19:19:54' prior: 50763472!
addAccountWith: anAmount to: aPortfolio 
	
	| anAccount |
	anAccount := ReceptiveAccount new.
	Deposit register: anAmount on: aPortfolio .! !
!TransferTest methodsFor: 'test - private' stamp: 'mr 10/21/2019 19:20:53' prior: 50763478!
addAccountWith: anAmount to: aPortfolio 
	
	| anAccount |
	anAccount := ReceptiveAccount new.
	Deposit register: anAmount on: anAccount .
	
	aPortfolio add: anAccount .
	^aPortfolio .! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:21:57' prior: 50763460!
test01TransferChangeBalanceOfExtractee

	| aPortfolio anotherPortfolio anAccount |
	
	anAccount := Portfolio new.
	anotherPortfolio := Portfolio new.
	
	self addAccountWith: 100 to: aPortfolio.
	self addAccountWith: 100 to: aPortfolio.
	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:23:14' prior: 50763495!
test01TransferChangeBalanceOfExtractee

	| aPortfolio anAccount anotherAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	
	
	self addAccountWith: 100 to: aPortfolio.
	self addAccountWith: 100 to: aPortfolio.
	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:23:28' prior: 50763506!
test01TransferChangeBalanceOfExtractee

	| anAccount anotherAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	

	
	

	! !

!classDefinition: #Transfer category: #'Portfolio-Solucion'!
AccountTransaction subclass: #Transfer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:25:04' prior: 50763520!
test01TransferChangeBalanceOfExtractee

	| anAccount anotherAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	Transfer register: 50 from: anAccount to: anotherAccount .
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:27:09' prior: 50763538!
test01TransferChangeBalanceOfExtractee

	| anAccount anotherAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: anAccount balance equals: 50.
	

	
	

	! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:27:57'!
register: aSmallInteger from: aReceptiveAccount to: aReceptiveAccount3 
	self shouldBeImplemented.! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:29:49' prior: 50763565!
register: anAmount from: aSender to: aReceiver
	self shouldBeImplemented.! !

AccountTransaction subclass: #Transfer
	instanceVariableNames: 'value senderAccount receiverAccount '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: #'Portfolio-Solucion'!
AccountTransaction subclass: #Transfer
	instanceVariableNames: 'value senderAccount receiverAccount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:31:58' prior: 50763572!
register: anAmount from: aSender to: aReceiver
	! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:42:17' prior: 50763591!
register: anAmount from: aSender to: aReceiver
	
	| transfer |
	transfer := self new intializeWith: anAmount  from: aSender  to: aReceiver.
	aSender register: transfer.! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:42:37' prior: 50763596!
register: anAmount from: aSender to: aReceiver
	
	| transfer |
	transfer := self new intializeWith: anAmount  from: aSender  to: aReceiver.
	aSender register: transfer.
	^ transfer.! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:42:47' prior: 50763605!
register: anAmount from: aSender to: aReceiver
	
	| transfer |
	
	transfer := self new intializeWith: anAmount  from: aSender  to: aReceiver.
	aSender register: transfer.
	
	^ transfer.! !
!Transfer methodsFor: 'no messages' stamp: 'mr 10/21/2019 19:44:02'!
initializeWith: anAmount from: aSender to: aReceiver

	value := anAmount .
	senderAccount := aSender.
	receiverAccount  := aReceiver.! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'mr 10/21/2019 19:48:04' prior: 50763304!
balance

	^transactions 
		inject: 0
		into: [ :currentBalance :transaction | transaction affectBalance: currentBalance for: self ]! !
!AccountTransaction methodsFor: 'balance' stamp: 'mr 10/21/2019 19:48:30'!
affectBalance: aBalance for: anAccount

	self subclassResponsibility ! !
!Deposit methodsFor: 'balance' stamp: 'mr 10/21/2019 19:48:43'!
affectBalance: aBalance for: anAccount

	^aBalance + value ! !
!Withdraw methodsFor: 'balance' stamp: 'mr 10/21/2019 19:48:53'!
affectBalance: aBalance for: anAccount

	^aBalance - value! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:50:22'!
affectBalance: aBalance for: anAccount

	anAccount = senderAccount ifTrue: [aBalance - value]! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:50:27' prior: 50763652!
affectBalance: aBalance for: anAccount

	anAccount = senderAccount ifTrue: [^aBalance - value]! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:50:30' prior: 50763658!
affectBalance: aBalance for: anAccount

	anAccount = senderAccount ifTrue: [^ aBalance - value]! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:50:35' prior: 50763664!
affectBalance: aBalance for: anAccount

	anAccount = senderAccount ifTrue: [ ^ aBalance - value]! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 19:50:40' prior: 50763670!
affectBalance: aBalance for: anAccount

	anAccount = senderAccount ifTrue: [ ^ aBalance - value ]! !

AccountTransaction removeSelector: #affectBalance:for:!

Deposit removeSelector: #affectBalance:for:!

Withdraw removeSelector: #affectBalance:for:!
!ReceptiveAccount methodsFor: 'balance' stamp: 'mr 10/21/2019 19:59:47' prior: 50763631!
balance

	^transactions 
		inject: 0
		into: [ :currentBalance :transaction | transaction affectBalance: currentBalance ]! !

Transfer subclass: #TransferIn
	instanceVariableNames: 'mainTransfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferIn category: #'Portfolio-Solucion'!
Transfer subclass: #TransferIn
	instanceVariableNames: 'mainTransfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Transfer subclass: #TransferOut
	instanceVariableNames: 'mainTransfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferOut category: #'Portfolio-Solucion'!
Transfer subclass: #TransferOut
	instanceVariableNames: 'mainTransfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

AccountTransaction subclass: #Transfer
	instanceVariableNames: 'value transferIn transferOut'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: #'Portfolio-Solucion'!
AccountTransaction subclass: #Transfer
	instanceVariableNames: 'value transferIn transferOut'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Transfer methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:03:35' prior: 50763623!
initializeWith: anAmount from: aSender to: aReceiver

	value := anAmount .
	transferOut := TransferOut for: self.
	transferIn  := TransferIn for: self.
	! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:07:27' prior: 50763614!
register: anAmount from: aSender to: aReceiver
	
	^ self new intializeWith: anAmount from: aSender  to: aReceiver.
! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:07:37' prior: 50763739!
register: anAmount from: aSender to: aReceiver
	
	^ self new intializeWith: anAmount from: aSender to: aReceiver.
! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:08:04' prior: 50763746!
register: anAmount from: aSender to: aReceiver
	
	^ self new initializeWith: anAmount from: aSender to: aReceiver.
! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:08:56' prior: 50763731!
initializeWith: anAmount from: aSender to: aReceiver

	value := anAmount .
	transferOut := TransferOut for: self.
	transferIn  := TransferIn for: self.
	
	aSender register: transferOut.
	aReceiver register: transferIn.! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:09:59' prior: 50763760!
initializeWith: anAmount from: aSender to: aReceiver

	value := anAmount .
	transferOut := TransferOut for: self.
	transferIn  := TransferIn for: self.
	
	aSender register: transferOut.
	aReceiver register: transferIn.
	! !
!TransferIn class methodsFor: 'no messages' stamp: 'mr 10/21/2019 20:10:45'!
for: aMainTransfer

	! !
!TransferIn class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:11:09' prior: 50763780!
for: aMainTransfer

	^ self new initializeFor: aMainTransfer .! !
!TransferOut class methodsFor: 'no messages' stamp: 'mr 10/21/2019 20:12:02'!
for: aMainTransfer

	^ self new initializeFor: aMainTransfer .! !
!TransferOut methodsFor: 'no messages' stamp: 'mr 10/21/2019 20:14:00'!
initializeFor: aMainTransfer

	mainTransfer  := aMainTransfer .! !
!TransferIn methodsFor: 'no messages' stamp: 'mr 10/21/2019 20:14:08'!
initializeFor: aMainTransfer

	mainTransfer  := aMainTransfer .! !
!TransferIn methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:15:30'!
affectBalance: aBalance

	^ aBalance + mainTransfer value.! !
!TransferOut methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:15:45'!
affectBalance: aBalance

	^ aBalance - mainTransfer value.! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:16:42'!
value

	^ value.! !

Transfer removeSelector: #affectBalance:for:!
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:18:04'!
test02TransferChangeBalanceOfReceiver

	| anAccount anotherAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: anotherAccount balance equals: 150.
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:18:12'!
test01TransferChangeBalanceOfSender

	| anAccount anotherAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: anAccount balance equals: 50.
	

	
	

	! !

TransferTest removeSelector: #test01TransferChangeBalanceOfExtractee!
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:25:14'!
test03TransferCannotTransferZero

	| anAccount anotherAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	Transfer register: 0 from: anAccount to: anotherAccount .
	
	self assert: anotherAccount balance equals: 150.
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:27:28' prior: 50763849!
test03TransferCannotTransferZero

	| anAccount anotherAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	self 
		should: [ Transfer register: 0 from: anAccount to: anotherAccount . ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anAccount  balance equals: 100.
			self assert: anotherAccount balance equals: 100.
			]

	
! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:28:30' prior: 50763864!
test03TransferCannotTransferZero

	| anAccount anotherAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	self 
		should: [ Transfer register: 0 from: anAccount to: anotherAccount . ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Transfer cannotTransferZeroErrorMessage equals: anError messageText.
			self assert: anAccount  balance equals: 100.
			self assert: anotherAccount balance equals: 100.
			]

	
! !
!TransferTest methodsFor: 'failing' stamp: 'mr 10/21/2019 20:28:41'!
signalFailure: aString 
	self shouldBeImplemented.! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:30:36'!
cannotTransferZeroErrorMessage

	^ 'You cannot transfer 0 '! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:30:45' prior: 50763909!
cannotTransferZeroErrorMessage

	^ 'You cannot transfer zero '! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:32:30'!
cannotTransferNegativeAmountErrorMessage

	^ 'Stop trying to steal, the bank will file a report '! !

TransferTest removeSelector: #signalFailure:!
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:36:29' prior: 50763753!
register: anAmount from: aSender to: aReceiver
	
	anAmount = 0 ifTrue: [self error: self cannotTransferZeroErrorMessage ].
	
	^ self new initializeWith: anAmount from: aSender to: aReceiver.
! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:36:33' prior: 50763928!
register: anAmount from: aSender to: aReceiver
	
	anAmount = 0 ifTrue: [ self error: self cannotTransferZeroErrorMessage ].
	
	^ self new initializeWith: anAmount from: aSender to: aReceiver.
! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:36:36' prior: 50763938!
register: anAmount from: aSender to: aReceiver
	
	anAmount = 0 ifTrue: [ self error: self cannotTransferZeroErrorMessage ].
	
	
	^ self new initializeWith: anAmount from: aSender to: aReceiver.
! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:37:31' prior: 50763948!
register: anAmount from: aSender to: aReceiver
	
	anAmount = 0 ifTrue: [ self error: self cannotTransferZeroErrorMessage ].
	anAmount < 0 ifTrue: [ self error: self cannotTransferNegativeAmountErrorMessage ].
	
	^ self new initializeWith: anAmount from: aSender to: aReceiver.
! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:38:44'!
test04TransferCannotStealFromTheReceiver

	| anAccount anotherAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	self 
		should: [ Transfer register: -50 from: anAccount to: anotherAccount . ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Transfer cannotTransferNegativeAmountErrorMessage equals: anError messageText.
			self assert: anAccount  balance equals: 100.
			self assert: anotherAccount balance equals: 100.
			]

	
! !

AccountTransaction subclass: #TransferIn
	instanceVariableNames: 'mainTransfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferIn category: #'Portfolio-Solucion'!
AccountTransaction subclass: #TransferIn
	instanceVariableNames: 'mainTransfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

AccountTransaction subclass: #TransferOut
	instanceVariableNames: 'mainTransfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferOut category: #'Portfolio-Solucion'!
AccountTransaction subclass: #TransferOut
	instanceVariableNames: 'mainTransfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Object subclass: #Transfer
	instanceVariableNames: 'value transferIn transferOut'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: #'Portfolio-Solucion'!
Object subclass: #Transfer
	instanceVariableNames: 'value transferIn transferOut'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!TransferIn methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:49:31'!
value

	^ mainTransfer  value.! !
!TransferOut methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:49:38'!
value

	^ mainTransfer  value.! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:52:00'!
test04TransferCannotBeToYourself

	| anAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	self 
		should: [ Transfer register: -50 from: anAccount to: anAccount . ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Transfer cannotTransferToYourselfErrorMessage equals: anError messageText.
			self assert: anAccount  balance equals: 100.
			]

	
! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:52:21'!
cannotTransferToYourselfErrorMessage
	self shouldBeImplemented.! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:53:06' prior: 50764052!
cannotTransferToYourselfErrorMessage
	
	^ 'You cannot transfer to the same account '! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 20:53:27'!
test05TransferCannotBeToYourself

	| anAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	self 
		should: [ Transfer register: -50 from: anAccount to: anAccount . ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Transfer cannotTransferToYourselfErrorMessage equals: anError messageText.
			self assert: anAccount  balance equals: 100.
			]

	
! !

TransferTest removeSelector: #test04TransferCannotBeToYourself!
!Transfer methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:10:03'!
transferIn

	^ transferIn ! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:10:12'!
transferOut

	^ transferOut ! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:12:43'!
test06TransferIsRegisteredInSender

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: anAccount transactions includes
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:20:07' prior: 50764090!
test06TransferIsRegisteredInSender

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: anAccount transactions includes: aTransfer transferIn
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:20:24' prior: 50764105!
test06TransferIsRegisteredInSender

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: anAccount transactions includes: aTransfer transferOut
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:21:22' prior: 50764064!
test05TransferCannotBeToYourself

	| anAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	self 
		should: [ Transfer register: 50 from: anAccount to: anAccount . ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Transfer cannotTransferToYourselfErrorMessage equals: anError messageText.
			self assert: anAccount  balance equals: 100.
			]

	
! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:22:27' prior: 50763958!
register: anAmount from: aSender to: aReceiver
	
	anAmount = 0 ifTrue: [ self error: self cannotTransferZeroErrorMessage ].
	anAmount < 0 ifTrue: [ self error: self cannotTransferNegativeAmountErrorMessage ].
	aSender = aReceiver ifTrue: [ self error: self cannotTransferToYourselfErrorMessage ].
	
	^ self new initializeWith: anAmount from: aSender to: aReceiver.
! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:23:56'!
test07TransferIsRegisteredInReceiver

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: anAccount transactions includes: aTransfer transferOut
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:24:03' prior: 50764169!
test07TransferIsRegisteredInReceiver

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: anAccount transactions includes: aTransfer transferIn
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:24:14' prior: 50764185!
test07TransferIsRegisteredInReceiver

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: anotherAccount transactions includes: aTransfer transferIn
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:25:25'!
test08SenderAccountHasRegisteredTransferOut

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: anotherAccount transactions includes: aTransfer transferIn
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:26:00' prior: 50764217!
test08SenderAccountHasRegisteredTransferOut

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: ( anAccount hasRegistered: aTransfer transferIn ).
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:26:05' prior: 50764233!
test08SenderAccountHasRegisteredTransferOut

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: ( anAccount hasRegistered: aTransfer transferOut ).
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'mr 10/21/2019 21:26:39'!
test09ReceiverAccountHasRegisteredTransferIn

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: ( anotherAccount hasRegistered: aTransfer transferIn ).
	

	
	

	! !

----SNAPSHOT----(21 October 2019 21:27:16) clase2.image priorSource: 13794321!

----QUIT----(21 October 2019 21:27:28) clase2.image priorSource: 13844153!

----STARTUP---- (24 October 2019 14:58:45) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!

!TransferTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:08:08'!
test10SenderAccountHasKnowledgeOfReceiverAccount
	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: ( anotherAccount hasRegistered: aTransfer transferIn ).
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:08:11' prior: 50764289!
test10SenderAccountHasKnowledgeOfReceiverAccount

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: ( anotherAccount hasRegistered: aTransfer transferIn ).
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:08:49'!
test10TransferOutHasKnowledgeOfTransferIn

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: ( anotherAccount hasRegistered: aTransfer transferIn ).
	

	
	

	! !

TransferTest removeSelector: #test10SenderAccountHasKnowledgeOfReceiverAccount!
!TransferTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:10:11' prior: 50764321!
test10TransferOutHasKnowledgeOfTransferIn

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: ( aTransfer transferIn transferOut equals: aTransfer transferOut).
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:10:16' prior: 50764340!
test10TransferOutHasKnowledgeOfTransferIn

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: ( aTransfer transferIn transferOut equals: aTransfer transferOut ).
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:10:36' prior: 50764357!
test10TransferOutHasKnowledgeOfTransferIn

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert: ( aTransfer transferIn transferOut equals: aTransfer transferOut ).
	

	
	

	! !
!Withdraw methodsFor: 'balance' stamp: 'Dr 10/24/2019 15:10:53' prior: 50763411!
affectBalance: aBalance

	^ aBalance - value! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:11:14' prior: 50764374!
test10TransferOutHasKnowledgeOfTransferIn

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert:  aTransfer transferIn transferOut equals: aTransfer transferOut .
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:11:34'!
test10TransferInHasKnowledgeOfTransferOut

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert:  aTransfer transferIn transferOut equals: aTransfer transferOut .
	

	
	

	! !
!TransferTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:11:42'!
test11TransferInHasKnowledgeOfTransferOut

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert:  aTransfer transferIn transferOut equals: aTransfer transferOut .
	

	
	

	! !

TransferTest removeSelector: #test10TransferInHasKnowledgeOfTransferOut!
!TransferTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:12:08' prior: 50764427!
test11TransferInHasKnowledgeOfTransferOut

	| anAccount anotherAccount aTransfer |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anotherAccount := ReceptiveAccount new.
	Deposit register: 100 on: anotherAccount .
	
	aTransfer := Transfer register: 50 from: anAccount to: anotherAccount .
	
	self assert:  aTransfer transferOut transferIn equals: aTransfer transferIn .
	

	
	

	! !
!TransferIn methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:13:11'!
transferOut
	self shouldBeImplemented.! !
!TransferIn methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:13:32' prior: 50764462!
transferOut
	
	^ mainTransfer transferOut .! !
!TransferOut methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:14:03'!
transferIn
	self shouldBeImplemented.! !
!TransferOut methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:14:12' prior: 50764471!
transferIn
	
	^ mainTransfer transferIn .! !

TestCase subclass: #ReportTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #ReportTest category: #'Portfolio-Solucion'!
TestCase subclass: #ReportTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!ReportTest methodsFor: 'nil' stamp: 'Dr 10/24/2019 15:17:13'!
test01EmptyAccountHasEmptyReport

! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 15:19:55' prior: 50764490!
test01EmptyAccountHasEmptyReport

	| anAccount |
	anAccount := ReceptiveAccount new.
	
	self assert: anAccount netReport isEmpty .! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 15:20:34'!
netReport

	^ ''.! !

----SNAPSHOT----(24 October 2019 15:21:35) clase2.image priorSource: 13844233!

----QUIT----(24 October 2019 15:21:38) clase2.image priorSource: 13851348!

----STARTUP---- (24 October 2019 16:42:42) as /home/drenteria/Documentos/isI/isw1/linux64/clase2.image!

!ReportTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 16:45:10' prior: 50764495!
test01EmptyAccountHasEmptyReport

	| anAccount |
	anAccount := ReceptiveAccount new.
	
	self assert: anAccount netReport equals: 'Balance = 0' .! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 16:46:26' prior: 50764502!
netReport

	^ 'Balance = 0'.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 16:47:47'!
test02AccountWithDepositHasValidReport

	| anAccount |
	anAccount := ReceptiveAccount new.
	
	self assert: anAccount netReport equals: 'Balance = 0' .! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 16:47:51' prior: 50764526!
test02AccountWithDepositHasValidReport

	| anAccount |
	
	anAccount := ReceptiveAccount new.
	
	self assert: anAccount netReport equals: 'Balance = 0' .! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 16:49:12' prior: 50764534!
test02AccountWithDepositHasValidReport

	| anAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	self assert: anAccount netReport equals: 
	'Depsito por 100.
	Balance = 100' .! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 16:55:17' prior: 50764522!
netReport
	
	^ (transactions inject: String new into: [ :report : aTransaction | report, '
		', aTransaction ]), 'Balance = ', self balance.! !

	String enter!

Character enter!

Character enter!

Character enter join: #(a b c)!

Character enter asString join: #(a b c)!

10 asCharacter!

10 asCharacter!
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 17:03:11' prior: 50764552!
netReport
	
	^ (transactions inject: String new into: [ :report : aTransaction | report, 10 asCharacter , aTransaction ]), 'Balance = ', self balance.! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 17:04:37'!
accountSummaryReport
	
	^ (transactions inject: String new into: [ :report : aTransaction | report, 10 asCharacter , aTransaction ]), 'Balance = ', self balance.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 17:04:37' prior: 50764542!
test02AccountWithDepositHasValidReport

	| anAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	self assert: anAccount accountSummaryReport equals: 
	'Depsito por 100.
	Balance = 100' .! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 17:04:37' prior: 50764514!
test01EmptyAccountHasEmptyReport

	| anAccount |
	anAccount := ReceptiveAccount new.
	
	self assert: anAccount accountSummaryReport equals: 'Balance = 0' .! !

ReceptiveAccount removeSelector: #netReport!
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 17:04:54' prior: 50764573!
accountSummaryReport
	
	^ (transactions inject: String new into: [ :report : aTransaction | report, 10 asCharacter asString , aTransaction ]), 'Balance = ', self balance.! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 17:05:46' prior: 50764603!
accountSummaryReport
	
	^ (transactions inject: String new into: [ :report : aTransaction | report, 10 asCharacter , aTransaction ]), 'Balance = ', self balance asString.! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 17:05:53' prior: 50764612!
accountSummaryReport
	
	^ (transactions inject: String new into: [ :report : aTransaction | report, 10 asCharacter asString , aTransaction ]), 'Balance = ', self balance asString.! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 17:07:04' prior: 50764621!
accountSummaryReport
	
	^ (transactions inject: String new into: [ :report : aTransaction | report, 10 asCharacter asString , aTransaction reportMessage ]), 'Balance = ', self balance asString.! !
!Deposit methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 17:07:24'!
reportMessage
	self shouldBeImplemented.! !
!Deposit methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 17:07:50' prior: 50764639!
reportMessage
	^ 'Depsito por ', value asString .! !
!Deposit methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 17:08:26' prior: 50764644!
reportMessage
	^ 'Depsito por ', value asString, '.' .! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 17:09:54' prior: 50764582!
test02AccountWithDepositHasValidReport

	| anAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	self assert: anAccount accountSummaryReport equals: 
	'Depsito por 100.',10 asCharacter asString , 'Balance = 100' .! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'Dr 10/24/2019 17:27:29' prior: 50764654!
test02AccountWithDepositHasValidReport

	| anAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	self assert: anAccount accountSummaryReport equals: 
	'Depsito por 100.',String newLineString , 'Balance = 100' .! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 17:28:47' prior: 50764630!
accountSummaryReport
	
	^ (transactions inject: String new into: [ :report : aTransaction | report, String newLineString , aTransaction reportMessage ]), 'Balance = ', self balance asString.! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 17:30:36' prior: 50764676!
accountSummaryReport
	
	^ (transactions inject: String new into: [ :report : aTransaction | report, aTransaction reportMessage , String newLineString ]), 'Balance = ', self balance asString.! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 17:30:43' prior: 50764685!
accountSummaryReport
	
	^ (transactions inject: String new into: [ :report : aTransaction | report, aTransaction reportMessage, String newLineString ]), 'Balance = ', self balance asString.! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 17:37:13' prior: 50764694!
accountSummaryReport
	"^ Summary for: self value"
	^ (transactions inject: String new into: [ :report : aTransaction | report, aTransaction reportMessage, String newLineString ]), 'Balance = ', self balance asString.! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'Dr 10/24/2019 19:26:34' prior: 50764703!
accountSummaryReport
	"^ SummaryLines for: self value"
	^ (transactions inject: String new into: [ :report : aTransaction | report, aTransaction reportMessage, String newLineString ]), 'Balance = ', self balance asString.! !

----QUIT----(24 October 2019 21:05:30) clase2.image priorSource: 13851428!

----STARTUP---- (26 October 2019 16:37:50) as /home/melissa/Mel/college shit/Ingeniera de Software I/isw1/linux64/clase2.image!

!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 16:43:20'!
test03AccountWithWithdrawHasValidReport

	| anAccount |
	
	anAccount := ReceptiveAccount new.
	Withdraw register: 50 on: anAccount .

	self assert: anAccount accountSummaryReport equals: 
	'Extraccin por 50.',String newLineString , 'Balance = -50' .! !
!Withdraw methodsFor: 'balance' stamp: 'mr 10/26/2019 16:44:05'!
reportMessage

	^ 'Extraccin por ', value.! !
!Withdraw methodsFor: 'balance' stamp: 'mr 10/26/2019 16:44:41' prior: 50764739!
reportMessage

	^ 'Extraccin por ', value asString.! !
!Withdraw methodsFor: 'balance' stamp: 'mr 10/26/2019 16:45:12' prior: 50764743!
reportMessage

	^ 'Extraccin por ', value asString, '.'.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 16:45:48'!
test01EmptyAccountHasEmptyAccountSummary

	| anAccount |
	anAccount := ReceptiveAccount new.
	
	self assert: anAccount accountSummaryReport equals: 'Balance = 0' .! !

ReportTest removeSelector: #test01EmptyAccountHasEmptyReport!
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 16:46:11'!
test02AccountWithDepositHasValidAccountSummary

	| anAccount |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	self assert: anAccount accountSummaryReport equals: 
	'Depsito por 100.',String newLineString , 'Balance = 100' .! !

ReportTest removeSelector: #test02AccountWithDepositHasValidReport!
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 16:46:24'!
test03AccountWithWithdrawHasValidAccountSummary

	| anAccount |
	
	anAccount := ReceptiveAccount new.
	Withdraw register: 50 on: anAccount .

	self assert: anAccount accountSummaryReport equals: 
	'Extraccin por 50.',String newLineString , 'Balance = -50' .! !

ReportTest removeSelector: #test03AccountWithWithdrawHasValidReport!
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 16:47:52'!
test04AccountWithTransferInHasValidAccountSummary

	| anAccount aTransferingAccount |
	
	aTransferingAccount := ReceptiveAccount new.
	Transfer.
	
	anAccount := ReceptiveAccount new.
	Withdraw register: 50 on: anAccount .

	self assert: anAccount accountSummaryReport equals: 
	'Extraccin por 50.',String newLineString , 'Balance = -50' .! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 16:49:25' prior: 50764789!
test04AccountWithTransferInHasValidAccountSummary

	| anAccount aTransferingAccount |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Transfer register: 100 from: aTransferingAccount to: anAccount.

	self assert: anAccount accountSummaryReport equals: 
	'Entrada por transferencia de 100.', String newLineString , 'Balance = 100' .! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 16:50:12'!
test05AccountWithTransferOutHasValidAccountSummary

	| anAccount aTransferingAccount |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Transfer register: 100 from: aTransferingAccount to: anAccount.

	self assert: aTransferingAccount accountSummaryReport equals: 
	'Salida por transferencia de 100.', String newLineString , 'Balance = -100' .! !
!TransferIn methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 16:51:22'!
reportMessage

	^ 'Entrada por transferencia de ', mainTransfer value asString, '.'.! !
!TransferOut methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 16:52:07'!
reportMessage

	^ 'Salida por transferencia de ', mainTransfer value asString, '.'.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 16:56:46'!
test06AccountWithAllPossibleTransactionsHasValidAccountSummary

	| anAccount aTransferingAccount |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	self assert: anAccount accountSummaryReport equals: 
	'Depsito por 50.', String newLineString ,
	'Extraccin por 25.', String newLineString ,
	'Entrada por transferencia de 100.', String newLineString ,
	'Salida por transferencia de 10.', String newLineString ,
	 'Balance = 115'.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:02:47'!
test07EmptyPortfolioHasEmptyAccountSummary


	| aPortfolio |
	self assert: aPortfolio accountSummaryReport equals: 'Balance = 115'.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:03:51' prior: 50764869!
test07EmptyPortfolioHasEmptyAccountSummary

	| aPortfolio |

	aPortfolio := Portfolio new.

	self assert: aPortfolio accountSummaryReport equals: 'Balance = 115'.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:04:09' prior: 50764877!
test07EmptyPortfolioHasEmptyAccountSummary

	| aPortfolio |

	aPortfolio := Portfolio new.

	self assert: aPortfolio accountSummaryReport equals: 'Balance = 0'.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:05:04'!
accountSummaryReport
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:05:26' prior: 50764894!
accountSummaryReport
	
	^ 'Balance = 0.'! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:05:44' prior: 50764886!
test07EmptyPortfolioHasEmptyAccountSummary

	| aPortfolio |

	aPortfolio := Portfolio new.

	self assert: aPortfolio accountSummaryReport equals: 'Balance = 0.'.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:06:15' prior: 50764904!
test07EmptyPortfolioHasEmptyAccountSummary

	| aPortfolio |

	aPortfolio := Portfolio new.

	self assert: aPortfolio accountSummaryReport equals: 'Balance = 0'.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:06:55' prior: 50764899!
accountSummaryReport
	
	^ 'Balance = 0'.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:12:42'!
test08PortfolioWithOneAccountHasTheAccountSummary

	| anAccount aPortfolio |

	anAccount := ReceptiveAccount new.
	
	
	aPortfolio := Portfolio new.

	self assert: aPortfolio accountSummaryReport equals: 'Balance = 0'.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:15:19' prior: 50764926!
test08PortfolioWithOneAccountHasTheAccountSummary

	| anAccount aTransferingAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.

	self assert: aPortfolio accountSummaryReport equals: 
	'Depsito por 50.', String newLineString ,
	'Extraccin por 25.', String newLineString ,
	'Entrada por transferencia de 100.', String newLineString ,
	'Salida por transferencia de 10.', String newLineString ,
	 'Balance = 115'.
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:16:35' prior: 50764922!
accountSummaryReport
	"^ SummaryLines for: self value"
	^ (self transactions inject: String new into: [ :report : aTransaction | report, aTransaction reportMessage, String newLineString ]), 'Balance = ', self balance asString.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:27:25'!
test09PortfolioWithManyAccountsHasTheAccountsSummary

	| anAccount aTransferingAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.
	aPortfolio add: aTransferingAccount.

	self assert: aPortfolio accountSummaryReport equals: 
	'Depsito por 50.', String newLineString ,
	'Extraccin por 25.', String newLineString ,
	'Entrada por transferencia de 100.', String newLineString ,
	'Salida por transferencia de 10.', String newLineString ,
	'Salida por transferencia de 100.', String newLineString ,
	'Entrada por transferencia de 10.', String newLineString ,
	 'Balance = 115'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:27:51' prior: 50764972!
test09PortfolioWithManyAccountsHasTheAccountsSummary

	| anAccount aTransferingAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.
	aPortfolio add: aTransferingAccount.

	self assert: aPortfolio accountSummaryReport equals: 
	'Depsito por 50.', String newLineString ,
	'Extraccin por 25.', String newLineString ,
	'Entrada por transferencia de 100.', String newLineString ,
	'Salida por transferencia de 10.', String newLineString ,
	'Salida por transferencia de 100.', String newLineString ,
	'Entrada por transferencia de 10.', String newLineString ,
	'Balance = 25'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:29:53'!
test10PortfolioWithPortfolioWithAccountsHasTheAccountsSummary

	| anAccount aTransferingAccount aPortfolio anotherPortfolio|
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anAccount.

	aPortfolio := Portfolio new.
	aPortfolio add: anotherPortfolio.

	self assert: aPortfolio accountSummaryReport equals: 
	'Depsito por 50.', String newLineString ,
	'Extraccin por 25.', String newLineString ,
	'Entrada por transferencia de 100.', String newLineString ,
	'Salida por transferencia de 10.', String newLineString ,
	'Balance = 115'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:34:24'!
test11EmptyAccountHasEmptyNetTransferReport

	| anAccount|
	
	anAccount := ReceptiveAccount new.

	self assert: anAccount netTransferReport equals: 'Neto de transferencia = 0'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:34:36' prior: 50765063!
test11EmptyAccountHasEmptyNetTransferReport

	| anAccount |
	
	anAccount := ReceptiveAccount new.

	self assert: anAccount netTransferReport equals: 'Neto de transferencia = 0'.
! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:34:49'!
netTransferReport
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:39:04' prior: 50765081!
netTransferReport
	
	^ 'Neto de transferencia = 0'.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:40:44'!
test12AccountWithTransferInHasValidNetTransferReport

	| anAccount aTransferingAccount |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.
	
	Transfer register: 100 from: aTransferingAccount to: anAccount.

	self assert: anAccount netTransferReport equals: 'Neto de transferencia = 100'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:42:06' prior: 50765091!
test12AccountWithTransferInHasValidNetTransferReport

	| anAccount aTransferingAccount |

	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.
	
	Transfer register: 100 from: aTransferingAccount to: anAccount.

	self assert: anAccount netTransferReport equals: 'Neto de transferencia = 100'.
! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:43:53' prior: 50765086!
netTransferReport

	^ 'Neto de transferencia = 0'.! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:49:01' prior: 50765119!
netTransferReport

      | netTransfer |

	netTransfer := self transactions inject: 0 into: [ :amount :aTransaction | amount + aTransaction valueForNetTranfer ].

	^ 'Neto de transferencia = ', netTransfer asString.! !
!AccountTransaction methodsFor: 'value' stamp: 'mr 10/26/2019 17:49:27'!
valueForNetTransfer

	^ 0.! !
!TransferIn methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:50:10'!
valueForNetTransfer

	^ mainTransfer value.! !
!TransferOut methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:50:29'!
valueForNetTransfer

	^ mainTransfer value negated.! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:51:52' prior: 50765124!
netTransferReport

      | netTransfer |

	netTransfer := self transactions inject: 0 into: [ :amount :aTransaction | amount + aTransaction valueForNetTransfer ].

	^ 'Neto de transferencia = ', netTransfer asString.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 17:57:49'!
test13AccountWithTransferOutHasValidNetTransferReport

	| anAccount aTransferingAccount |

	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.
	
	Transfer register: 100 from: aTransferingAccount to: anAccount.

	self assert: aTransferingAccount netTransferReport equals: 'Neto de transferencia = -100'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:01:24'!
test14AccountWithDepositHasValidNetTransferReport

	| anAccount |

	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount.

	self assert: anAccount netTransferReport equals: 'Neto de transferencia = 0'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:02:17'!
test15AccountWithWithdrawHasValidNetTransferReport

	| anAccount |

	anAccount := ReceptiveAccount new.
	Withdraw register: 100 on: anAccount.

	self assert: anAccount netTransferReport equals: 'Neto de transferencia = 0'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:03:42'!
test15AccountWithAllTransactionsHasValidNetTransferReport

	| anAccount |

	anAccount := ReceptiveAccount new.
	Withdraw register: 100 on: anAccount.

	self assert: anAccount netTransferReport equals: 'Neto de transferencia = 0'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:03:49'!
test16AccountWithAllTransactionsHasValidNetTransferReport

	| anAccount |

	anAccount := ReceptiveAccount new.
	Withdraw register: 100 on: anAccount.

	self assert: anAccount netTransferReport equals: 'Neto de transferencia = 0'.
! !

ReportTest removeSelector: #test15AccountWithAllTransactionsHasValidNetTransferReport!
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:05:25' prior: 50765200!
test16AccountWithAllTransactionsHasValidNetTransferReport

	| anAccount aTransferingAccount |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	self assert: anAccount netTransferReport equals: 'Neto de transferencia = 90'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:08:54'!
test17EmptyPortfolioHasValidNetTransferReport


	| aPortfolio |
	aPortfolio := Portfolio new.

	self assert: aPortfolio netTransferReport equals: 'Neto de transferencia = 90'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:12:36' prior: 50765232!
test17EmptyPortfolioHasValidNetTransferReport

	| aPortfolio |

	aPortfolio := Portfolio new.

	self assert: aPortfolio netTransferReport equals: 'Neto de transferencia = 0'.
! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:12:46'!
netTransferReport
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:14:42' prior: 50765250!
netTransferReport
	
	^ self transactions inject: 0 into: [ :amount :aTransaction | amount + aTransaction valueForNetTransfer ]! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:16:07' prior: 50765255!
netTransferReport
	
	^ 'Neto de transferencia = ', (self transactions inject: 0 into: [ :amount :aTransaction | amount + aTransaction valueForNetTransfer ]) asString! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:16:09' prior: 50765262!
netTransferReport
	
	^ 'Neto de transferencia = ', (self transactions inject: 0 into: [ :amount :aTransaction | amount + aTransaction valueForNetTransfer ]) asString.! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:17:18'!
test17PortfolioWithOneAccountHasValidNetTransferReport

	| aPortfolio |

	aPortfolio := Portfolio new.

	self assert: aPortfolio netTransferReport equals: 'Neto de transferencia = 0'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:17:27'!
test18PortfolioWithOneAccountHasValidNetTransferReport

	| aPortfolio |

	aPortfolio := Portfolio new.

	self assert: aPortfolio netTransferReport equals: 'Neto de transferencia = 0'.
! !

ReportTest removeSelector: #test17PortfolioWithOneAccountHasValidNetTransferReport!
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:20:39' prior: 50764753!
test01EmptyAccountHasEmptyAccountSummary

	| anAccount |

	anAccount := ReceptiveAccount new.
	
	self assert: anAccount accountSummaryReport equals: 'Balance = 0' .! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:24:01' prior: 50765288!
test18PortfolioWithOneAccountHasValidNetTransferReport

	| anAccount aPortfolio |

	anAccount := ReceptiveAccount new.
	

	aPortfolio := Portfolio new.

	self assert: aPortfolio netTransferReport equals: 'Neto de transferencia = 0'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:25:48' prior: 50765309!
test18PortfolioWithOneAccountHasValidNetTransferReport

	| anAccount aTransferingAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	aPortfolio := Portfolio new.
	aPortfolio  add: anAccount.

	self assert: aPortfolio netTransferReport equals: 'Neto de transferencia = 90'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:26:46'!
test19PortfolioWithManyAccountHasValidNetTransferReport

	| anAccount aTransferingAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.
	aPortfolio add: aTransferingAccount.

	self assert: aPortfolio netTransferReport equals: 'Neto de transferencia = 90'.
! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 18:26:54' prior: 50765340!
test19PortfolioWithManyAccountHasValidNetTransferReport

	| anAccount aTransferingAccount aPortfolio |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.
	aPortfolio add: aTransferingAccount.

	self assert: aPortfolio netTransferReport equals: 'Neto de transferencia = 0'.
! !

Object subclass: #AccountReport
	instanceVariableNames: 'account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountReport category: #'Portfolio-Solucion'!
Object subclass: #AccountReport
	instanceVariableNames: 'account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

AccountReport subclass: #AccountSummaryReport
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountSummaryReport category: #'Portfolio-Solucion'!
AccountReport subclass: #AccountSummaryReport
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

AccountReport subclass: #NetTransferReport
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #NetTransferReport category: #'Portfolio-Solucion'!
AccountReport subclass: #NetTransferReport
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!AccountReport methodsFor: 'no messages' stamp: 'mr 10/26/2019 19:03:27'!
value

	self subclassResponsibility.! !
!AccountReport class methodsFor: 'no messages' stamp: 'mr 10/26/2019 19:04:19'!
for: anAccount

	^ self new initializeFor: anAccount.! !
!AccountReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:04:38'!
initializeFor: anAccount
	
	account := anAccount.! !
!AccountSummaryReport methodsFor: 'no messages' stamp: 'mr 10/26/2019 19:05:01'!
value

	! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:06:40' prior: 50765430!
value

	^ (account transactions inject: String new into: [ :report : aTransaction | report, aTransaction reportMessage, String newLineString ]), 'Balance = ', self balance asString.! !

String new nextPutAll: 'hola'!

String nextPutAll: 'hola'!

aString := String new.
!

aString := String new
aString nextPutAll: 'hola'.!

aString := String new.
aString nextPutAll: 'hola'.!

String superclass.!

'xxx \ yyy' withNewLines.!
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:13:36' prior: 50765434!
value

	^ (account transactions inject: String new into: [ :report : aTransaction | report, aTransaction reportInfoFor: self, String newLineString ]), 'Balance = ', self balance asString.! !
!AccountTransaction methodsFor: 'nil' stamp: 'mr 10/26/2019 19:15:42'!
reportInfoFor: aTransaction
	self subclassResponsibility.! !
!Deposit methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:16:52'!
reportInfoFor: aReport
	
	^ aReport forDeposit: self.! !
!AccountTransaction methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:17:08' prior: 50765460!
reportInfoFor: aReport
	self subclassResponsibility.! !
!TransferIn methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:17:36'!
reportInfoFor: aReport

	! !
!TransferIn methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:18:03' prior: 50765475!
reportInfoFor: aReport
	
	^ aReport forTransferIn: self.! !
!TransferOut methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:18:23'!
reportInfoFor: aReport
	
	^ aReport forTransferOut: self.! !
!Withdraw methodsFor: 'nil' stamp: 'mr 10/26/2019 19:18:48'!
reportInfoFor: aReport
	
	^ aReport forWithdraw: self.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:22:53'!
forDeposit: aDeposit

	^ 'Depsito por ', aDeposit value asString, '.'.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:23:20'!
forTransferIn: aDeposit

	^ 'Entrada por transferencia de ', aDeposit value asString, '.'.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:23:32'!
forTransferOut: aDeposit

	^ 'Salida por transferencia de ', aDeposit value asString, '.'.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:24:02'!
forWithdraw: aDeposit

	^ 'Extraccin por ', aDeposit value asString, '.'.! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:25:05' prior: 50765300!
test01EmptyAccountHasEmptyAccountSummary

	| anAccount anAccountSummaryReport |

	anAccount := ReceptiveAccount new.
	
	anAccountSummaryReport := AccountSummaryReport for: anAccount.
	self assert: anAccount accountSummaryReport equals: 'Balance = 0' .! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:25:31' prior: 50765517!
test01EmptyAccountHasEmptyAccountSummary

	| anAccount anAccountSummaryReport |

	anAccount := ReceptiveAccount new.
	
	anAccountSummaryReport := AccountSummaryReport for: anAccount.
	
	self assert: anAccountSummaryReport value equals: 'Balance = 0' .! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:26:00' prior: 50765451!
value

	^ (account transactions inject: String new into: [ :report : aTransaction | report, aTransaction reportInfoFor: self, String newLineString ]), 'Balance = ', account balance asString.! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:27:36' prior: 50764763!
test02AccountWithDepositHasValidAccountSummary

	| anAccount anAccountSummaryReport |
	
	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount .
	
	anAccountSummaryReport := AccountSummaryReport for: anAccount.

	self assert: anAccountSummaryReport value equals: 
	'Depsito por 100.',String newLineString , 'Balance = 100' .! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:29:58' prior: 50765541!
value

	^ (account transactions inject: String new into: [ :report : aTransaction | report, (aTransaction reportInfoFor: self), String newLineString ]), 'Balance = ', account balance asString.! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:30:26' prior: 50764776!
test03AccountWithWithdrawHasValidAccountSummary

	| anAccount anAccountSummaryReport |
	
	anAccount := ReceptiveAccount new.
	Withdraw register: 50 on: anAccount .

	anAccountSummaryReport := AccountSummaryReport for: anAccount.

	self assert: anAccountSummaryReport value equals: 
	'Extraccin por 50.',String newLineString , 'Balance = -50' .! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:30:44' prior: 50764803!
test04AccountWithTransferInHasValidAccountSummary

	| anAccount aTransferingAccount anAccountSummaryReport |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Transfer register: 100 from: aTransferingAccount to: anAccount.

	anAccountSummaryReport := AccountSummaryReport for: anAccount.

	self assert: anAccountSummaryReport value equals: 
	'Entrada por transferencia de 100.', String newLineString , 'Balance = 100' .! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:31:31' prior: 50764818!
test05AccountWithTransferOutHasValidAccountSummary

	| anAccount aTransferingAccount anAccountSummaryReport |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Transfer register: 100 from: aTransferingAccount to: anAccount.

	anAccountSummaryReport := AccountSummaryReport for: aTransferingAccount.

	self assert: anAccountSummaryReport value equals: 
	'Salida por transferencia de 100.', String newLineString , 'Balance = -100' .! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:31:54' prior: 50764845!
test06AccountWithAllPossibleTransactionsHasValidAccountSummary

	| anAccount aTransferingAccount anAccountSummaryReport |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	anAccountSummaryReport := AccountSummaryReport for: anAccount.

	self assert: anAccountSummaryReport value equals: 
	'Depsito por 50.', String newLineString ,
	'Extraccin por 25.', String newLineString ,
	'Entrada por transferencia de 100.', String newLineString ,
	'Salida por transferencia de 10.', String newLineString ,
	 'Balance = 115'.! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:32:46' prior: 50764913!
test07EmptyPortfolioHasEmptyAccountSummary

	| aPortfolio anAccountSummaryReport |

	aPortfolio := Portfolio new.
	
	anAccountSummaryReport := AccountSummaryReport for: aPortfolio.

	self assert: anAccountSummaryReport value equals: 'Balance = 0'.! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:33:24' prior: 50764936!
test08PortfolioWithOneAccountHasTheAccountSummary

	| anAccount aTransferingAccount aPortfolio anAccountSummaryReport |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.

	anAccountSummaryReport := AccountSummaryReport for: aPortfolio.

	self assert: anAccountSummaryReport value equals: 
	'Depsito por 50.', String newLineString ,
	'Extraccin por 25.', String newLineString ,
	'Entrada por transferencia de 100.', String newLineString ,
	'Salida por transferencia de 10.', String newLineString ,
	 'Balance = 115'.
! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:33:59' prior: 50765003!
test09PortfolioWithManyAccountsHasTheAccountsSummary

	| anAccount aTransferingAccount aPortfolio anAccountSummaryReport |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.
	aPortfolio add: aTransferingAccount.

	anAccountSummaryReport := AccountSummaryReport for: aPortfolio.

	self assert: anAccountSummaryReport value equals: 
	'Depsito por 50.', String newLineString ,
	'Extraccin por 25.', String newLineString ,
	'Entrada por transferencia de 100.', String newLineString ,
	'Salida por transferencia de 10.', String newLineString ,
	'Salida por transferencia de 100.', String newLineString ,
	'Entrada por transferencia de 10.', String newLineString ,
	'Balance = 25'.
! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:34:30' prior: 50765034!
test10PortfolioWithPortfolioWithAccountsHasTheAccountsSummary

	| anAccount aTransferingAccount aPortfolio anotherPortfolio anAccountSummaryReport |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	anotherPortfolio := Portfolio new.
	anotherPortfolio add: anAccount.

	aPortfolio := Portfolio new.
	aPortfolio add: anotherPortfolio.

	anAccountSummaryReport := AccountSummaryReport for: aPortfolio.

	self assert: anAccountSummaryReport value equals: 
	'Depsito por 50.', String newLineString ,
	'Extraccin por 25.', String newLineString ,
	'Entrada por transferencia de 100.', String newLineString ,
	'Salida por transferencia de 10.', String newLineString ,
	'Balance = 115'.
! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:34:50' prior: 50765072!
test11EmptyAccountHasEmptyNetTransferReport

	| anAccount |
	
	anAccount := ReceptiveAccount new.

	self assert: anAccount netTransferReport equals: 'Neto de transferencia = 0'.
! !
!NetTransferReport methodsFor: 'no messages' stamp: 'mr 10/26/2019 19:35:49'!
value

	! !

ReceptiveAccount removeSelector: #accountSummaryReport!

Portfolio removeSelector: #accountSummaryReport!
!NetTransferReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:39:12' prior: 50765771!
value

	^ 'Neto de transferencia = ', (account transactions inject: 0 into: [ :amount :aTransaction | amount + aTransaction reportInfoFor: self ]) asString.! !
!NetTransferReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:39:48'!
forDeposit: aDeposit

	^ 0.! !
!NetTransferReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:40:00'!
forWithdraw: aWithdraw

	^ 0.! !
!NetTransferReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:40:38'!
forTransferIn: aTransferIn

	^ aTransferIn value.! !
!NetTransferReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:40:55'!
forTransferOut: aTransferOut

	^ aTransferOut value negated.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:41:35' prior: 50765499!
forTransferIn: aTransferIn

	^ 'Entrada por transferencia de ', aTransferIn value asString, '.'.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:41:55' prior: 50765505!
forTransferOut: aTransferOut

	^ 'Salida por transferencia de ', aTransferOut value asString, '.'.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:42:25' prior: 50765511!
forWithdraw: aWithdraw

	^ 'Extraccin por ', aWithdraw value asString, '.'.! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:44:17' prior: 50765762!
test11EmptyAccountHasEmptyNetTransferReport

	| anAccount aTransferReport |
	
	anAccount := ReceptiveAccount new.
	
	aTransferReport := NetTransferReport for: anAccount .

	self assert: anAccount netTransferReport equals: 'Neto de transferencia = 0'.
! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:44:42' prior: 50765825!
test11EmptyAccountHasEmptyNetTransferReport

	| anAccount aTransferReport |
	
	anAccount := ReceptiveAccount new.
	
	aTransferReport := NetTransferReport for: anAccount .

	self assert: aTransferReport value equals: 'Neto de transferencia = 0'.
! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:45:03' prior: 50765105!
test12AccountWithTransferInHasValidNetTransferReport

	| anAccount aTransferingAccount aTransferReport |

	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.
	
	Transfer register: 100 from: aTransferingAccount to: anAccount.

	aTransferReport := NetTransferReport for: anAccount .

	self assert: aTransferReport value equals: 'Neto de transferencia = 100'.
! !
!NetTransferReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:45:42' prior: 50765778!
value

	^ 'Neto de transferencia = ', (account transactions inject: 0 into: [ :amount :aTransaction | amount + (aTransaction reportInfoFor: self) ]) asString.! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:46:05' prior: 50765157!
test13AccountWithTransferOutHasValidNetTransferReport

	| anAccount aTransferingAccount aTransferReport |

	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.
	
	Transfer register: 100 from: aTransferingAccount to: anAccount.

	aTransferReport := NetTransferReport for: anAccount .

	self assert: aTransferReport value equals: 'Neto de transferencia = -100'.
! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:46:30' prior: 50765873!
test13AccountWithTransferOutHasValidNetTransferReport

	| anAccount aTransferingAccount aTransferReport |

	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.
	
	Transfer register: 100 from: aTransferingAccount to: anAccount.

	aTransferReport := NetTransferReport for: aTransferingAccount .

	self assert: aTransferReport value equals: 'Neto de transferencia = -100'.
! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:46:45' prior: 50765170!
test14AccountWithDepositHasValidNetTransferReport

	| anAccount aTransferReport |

	anAccount := ReceptiveAccount new.
	Deposit register: 100 on: anAccount.

	aTransferReport := NetTransferReport for: anAccount .

	self assert: aTransferReport value equals: 'Neto de transferencia = 0'.
! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:47:09' prior: 50765180!
test15AccountWithWithdrawHasValidNetTransferReport

	| anAccount aTransferReport |

	anAccount := ReceptiveAccount new.
	Withdraw register: 100 on: anAccount.

	aTransferReport := NetTransferReport for: anAccount .

	self assert: aTransferReport value equals: 'Neto de transferencia = 0'.
! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:47:45' prior: 50765214!
test16AccountWithAllTransactionsHasValidNetTransferReport

	| anAccount aTransferingAccount aTransferReport |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	aTransferReport := NetTransferReport for: anAccount .

	self assert: aTransferReport value equals: 'Neto de transferencia = 90'.
! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:48:26' prior: 50765241!
test17EmptyPortfolioHasValidNetTransferReport

	| aPortfolio aTransferReport |

	aPortfolio := Portfolio new.
	
	aTransferReport := NetTransferReport for: aPortfolio.

	self assert: aTransferReport value equals: 'Neto de transferencia = 0'.
! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:48:49' prior: 50765320!
test18PortfolioWithOneAccountHasValidNetTransferReport

	| anAccount aTransferingAccount aPortfolio aTransferReport |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	aPortfolio := Portfolio new.
	aPortfolio  add: anAccount.

	aTransferReport := NetTransferReport for: aPortfolio.

	self assert: aTransferReport value equals: 'Neto de transferencia = 90'.
! !
!AccountReportTest methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:49:09' prior: 50765361!
test19PortfolioWithManyAccountHasValidNetTransferReport

	| anAccount aTransferingAccount aPortfolio aTransferReport |
	
	anAccount := ReceptiveAccount new.
	aTransferingAccount := ReceptiveAccount new.

	Deposit register: 50 on: anAccount.
	Withdraw register: 25 on: anAccount. 
	Transfer register: 100 from: aTransferingAccount to: anAccount.
	Transfer register: 10 from: anAccount to: aTransferingAccount.

	aPortfolio := Portfolio new.
	aPortfolio add: anAccount.
	aPortfolio add: aTransferingAccount.
	
	aTransferReport := NetTransferReport for: aPortfolio.

	self assert: aTransferReport value equals: 'Neto de transferencia = 0'.
! !

Portfolio removeSelector: #netTransferReport!

ReceptiveAccount removeSelector: #netTransferReport!
!AccountReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:50:52'!
forDeposit: aDeposit

	self subclassResponsibility.! !
!AccountReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:51:10'!
forWithdraw: aWithdraw

	self subclassResponsibility.! !
!AccountReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:51:26'!
forTransferIn: aTransferIn

	self subclassResponsibility.! !
!AccountReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 19:51:35'!
forTransferOut: aTransferOut

	self subclassResponsibility.! !
!Account methodsFor: 'nil' stamp: 'mr 10/26/2019 20:03:08'!
forEachTransactionsDo: aClosureToRun andInjectInto: anAccumulator

	^ self transactions ! !
!Account methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:03:43' prior: 50766030!
forEachTransactionsDo: aClosureToRun andInjectInto: anAccumulator

	^ self transactions inject: anAccumulator into: aClosureToRun.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:06:11' prior: 50765566!
value

	^ (account forEachTransactionsDo:  [ :report : aTransaction | report, (aTransaction reportInfoFor: self), 
										     String newLineString ] andInjectInto: String new ), 
	'Balance = ', account balance asString.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:06:33' prior: 50766044!
value

	^ (account forEachTransactionsDo:  [ :report : aTransaction | report, (aTransaction reportInfoFor: self), 
										     String newLineString ] 
				andInjectInto: String new ), 
	'Balance = ', account balance asString.! !
!NetTransferReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:08:05' prior: 50765864!
value

	
	^ 'Neto de transferencia = ', (account forEachTransactionsDo: [ :amount :aTransaction | amount + (aTransaction reportInfoFor: self) ] andInjectInto: 0 ) asString.! !
!NetTransferReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:08:09' prior: 50766066!
value

	
	^ 'Neto de transferencia = ', (account forEachTransactionsDo: [ :amount :aTransaction | amount + (aTransaction reportInfoFor: self) ] andInjectInto: 0) asString.! !
!NetTransferReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:08:49' prior: 50766075!
value

	
	^ 'Neto de transferencia = ', (account forEachTransactionsDo: [ :amount :aTransaction | amount + (aTransaction  
																		reportInfoFor: self) ] 
											andInjectInto: 0) asString.! !
!NetTransferReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:10:11'!
netTransfer

	^(account forEachTransactionsDo: [ :amount :aTransaction | amount + (aTransaction  
																	reportInfoFor: self) ] 
											andInjectInto: 0).! !
!NetTransferReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:10:32' prior: 50766084!
value

	
	^ 'Neto de transferencia = ', self netTransfer asString.! !
!NetTransferReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:10:56' prior: 50766103!
value
	
	^ 'Neto de transferencia = ', self netTransfer asString.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:12:08'!
transactionsDescriptions
	
	^(account forEachTransactionsDo:  [ :report : aTransaction | report, (aTransaction reportInfoFor: self), 
										     String newLineString ] 
				andInjectInto: String new ).
	! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:12:19' prior: 50766114!
transactionsDescriptions
	
	^account forEachTransactionsDo:  [ :report : aTransaction | report, (aTransaction reportInfoFor: self), 
										     String newLineString ] 
				andInjectInto: String new .
	! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:12:21' prior: 50766124!
transactionsDescriptions
	
	^ account forEachTransactionsDo:  [ :report : aTransaction | report, (aTransaction reportInfoFor: self), 
										     String newLineString ] 
				andInjectInto: String new .
	! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:12:59' prior: 50766055!
value

	^ self transactionsDescriptions , 
	'Balance = ', account balance asString.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:13:10' prior: 50766144!
value

	^ self transactionsDescriptions , 'Balance = ', account balance asString.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:13:19' prior: 50766150!
value

	^ self transactionsDescriptions, 'Balance = ', account balance asString.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:14:02'!
balanceDescription

	^'Balance = ', account balance asString.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:14:08' prior: 50766162!
balanceDescription

	^ 'Balance = ', account balance asString.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'mr 10/26/2019 20:14:34' prior: 50766156!
value

	^ self transactionsDescriptions, self balanceDescription.! !

----SNAPSHOT----(26 October 2019 20:16:55) clase2.image priorSource: 13858304!